{
    "__type__": "Deck",
    "activeTags": [],
    "children": [],
    "crowdanki_uuid": "eee58b04-e5c4-11ea-8fe2-e4a7a0580719",
    "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0,
                    1440.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.75
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": true,
                "delays": [
                    2.0,
                    10.0,
                    1440.0,
                    4320.0
                ],
                "initialFactor": 2500,
                "ints": [
                    4,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 50,
                "separate": true
            },
            "newGatherPriority": 0,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "replayq": true,
            "rev": {
                "bury": true,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 500
            },
            "reviewOrder": 0,
            "timer": 0
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 101,
    "extendRev": 0,
    "inactiveTags": [],
    "media_files": [],
    "mid": "1595711725854",
    "name": "GA Tech OMSCS::GIOS",
    "newLimit": null,
    "newLimitToday": null,
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "css": ".card {\n  font-family: arial;\n  font-size: 20px;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n.cloze {\n  font-weight: bold;\n  color: blue;\n}\n\n.cloze-inactive {\n  color: darkslateblue;\n}\n\n.nightMode .cloze {\n  color: lightblue;\n}\n\nul,\nol {\n  display: block;\n  text-align: left;\n  list-style: inside;\n}\n\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n\ntd[colspan]:not([colspan=\"1\"]) {\n    text-align: center;\n}\n\ncode {\n  display: inline-block;\n  white-space: pre;\n  text-align: left;\n  tab-size: 3;\n  background: rgba(7,7,7,0.2);\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Text",
                    "ord": 0,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Extra",
                    "ord": 1,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "OMSCS Cloze",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [],
            "tmpls": [
                {
                    "afmt": "<h6>{{Deck}}</h6>\n{{cloze:Text}}<br><br>\n{{Extra}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Cloze",
                    "ord": 0,
                    "qfmt": "<h6>{{Deck}}</h6>\n{{cloze:Text}}"
                }
            ],
            "type": 1,
            "vers": []
        }
    ],
    "notes": [
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Handling Partial Failures</h2>\n<p>RPC systems incorporate a special {{c1::error notification}} that tries to capture what went wrong with an RPC request without claiming to provide the exact detail.</p>",
                ""
            ],
            "guid": "?{XX$KQ$C",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Interrupts as Threads</h2>\n<p>There are two components of signal handling:</p>\n<ul>\n<li>{{c1::The <strong>top half</strong> of signal handling occurs in the context of the interrupted thread (before the handler thread is created). This half must be fast, non-blocking, and include a minimal amount of processing.}}<br></li>\n<li>{{c2::Once we have created our thread, this <strong>bottom half</strong> can contain arbitrary complexity, as we have now stepped out of the context of our main program into a separate thread.}}<br></li>\n</ul>",
                ""
            ],
            "guid": "A%ZJv<}MN%",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>OS Protection Boundary</h2>\nOperating systems also support {{c1::signals}}, which is a way for the operating system to send notifications to the application.",
                ""
            ],
            "guid": "A0J_#wz}dD",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Rationale For Data Structures</h2>\n<p>Multiple data structures:</p>\n<ul>\n<li>{{c1::smaller data structures}}</li>\n<li>{{c2::easier to share}}</li>\n<li>{{c3::save and restore only what needs to change on context switch}}</li>\n<li>{{c4::user-level library only needs to update a portion of the state for customized behavior}}</li>\n</ul>",
                ""
            ],
            "guid": "ACZsP;o1k+",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Binding and Registry</h2>\n<p>Binding is the mechanism used by the client to determine which server to connect to, based on the {{c1::<b>service name</b>}} and the {{c2::<b>version number</b>}}.</p>",
                ""
            ],
            "guid": "AC]InJf{J_",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Run To Completion Scheduling</h2>\n<p>When it comes to comparing schedulers, some common metrics include:</p>\n<ul>\n<li>{{c1::throughput}}</li>\n<li>{{c2::average job completion time}}</li>\n<li>{{c3::average job wait time}}</li>\n<li>{{c4::CPU utilization}}</li>\n</ul>",
                ""
            ],
            "guid": "AZlg;~uML~",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>Stateless vs Stateful File Server</h2>\n<p>A stateless server keeps no state. It has no notion of:</p>\n<ul>\n<li>{{c1::which files/blocks are being accessed}}</li>\n<li>{{c2::which operations are being performed}}</li>\n<li>{{c3::how many clients are accessing how many files}}</li>\n</ul>",
                ""
            ],
            "guid": "AtHxvtiO6!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>NFS Versions</h2>\n<p>NFS uses a {{c1::lease-based}} mechanism to support locking.</p>",
                "NFSv4 also supports a reader/writer lock called \"share reservation\"."
            ],
            "guid": "AzjC&aPpTg",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Defining Virtualization</h2>\n<h3>The virtual machine monitor (VMM) has three responsibilities:</h3>\n<ul>\n<li>{{c1::<b>fidelity</b> - an environment that is essentially identical to the original machine.}}</li>\n<li>{{c2::<b>performance</b> - provide performance to the VMs that is as close to native performance as possible.}}</li>\n<li>{{c3::<b>safety and isolation</b> - provided among the VMs.}}</li>\n</ul>",
                ""
            ],
            "guid": "B<*{tr]0NM",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Atomic Instructions</h2>\n<p>Each type of hardware will support a number of atomic instructions. Some examples include</p>\n<ul>\n<li><code>{{c1::test_and_set}}</code></li>\n<li><code>{{c2::read_and_increment}}</code></li>\n<li><code>{{c3::compare_and_swap}}</code></li>\n</ul>",
                ""
            ],
            "guid": "BJ<.[<J&3f",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Architecture</h2>\n<p>Every address in this system will be uniquely identified by a combination of the {{c1::<b>node identifier</b>}} and the {{c2::<b>page frame number</b>}}.</p>",
                ""
            ],
            "guid": "BzY=Ue*B`8",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>I/O Devices</h2>\n<p>I/O devices are components are specifically tied to {{c1::receiving inputs or directing outputs}}.</p>",
                ""
            ],
            "guid": "B|pw[KK2NI",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Weak Consistency</h2>\n<p>A system may provide an {{c1::exit/release}} point, which can be invoked when a particular process wishes to {{c2::release to all other processors}} {{c3::the updates that it has made}}.</p>",
                ""
            ],
            "guid": "C:;W3gK)@=",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Event-Driven Model</span></h2></div><div>Both sockets and files are represented by {{c1::file descriptors}}.<br></div>",
                ""
            ],
            "guid": "CdVMmkj&yi",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Internet Service Architectures</h2>\n<p>Behind the load balancer, there can be one or two different setups:</p>\n<ul>\n<li>{{c1::a <b>homogenous</b> setup, all nodes are able to execute any possible step in the request processing pipeline}}</li>\n<li>{{c1::a <b>heterogenous</b> setup, nodes execute some specific steps in the request processing, for only some request types}}</li>\n</ul>",
                ""
            ],
            "guid": "CzfCCcR_Fh",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Linux O(1) Scheduler</h2>\nThe runqueue in the O(1) scheduler is implemented as two arrays of tasks:\n<ul>\n<li>{{c1::active}}</li>\n<li>{{c1::expired}}</li>\n</ul>",
                ""
            ],
            "guid": "DK-k4_T7;!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>DFS Models</h2>\n<p>In a {{c1::<b>partitioned</b>}} system, adding capacity can be done by adding more machines. This makes {{c1::<b>partitioned</b>}} systems more {{c2::<b>scalable</b>}}.</p>",
                ""
            ],
            "guid": "DM`t7.DpU6",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>NFS Versions</h2>\n<p>NFSv3 is {{c1::<b>stateless</b>}}, whereas NFSv4 is {{c1::<b>stateful</b>}}.</p>",
                "Since NFSv4 is stateful, it can support operations like file caching and file locking."
            ],
            "guid": "DR`AlKE?DW",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>How is PCB Used?</h2>\nEach time the operating system switches between processes, we call this a {{c1::context switch}}.",
                ""
            ],
            "guid": "DZ^rp5R+cm",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>Inter Process Communication</h2>\n<p>IPC mechanisms are broadly categorized as either {{c1::<b>message-based</b>}} or {{c2::<b>memory-based</b>}}.</p>",
                ""
            ],
            "guid": "Dc~K=+L*bF",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Kernel Level Structures in Solaris 2.0</h2>\n<p>The data contained in an <strong>LWP</strong> includes:</p>\n<ul>\n<li>{{c1::user level registers}}</li>\n<li>{{c2::system call arguments}}</li>\n<li>{{c3::resource usage info}}</li>\n<li>{{c4::signal masks}}</li>\n</ul>",
                "<div>A light-weight process (LWP) contains data that is relevant for some subset of the user threads in a given process.<br></div>"
            ],
            "guid": "Do_z$0>U5B",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>NFS Versions</h2>\n<p>NFSv4 incorporates a {{c1::<b>delegation</b>}} mechanism where the server grants to the client all rights to manage a file for a given period of time.</p>",
                "This avoids the need for periodic update checks."
            ],
            "guid": "E;2*3N?8u<",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Interrupts and Signals Intro</h2>\n<p>Interrupts appear {{c1::asynchronously}}. That is, they do not appear in response to any specific action that is take place on the CPU.</p>",
                ""
            ],
            "guid": "E<If>ETmX:",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Benefits of RPC</h2>\n<ul>\n<li>offers a {{c1::high-level interface}}&nbsp;for {{c2::data movement}} and {{c2::communication}}</li>\n<li>{{c3::handles}}&nbsp;a lot of the {{c3::errors}}&nbsp;that may arise from {{c4::low-level communication/transmission interactions}}</li>\n<li>{{c5::hides complexities}}&nbsp;of {{c6::cross-machine interactions}}</li>\n</ul>",
                ""
            ],
            "guid": "ESheKIrkEq",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1><h2>Defining Virtualization</h2><br><p>A virtual machine is an {{c1::<b>efficient</b>}}, {{c2::<b>isolated</b>}} duplicate of a real machine.</p>",
                ""
            ],
            "guid": "EVH3cG^vgj",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Pointers in RPC</h2>\n<p>Pointers can be used in RPCs by having the marshaling process include the {{c1::<b>referenced data</b>}} - not the {{c1::<b>pointer</b>}} - into the transmitted buffer.</p>",
                ""
            ],
            "guid": "EuSMMI}FCN",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Segmentation</h2>\n<p>The selector is used in combination with a {{c1::descriptor table}} to produce a physical address which is combined with the offset to describe a precise memory location.</p>",
                ""
            ],
            "guid": "E|dpIUa!q?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Device Virtualization</h2>\n<p>There is a significant level of standardization at the {{c1::instruction set architecture (ISA)}} level across different platforms.</p>",
                ""
            ],
            "guid": "F(,vQ;y!y/",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Processor Virtualization</h2>\n<p>With a {{c1::<b>trap-and-emulate</b>}} strategy, for allowed privileged operations, the hypervisor provides necessary emulation.</p>",
                ""
            ],
            "guid": "F*Y]+)Xt~Q",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Cloud Service Models</h2>\n<ul>\n<li>{{c1::<b>Software}}</b> as a Service ({{c1::SaaS}}) provides {{c2::a complete application}}</li>\n<li>{{c1::<b>Platform}}</b> as a Service ({{c1::PaaS}}) provides {{c3::an environment for your applications}}</li>\n<li>{{c1::<b>Infrastructure}}</b> as a Service ({{c1::IaaS}}) provides {{c4::things like compute instances, storage and network}}</li>\n</ul>",
                ""
            ],
            "guid": "F-f*Y}OOd`",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Spinlock Performance Metrics</h2>\n<p>{{c1::Contention}} is the {{c2::vying for a resource}} due to {{c3::the actual atomic memory references}} as well as the subsequent {{c4::coherence traffic}}.</p>",
                "<div>Contention is bad because it will delay any other CPU that is trying to access memory. Most pertinent to our use case though, contention will also delay the acquisition and release of the spinlock.</div>"
            ],
            "guid": "FJ-y88Ki43",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Linux CFS Scheduler</h2>\nCFS uses a {{c1::red-black tree}} as a runqueue structure.",
                ""
            ],
            "guid": "FLe2H}Q$(/",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Tables</h2>\n<p>The VPN is used as an index into the page table, which will produce the {{c1::physical frame number (PFN)}}, which is the first physical address of the frame in DRAM.</p>",
                ""
            ],
            "guid": "FP<6R,RMH+",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Hardware Virtualization</h2>\n<h3>Virtualization-friendly architectures added:</h3>\n<ul>\n<li>close the holes with the 17 {{c1::non-virtualizable hardware instructions}}</li>\n<li>new protection mode: {{c2::\"root\" and \"non-root\" (AKA \"host\" and \"guest\")}}</li>\n<li>{{c3::hardware processor}} to interpret the state of the {{c3::virtual processors (or vCPUs)}}</li>\n<li>tag the {{c4::memory structures}} used by the hypervisor with the different VM identifiers</li>\n<li>better support for {{c5::I/O}} virtualization</li>\n<li>better security and {{c6::management}} support</li>\n<li>new {{c7::instructions}} were added to {{c7::x86}} in order to implement these new features (e.g. switching protection modes)</li>\n</ul>",
                ""
            ],
            "guid": "Ff}0XM6aFa",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>OS Bypass</h2>\n<p>Normally, the kernel performs the {{c1::demultiplexing}}, but in OS bypass that responsibility is left to the device itself.</p>",
                ""
            ],
            "guid": "F~Y=(|r3;M",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Picking a Delay</h2>\n<p>A {{c1::<b>static delay</b>}} is based on some fixed information, such as the CPU ID where the process is running.</p>",
                ""
            ],
            "guid": "G&?H>O~O^a",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>Inter Process Communication</h2>\n<p>{{c1::Remote procedure calls (RPC)}} are an IPC mechanism that provides higher level semantics.</p>",
                "This method provides some additional detail as to the protocol(s) that will be used, which includes information about the data format and the data exchange procedure."
            ],
            "guid": "G)ATk<7xH&",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication",
                "leech"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Hyperthreading</h2>\n<p>Hyperthreading is referred to by many names:</p>\n<ul>\n<li>{{c1::hardware multithreading}}</li>\n<li>{{c1::hyperthreading}}</li>\n<li>{{c2::chip multithreading (CMT)}}</li>\n<li>{{c2::simultaneous multithreading (SMT)}}</li>\n</ul>",
                ""
            ],
            "guid": "G+)(8Lf=NK",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>System Call Flow</h2>\nIn {{c1::synchronous mode}}, the process waits until the system call completes.",
                ""
            ],
            "guid": "G51DXub7tz",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Virtualization Models: Bare Metal</h2>\n<p>In bare-metal virtualization (also known as {{c1::<b>hypervisor-based</b>}} or {{c2::<b>type 1 virtualization</b>}}), the VMM manages all the hardware resources and support execution of VMs.</p>",
                ""
            ],
            "guid": "G9{9r=HYT3",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Goals</h2>\n<p>In {{c1::page-based memory management}} the arbitration is done via {{c2::page tables}}.</p>",
                ""
            ],
            "guid": "GRu3XR+Ba)",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>{{c1::Interrupts}} and Signals Intro</h2>\n<p>{{c1::Interrupts}} are events that are generated {{c2::externally}} by components other than the CPU to which the {{c1::interrupt}} is delivered.</p>",
                "Interrupts are notifications that some external event has occurred."
            ],
            "guid": "Gb.u,1CF(9",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Spinlock Performance Metrics</h2>\n<p>We can define {{c1::<b>latency</b>}} as {{c2::<b>the time it takes a thread to acquire a free lock</b>}}.</p>",
                "We want the spinlock to have&nbsp;<em>low latency</em>."
            ],
            "guid": "GjZQdnhmfP",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>SunRPC Registry</h2>\n<p>In SunRPC, the registry process runs on every machine, and is called {{c1::portmapper}}.</p>",
                ""
            ],
            "guid": "Gvp$H8O70_",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Hardware Protection Levels</h2>\n<p>Attempts by the guest OS to perform privileged operations cause traps called {{c1::<b>VMExits</b>}}.</p>",
                "These trigger a switch to root mode, passing control to the hypervisor."
            ],
            "guid": "H&,i@KmQSe",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Performance Considerations</h1>\n<h2>Helper Threads And Processes</h2><div><b>AMPED</b>&nbsp;stands for {{c1::Asymmetric Multi-Process Event-Driven Model}}.<br></div>\n",
                "The multithreaded equivalent acronym is AMTED."
            ],
            "guid": "HXu!~8-za0",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>Sprite DFS Access Pattern Analysis</h2>\n<p>The Sprite DFS authors found that {{c1::33}}% of all file accesses are writes.</p>",
                ""
            ],
            "guid": "Hfn_dEtu@3",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Virtual File system Abstractions</h2>\n<p>The {{c1::superblock}} abstraction provides information about how a particular filesystem is laid out on some storage device.</p>",
                ""
            ],
            "guid": "Hq^l/9vJW/",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Hardware vs Software DSM</h2>\n<p>Software based DSM has to:</p>\n<ul>\n<li>detect {{c1::local vs remote memory accesses}}</li>\n<li>{{c2::create and send messages}} to the appropriate node</li>\n<li>accept messages from other nodes and perform the {{c3::encoded memory operations}}</li>\n<li>be involved in {{c4::memory sharing}} and {{c4::consistency support}}</li>\n</ul>",
                ""
            ],
            "guid": "H|7{@]39MU",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Preemptive Scheduling: SJF + Preempt</h2>\n<p>A {{c1::windowed average}} is {{c2::the average execution time over the past n times}}.</p>",
                ""
            ],
            "guid": "H~PQ|r?KJ[",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction To Operating Systems</h1>\n<h2>Monolithic OS</h2>\nMonolithic OS Pros/Cons\n<br><br><ul>\n<li>Pros</li>\n<ul>\n<li>{{c1::Everything included}}</li>\n<li>{{c2::Inlining, compile-time optimizations}}</li>\n</ul>\n<li>Cons</li>\n<ul>\n<li>{{c3::No customization}}</li>\n<li>{{c4::Not too portable/manageable}}</li>\n<li>{{c5::Large memory footprint (which can impact performance)}}</li>\n</ul>\n</ul>\n",
                ""
            ],
            "guid": "H~]`Rot^0`",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>If I really just care about money, I can look at {{c1::performance per dollar}}.<br></div>",
                ""
            ],
            "guid": "I(;ldT~QQu",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Semaphores</h2>\n<p>Semaphores allows us to express {{c1::count related synchronization requirements}}.</p>",
                "<div>The number of threads that will be allowed to proceed at a given time will equal the initialization value of the semaphore.</div><div>When a thread leaves the critical section, it signals the semaphore, which will increment the semaphore's counter.</div>"
            ],
            "guid": "I+I_ML!Y]l",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Inverted Page Tables</h2>\n<p>Inverted page tables are often supplemented with {{c1::hashing page tables}}.</p>",
                "Hashing page tables speed up the linear search of an inverted page table to consider just a few possibilities."
            ],
            "guid": "I8r6]@f(Y9",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Cache Coherence</h2>\n<p>Hardware using the {{c1::<b>write-invalidate (WI)</b>}} strategy will {{c1::invalidate}}&nbsp;{{c2::all cache entries of X once one CPU updates its copy of X}}.</p>",
                "Future references to invalidated cache entries will have to pass through to main memory before being re-cached."
            ],
            "guid": "I:-_+.|)>l",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span><br></h2><div>{{c1::A&nbsp;<b>testbed</b>}}&nbsp;is {{c2::a set of \"toy\" experiments that are&nbsp;<em>representative</em>&nbsp;of realistic situations that we may encounter}}.<br></div>",
                ""
            ],
            "guid": "I;<`s-6;:a",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Cloud Computing Poster Child: Animoto</h2>\n<p>In 2006, Amazon opened up access to its hardware resources via web-based APIs.&nbsp;This was the birth of {{c1::<b>Amazon Web Services (AWS)</b>}} and {{c2::<b>Amazon Elastic Cloud Compute (EC2)</b>}}.</p>",
                ""
            ],
            "guid": "I<$<S9ZJCR",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Event-Driven Model</span></h2></div><div>{{c1::An&nbsp;<strong>event dispatcher</strong>}}&nbsp;{{c2::looks for incoming events in a loop}}&nbsp;and then {{c3::based on those events invokes one or more of the registered handlers}}.<br></div>",
                ""
            ],
            "guid": "IJSnPfx_Tj",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling Overview</h2>\nGiving each task some amount of time on the CPU is known as a {{c1::timeslice}}.",
                ""
            ],
            "guid": "IO:w|iI1aM",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Tables</h2>\n<p>The first portion of the virtual address is the {{c1::<b>virtual page number (VPN)</b>}} and is used to index into the page table, and the rest of the of the virtual address is the {{c2::<b>offset</b>}}.</p>",
                ""
            ],
            "guid": "IXNtd+:f+]",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Structure of RPC</h2>\n<p>When the packets are received on the server, they are handed off to the {{c1::server stub}}.</p>",
                "<div>This stub knows how to parse all of the received bytes, and it will make a call in the server process.</div>"
            ],
            "guid": "IXR/(EQy=+",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>File Access Operations in Sprite</h2>\n<p>On a per file basis, the <b>client</b> keeps track of:</p>\n<ul>\n<li>{{c1::cache (overall yes/no)}}</li>\n<li>{{c2::cached blocks}}</li>\n<li>{{c3::timer for each dirty block}}</li>\n<li>{{c4::version number}}</li>\n</ul>",
                ""
            ],
            "guid": "Id8S/uF6km",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Using Reader/Writer Locks</h2>\n<p>Some implementations refer to <b>reader/writer</b> locks as {{c1::shared/exclusive}} locks.</p>",
                ""
            ],
            "guid": "Ix*cpYV/!t",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Hardware Protection Levels</h2>\n<p>When the hypervisor completes its operation, it passes control back to the virtual machine, by performing a {{c1::VMEntry}}, which switches out of root mode.</p>",
                ""
            ],
            "guid": "J$!J(?~UD6",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>File Access Operations in Sprite</h2>\n<p>When a new writer comes along after the first writer has closed the file this is referred to as a {{c1::sequential writer}}.</p>",
                ""
            ],
            "guid": "J1<FS-~_19",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Goals</h2>\n<p>The virtual address space is subdivided into fixed-size segments called {{c1::pages}}.</p>",
                ""
            ],
            "guid": "JL(|`eyo-0",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling Overview</h2>\n<p>Whenever the CPU becomes idle, we need to run the {{c1::scheduler}}.</p>",
                ""
            ],
            "guid": "JW;&uxUQiX",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Causal Consistency</h2>\n<p>The causal consistency model can be refined into four session guarantees as follows:</p>\n<ul>\n<li>{{c1::<b>Read Your Writes}}</b>: If a process {{c2::performs a write}}, the same process later {{c2::observes the result of its write}}.</li>\n<li>{{c1::<b>Monotonic Reads}}</b>: {{c3::the set of writes observed (read) by a process}} is guaranteed to be monotonically non-decreasing.</li>\n<li>{{c1::<b>Writes Follow Reads}}</b>: if some process {{c4::performs a read followed by a write}}, and another process {{c4::observes the result of the write}}, then it can also {{c4::observe the read (unless it has been overwritten)}}.</li>\n<li>{{c1::<b>Monotonic Writes}}</b>: If some process {{c5::performs a write}}, followed some time later by {{c5::another write}}, other processes will {{c5::observe them in the same order}}.</li>\n</ul>",
                ""
            ],
            "guid": "Jt.!+qt42^",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Shared Memory Multiprocessors</h2>\n<p>In a {{c1::<b>write-back</b>}} system, the write will {{c2::immediately apply to the cache, and perform the write in main memory at some later point in time, perhaps when the cache entry is evicted}}.</p>",
                ""
            ],
            "guid": "J}t}LDOCpW",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Copy On Write</h2>\n<p>With Copy-On-Write (COW), a new process's address space, entirely or in part, will just point to {{c1::the address space of its parent.}}</p>",
                "<p>The same physical address may be referred to by two completely different virtual addresses belonging to the two processes. We have to make sure to <strong>write protect</strong> the page as a way to track accesses to it.</p>\n<p>If the page is only going to be read, we save memory and we also save on the CPU cycles we would waste performing the unnecessary copy.</p>\n<p>If a write request is issued for the physical address via either one of the virtual addresses, the MMU will detect that the page is write protected and will issue a page fault.</p>"
            ],
            "guid": "K$|hlc?`R3",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Benefits of Virtualization</h2>\n<ul>\n<li>{{c1::<b>consolidation</b> - ability to run multiple VMs on a single physical platform}}</li>\n<li>{{c2::<b>migration</b> - easy to setup, teardown, and clone virtual machines}}</li>\n<li>{{c3::<b>availability</b> and <b>reliability</b> - easily spin up new VMs on a different physical platform}}</li>\n<li>{{c4::<b>partitioning</b> - contain bugs or malicious code to those isolated containers}}</li>\n<li>{{c5::<b>research</b> - quickly boot up and test OSes in development}}</li>\n<li>{{c6::<b>legacy</b> - no need for a dedicated physical box}}</li>\n</ul>",
                ""
            ],
            "guid": "K/CyuoRNKr",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Shared Memory Multiprocessors</h2>\n<p>In a {{c1::<b>no-write</b>}} system, a write will go {{c2::<b>directly to main memory</b>}}.</p>",
                "Any cache references will be invalidated."
            ],
            "guid": "K2|84,S5j5",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Cache Coherence</h2>\n<p>On {{c1::<b>cache-coherent (CC) architectures</b>}}, the {{c2::<b>hardware</b>}} will take care of all of the necessary steps to ensure that the caches are coherent.</p>",
                "If one CPU writes a new version of&nbsp;X&nbsp;to its cache, the hardware will step in and ensure that the value is updated across CPU caches."
            ],
            "guid": "K?b]~/oZRu",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Types of Signals</h2>\n<p>There are two types of signals:</p>\n<ul>\n<li>{{c1::One-shot signals refer to signals that will only interrupt once. This means that from the perspective of the user level thread, n signals will look exactly like one signal. One-shot signals must also be explicitly re-enabled every time.}}</li>\n<li>{{c2::Real Time Signals refer to signals that will interrupt as many times are they are raised. If n signals occur, the handler will be called n times.}}</li>\n</ul>",
                ""
            ],
            "guid": "KE!JFjc8<<",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Interrupt Handling</h2>\n<p>Most modern devices use a special message, {{c1::Message Signalled Interrupts (MSI)}} that can be carried on the same interconnect that connects the device to the CPU complex.</p>",
                "Based on the pins on where the interrupt is received or the message itself, the interrupt can be uniquely identified."
            ],
            "guid": "KK=Np#eJ#.",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Deadlocks</h2>\n<p>The most ideal solution is to avoid deadlocks is to maintain a {{c1::lock order}}.</p>",
                ""
            ],
            "guid": "Kl}0REHWt8",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Types of Devices</h2>\n<p>Devices can be roughly grouped into categories:</p>\n<ul>\n<li>{{c1::<b>Block</b>}} devices&nbsp;- {{c2::like disks - operate at the granularity of blocks}}<br></li>\n<li>{{c1::<b>Character</b>}}&nbsp;devices&nbsp;- {{c3::like keyboards - work with a serial sequence of characters}}<br></li>\n<li>{{c1::<b>Network</b>}} devices&nbsp;are {{c4::somewhere in between. They are like a stream of data chunks of potentially different sizes}}.<br></li>\n</ul>",
                ""
            ],
            "guid": "Kl}Y_|/ix<",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Memory Virtualization: Full Virtualization</h2>\n<p>In a {{c1::shadow page table}}, the hypervisor re-maps the virtual addresses to machine addresses, without considering the physical addresses.</p>",
                ""
            ],
            "guid": "K~Fi*aU<ni",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Block Device Stack</h2>\n<p>A file is a {{c1::<b>logical</b>}}&nbsp;storage unit which maps to some underlying {{c2::<b>physical</b>}}&nbsp;storage location.</p>",
                ""
            ],
            "guid": "L)t&<lt[5P",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>A&nbsp;<b>metric</b>&nbsp;is a {{c1::measurable or quantifiable property of a system}} that we are interested in that {{c2::can be used to evaluate the system's behavior}}.<br></div>",
                ""
            ],
            "guid": "L8UQ9,`b{D",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Signal Handling</h2>\n<p>The process may specify how a signal can be handled, or the operating system default may be used. Some&nbsp;<b>default signal responses</b>&nbsp;include:</p>\n<ul>\n<li>{{c1::Terminate}}</li>\n<li>{{c1::Ignore}}</li>\n<li>{{c1::Terminate and Core Dump}}</li>\n<li>{{c2::Stop}}</li>\n<li>{{c2::Continue (from stopped)}}</li>\n</ul>",
                ""
            ],
            "guid": "L9wHpH:U&=",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Synchronization Related Issues</h2>\n<p>When a thread exits, the data structures are not immediately freed. Instead the thread is marked as being on {{c1::death row}}. Periodically, a special {{c2::reaper}} thread will perform garbage collection on these thread data structures.</p>",
                "<div>If a request for a thread comes in before a thread on death row is reaped, the thread structure can be reused, which results in some performance gains.<br></div>"
            ],
            "guid": "L@4U1:0R!#",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Spinlock \"Delay\" Alternatives</h2>\n<p>A delay is intended to prevent {{c1::every thread from executing the atomic instruction at the same time}}.</p>",
                ""
            ],
            "guid": "LR`KYj7^7o",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>When looking to incorporate enterprise software into the system, another useful metric may be the {{c1::percentage of SLA violations}}.<br></div>",
                ""
            ],
            "guid": "LZ(sNP_mFB",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Benefits of Multithreading</h2>\n<p>The memory requirements for a multiprocess application are greater than those of a multithreaded application because:\n  A multiprocess application requires a new {{c1::address space for each process}}, while a multithreaded application requires {{c2::only one address space}}.</p>\n",
                ""
            ],
            "guid": "Lj)dczZ7N&",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Basic Thread Mechanisms</h2>\n<p>A {{c1::data race}} is when one thread can try to read the data while another modifies it, which can lead to inconsistencies.</p>",
                ""
            ],
            "guid": "M7RKBTu#%",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Condition Variable API</h2>\n<p>A {{c1::signal}} procedure allows a thread to notify to another thread waiting on a condition that the condition has been met.</p>",
                ""
            ],
            "guid": "M:%QCNwR1s",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Critical Section Structure</h2>\n<p>Unnecessarily waking up a thread when there is no possible way for it proceed is called a {{c1::spurious wake up}}.</p>",
                ""
            ],
            "guid": "MQx,#lA;GG",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Device Drivers</h2>\n<p>Device drivers are {{c1::device-specific software components}}.</p>",
                "The operating systems needs to include a device driver for every type of device that is included in the system."
            ],
            "guid": "M[oO&_Hiz|",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Linux Kernel Allocators</h2>\n<p>The {{c1::buddy}} allocator works by recursively subdividing free memory to find space of the apprpriate size.</p>",
                "The allocator starts with some consecutive memory region that is free that is a power of two. Whenever a request comes in, the allocator subdivides the area into smaller chunks such that every one of them is also a power of two. It will continue subdividing until it finds a small enough chunk that is power of two that can satisfy the request."
            ],
            "guid": "Mi,_yUz/kO",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Run To Completion Scheduling</h2>\n<p>In {{c1::shortest job first&nbsp;(SJF)}} scheduling, jobs are scheduled in order of their execution time.</p>",
                ""
            ],
            "guid": "MsieAOB1h=",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Cache Coherence</h2>\n<p>In {{c1::<b>non-cache-coherent (NCC) architectures</b>}}, {{c2::<b>software</b>}} deals with cache coherency.</p>",
                "<div>For instance, if one CPU writes a new version of X to its cache, the hardware will not update the value across the other CPU caches.</div>"
            ],
            "guid": "Mw5R`N*n*:",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling on Multiprocessors</h2>\n<p>NUMA-aware scheduling keeps tasks {{c1::on the CPU closest to the memory node where their state is, in order to maximize the speed of memory access}}.</p>",
                ""
            ],
            "guid": "N+|XXz@$XT",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Cloud Computing Requirements</h2>\n<p>Goals of cloud computing, summarized:</p>\n<ul>\n<li>{{c1::On-demand}}, {{c1::elastic}} resources and services</li>\n<li>{{c2::Fine-grained}} pricing based on {{c2::usage}}</li>\n<li>Professionally&nbsp;{{c3::managed and hosted}}</li>\n<li>{{c4::API}}-based access</li>\n</ul>",
                ""
            ],
            "guid": "N1K<ziDL.K",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>{{c1::OS Bypass}}</h2>\n<p>{{c1::Operating system bypass}} is {{c2::configuring a device to be accessible directly from user level}}.</p>",
                ""
            ],
            "guid": "N1r*1I*3+5",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Context Switch</h2>\nWhat are the <b>direct</b> and <b>indirect</b> costs of a <i>context switch</i>?<div><ul><li><b>Direct</b>: {{c1::CPU&nbsp;<b>cycles</b>&nbsp;required to load and store a new PCB to and from memory}}</li><li><b>Indirect</b>: {{c2::<b>Cold cache</b>&nbsp;after caching in data for the new process and returning to the original.}}</li></ul></div>",
                ""
            ],
            "guid": "N<WMZxUet]",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Internet Services</h2>\n<p>Many {{c1::middleware}} components exists to connect and coordinate service tiers.</p>",
                ""
            ],
            "guid": "NTjpU9#J0N",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Lightweight Threads paper</h2>\n<p>A {{c1::red zone}} is a portion of the address space that is not allocated.</p>",
                "If a thread tries to write to a red zone, the operating system causes a fault."
            ],
            "guid": "NcR+%LsNB!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Size</h2>\n<p>Default pages in Linux are {{c1::4KB}} in size, requiring an offset of {{c1::12}} bits.</p>",
                ""
            ],
            "guid": "Ni8xb6rhRW",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Performance Considerations</h1><h2>Experimental Methodology</h2><div>{{c1::Connection rate}} is {{c2::the total number of client connections serviced divided by the total amount of time that passed}}.<br></div>",
                ""
            ],
            "guid": "Ni}ASqB@}!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Multithreading</h2>\n<p>In the Many-to-Many Model, a {{c1::bound}} thread is where a user level thread will always be scheduled atop the same kernel level thread.</p>",
                ""
            ],
            "guid": "NqMxSr~;tR",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>What about I/O</h2>\nWhen a process makes an I/O request, the operating system will deliver that request, and move the process to the {{c1::I/O queue}} for that particular I/O device.",
                ""
            ],
            "guid": "NxVVi-pvVC",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Weak Consistency</h2>\n<p>A {{c1::synchronization point}} makes sure that {{c2::all of the updates that have happened and been synchronized on other processors will become visible subsequently at the synchronizing processor in the future}}.</p>",
                ""
            ],
            "guid": "O%ESr|.O%W",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>File Sharing Semantics in DFS</h2>\n<p>In {{c1::<b>session semantics</b>}}, the client writes back whatever data was modified on {{c2::<b>close</b>}}.</p>",
                "Whenever a client needs to&nbsp;open&nbsp;a file, the cache is skipped, and the client checks to see if a more recent version is present on the file server."
            ],
            "guid": "O8nw)O*Nv~",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Steps in RPC</h2>\n<ol start=\"-1\">\n<li>{{c1::<b>register</b> - server registers procedure}}</li>\n<li>{{c2::<b>bind</b> - client finds and binds to server}}</li><li>{{c3::<b>call</b> - client make RPC call}}</li><li>{{c4::<b>marshal</b> - client stub serializes arguments}}</li><li>{{c5::<b>send</b> - client sends message to server}}</li><li>{{c5::<b>receive</b> - server receives message}}</li><li>{{c4::<b>unmarshal</b> - server stub deserializes args}}</li><li>{{c6::<b>actual call</b> - server stub calls local procedure implementation}}</li><li>{{c7::<b>result</b> - server performs operation and computes result}}</li>\n</ol>",
                "Similar steps on return."
            ],
            "guid": "OA~-p5_)QR",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Virtual File system Abstractions</h2>\n<p>The OS abstracts files via {{c1::file descriptors}}.</p>",
                "A file descriptor is an integer that is created when a file is first opened."
            ],
            "guid": "OIC!RNo^Nq",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>Sprint DFS from Analysis to Design</h2>\n<p>The authors decided that Sprite should support {{c1::<b>caching</b>}}, and use a {{c2::<b>write-back</b>}} policy to send changes to the server.</p>",
                ""
            ],
            "guid": "OKNOn=0<-u",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Disk Access Optimizations</h2>\n<p>Filesystems rely on {{c1::buffer caches}} in main memory to reduce the number of disk accesses.</p>",
                ""
            ],
            "guid": "OOuy[+PoqM",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>{{c1::Throughput}} is how many tasks will the platform complete in a given unit of time.<br></div>",
                ""
            ],
            "guid": "OXo&&X!q[^",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Kernel Level Structures in Solaris 2.0</h2>\n<p>For each <strong>process</strong>, the kernel maintains a bunch of information, such as:</p>\n<ul>\n<li>{{c1::list of kernel level threads}}</li>\n<li>{{c2::virtual address space}}</li>\n<li>{{c3::user credentials}}</li>\n<li>{{c4::signal handlers}}</li>\n</ul>",
                ""
            ],
            "guid": "O[f9G$q-.W",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Access Algorithm</h2>\n<p>For {{c1::<b>multiple readers/single writer</b>}} or {{c1::<b>multiple readers/multiple writers</b>}},&nbsp;reads must return the {{c2::<b>most recent value</b>}}, and writes must be {{c3::<b>correctly ordered</b>}}.</p>",
                ""
            ],
            "guid": "OkkOJ74$xE",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Multi Level Page Tables</h2>\n<p>In a hierarchical page table structure, the outer level is referred to as a {{c1::page table directory}}.</p>",
                ""
            ],
            "guid": "OnF0RK3F6|",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Shared Memory IPC</h2>\n<h3>Shared Memory Pros/Cons</h3>\n<p>The operating system establishes a shared memory channel, and then maps it into the address space of both processes.</p>\n<ul>\n<li>Pros:</li><ul><li>{{c1::No OS overhead}}</li></ul>\n<li>Cons:</li><ul><li>{{c2::Protocols provided by message passing (OS level) now have to be implemented in each user level program}}</li></ul>\n</ul>\n",
                ""
            ],
            "guid": "OqE0L2Od(Y",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1><br><h2>Cloud Enabling Technologies</h2><ul><li>{{c1::virtualization}} technologies to provide fungible resources</li><li>resource-{{c2::provisioning}} and -{{c2::scheduling}} technologies. mesos and yarn are technologies that address this issue.</li><li>{{c3::big data}} - process and store large amounts of data. Hadoop, MapReduce, and Spark are popular</li><li>{{c4::distributed filesystems}} - that typically operate in some \"append only\" mode.</li><li>{{c5::isolation}}</li><li>{{c6::monitoring}} technologies - Flume, CloudWatch, Log Insight are all {{c6::monitoring}}  technologies.</li></ul>",
                ""
            ],
            "guid": "OrV-K[If<z",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Process Address Space</h2>\nA {{c1::page table}} is a mapping between the virtual address and the physical address.",
                ""
            ],
            "guid": "P8]p54<z2P",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Encoding</h2>\n<p>An RPC header must contain information about the:</p>\n<ul>\n<li>{{c1::service procedure id}}</li>\n<li>{{c2::version number}}</li>\n<li>{{c3::request id}}</li>\n</ul>",
                "This header will be included in the response from the server as well."
            ],
            "guid": "PGFm5YTPFq",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>ext2: Second Extended Filesystem</h2>\n<p>{{c1::Bitmaps}} are used to quickly find free blocks and inodes.</p>",
                ""
            ],
            "guid": "Pd/qos2jY}",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>Forms of Message Passing</h2>\n<h3>There are several ways to implement message-based IPC:</h3>\n<ul>\n<li>{{c1::Pipes}}</li>\n<li>{{c1::Message Queues}}</li>\n<li>{{c1::Sockets}}</li>\n</ul>",
                ""
            ],
            "guid": "Q:$&:m:FPC",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Process Execution State</h2>\nTo maintain all of this useful information for every single process, the operating system maintains a {{c1::process control block (PCB)}}.",
                ""
            ],
            "guid": "Q<.T_NsHXO",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Pipeline Pattern</h2>\n<p>To balance a pipeline, allocate more threads to {{c1::slower stages}}.</p>",
                "For example, if a step takes three times as long as every other step, we can allocate three times the number of threads to that step."
            ],
            "guid": "Q>EG4oL<|#",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Indexing Distributed State</h2>\n<p>{{c1::Metadata}} for local pages is {{c2::partitioned across the system}}, while {{c1::the manager information}} for every page is {{c2::replicated}}.</p>",
                ""
            ],
            "guid": "Q_#i45y0#t",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>OS Bypass</h2>\n<p>A {{c1::user-level driver}} is like a {{c2::library that the user process links in order to interact with the device}}.</p>",
                ""
            ],
            "guid": "Qn8C:T?jfn",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>SunRPC Overview</h2>\n<p>SunRPC includes a compiler called {{c1::rpcgen}}.</p>",
                "Rpcgen compiles the interface specified in the .x file into language-specific stub for the client and the server."
            ],
            "guid": "Qp)0w;fA-&",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>File Access Operations in Sprite</h2>\n<p>On a per file basis, the <b>server</b> keeps track of:</p>\n<ul>\n<li>{{c1::readers}}</li>\n<li>{{c2::writer}}</li>\n<li>{{c3::version}}</li>\n</ul>",
                ""
            ],
            "guid": "Qy=yGe(Zhm",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Interface Design Language</h2>\n<p>An interface definition language (IDL) serves as a {{c1::protocol of how the client-server agreement will be expressed}}.</p>",
                ""
            ],
            "guid": "b*q.tp+g()",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>RPC Requirements</h2>\n<ul>\n<li>{{c1::synchronous}} call semantics</li>\n<li>type {{c2::checking}}</li>\n<li>hide {{c3::data representation differences}}</li>\n<li>support {{c4::multiple protocols}}</li>\n<li>{{c5::access control}}</li>\n<li>{{c6::authentication}}</li>\n<li>{{c7::fault tolerance}}</li>\n</ul>",
                ""
            ],
            "guid": "b5wLMD$o,|",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Length of Process</h2>\nThe amount of time that has been allocated to a process that is scheduled to run is known as a {{c1::timeslice}}.\n",
                ""
            ],
            "guid": "b7dYPnLRl/",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Boss/Workers Pattern</h2>\n<p>Thread {{c1::locality}} achieves a performance benefit by performing only a subset of the work. Likely only a subset of the state will need to be accessed, and it is more likely this part of the state will already be present in {{c2::CPU cache}}.</p>",
                ""
            ],
            "guid": "bBWwqT(?/c",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>inodes</h2>\n<p>The inode contains a list of all of the {{c1::blocks}} that correspond to the actual file.</p>",
                "In addition to the list of blocks, an inode also contains additional metadata information."
            ],
            "guid": "bKUlBUkirq",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Replacement</h2>\n<p>The default replacement algorithm in Linux is a variation of the LRU policy, which {{c1::gives a second chance.}}</p>",
                "It performs two scans before determining which pages are the ones that should be swapped out."
            ],
            "guid": "bRX6W8[H0^",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Device Access {{c1::PIO}}</h2>\n<p>With just basic support from an interconnect like PCI, a CPU can request an operation from an I/O device using {{c1::programmed I/O (PIO)}}.</p>",
                "The CPU issues instructions by writing into the command registers of the device. The CPU controls data movement to/from the device by reading/writing into the data registers for the device."
            ],
            "guid": "bUsb8QVwf#",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Disk Access Optimizations</h2>\n<p>Content will be written to and read from buffer caches, and periodically will be {{c1::flushed}} to disk.</p>",
                ""
            ],
            "guid": "b~vIRk<h!{",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling on Multiprocessors</h2>\n<p>Non-uniform memory access (NUMA) is a platform where {{c1::different memory nodes have faster access from some processors than others}}.</p>",
                ""
            ],
            "guid": "c9;*kP#=R&",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Size</h2>\n<p>Large pages in Linux are {{c1::2MB}} in size, requiring an offset of {{c1::21}} bits.</p>",
                ""
            ],
            "guid": "cR7m7|SBEK",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: {{c1::Migration}} vs Replication</h2>\n<p>With {{c1::<b>migration</b>}}, whenever a process on another node needs to access remote state, we {{c2::<b>copy the state over to that node</b>}}.</p>",
                ""
            ],
            "guid": "ccEt$p.Y7_",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>x86 Virtualization in the Past</h2>\n<p>Before 2005, x86 platforms had only the four privilege rings, without the {{c1::root/non-root}} distinction.</p>",
                "Some hardware instructions that were privileged (required ring 0), but didn't cause a trap. Issuing them from another protection level wouldn't pass control to the hypervisor, but would just fail silently."
            ],
            "guid": "cent6DmZAq",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Segmentation</h2>\n<p>A virtual address in the segmented memory mode includes a {{c1::segment selector}} and an offset.</p>",
                ""
            ],
            "guid": "ck|TL(RQ%?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>File Sharing Semantics in DFS</h2>\n<p>In order to avoid long periods of inconsistency, the client may write back changes to {{c1::<b>periodically update</b>}} the server.</p>",
                ""
            ],
            "guid": "cng^$f9TG4",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>More Synchronization Constructs</h2>\n<p>{{c1::Serializers}} make it easier to define priorities and also hide the need for explicit signaling and explicit use of condition variables from the programmer.</p>",
                ""
            ],
            "guid": "cq%:G@lpj9",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Round Robin Scheduling</h2>\nRound Robin Scheduling is {{c1::an algorithm which assigns time slices (also known as time quanta) to each process in equal portions and in circular order, handling all processes without priority (also known as cyclic executive)}}.",
                ""
            ],
            "guid": "ct_5r$g=lc",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2>Experimental Methodology</h2></div><div>{{c1::Bandwidth}}<b>&nbsp;</b>measures&nbsp;{{c2::the total number of bytes transferred divided by the total amount of time it takes to transfer those bytes}}.<br></div>",
                ""
            ],
            "guid": "d-kql~@WrC",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Hard and Light Process State</h2>\n<p>In the process control block {{c1::hard process state}} is relevant for {{c2::all user level threads}} in a given process.</p>",
                ""
            ],
            "guid": "d?W{1B8A@[",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>Example <b>metrics</b> are:</div><div><ul><li>CPU {{c1::utilization}}</li><li>{{c1::execution}} time</li><li>{{c1::request}} rate</li><li>{{c1::throughput}}</li></ul></div>",
                ""
            ],
            "guid": "dD?6~l4$PU",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Processes and Process Management</h1><h2>Process Life Cycle: Creation</h2></div><div>Most operating systems support two mechanisms for process creation:</div><div><ul><li>{{c1::<strong>fork:&nbsp;</strong>the operating system will create a new PCB for the child, and then will copy the exact same values from the parent PCB into the child PCB. The result is that both processes will continue executing with the exact same state at the instruction immediately following the fork (they have the same program counter).}}</li><li>{{c2::<strong>exec:&nbsp;</strong>the operating system will take a PCB, but will not leave the values to match those of the parents. Instead operating system loads a new program, and the child's PCB will now point to values that describe this new program. The program counter of the child will now point to the first instruction of the new program.}}</li></ul></div>",
                "<div>For \"creating\" a new program, you have to call fork to get a new process, and then call exec to load that program's information into the child's PCB.</div>"
            ],
            "guid": "dDI4Y--%R4",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Tables</h2>\n<p>The {{c1::CR3 register}} is an x86 hardware register that points to {{c2::the active page table}}.</p>",
                ""
            ],
            "guid": "dSlJ5o?8{z",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Architecture</h2>\n<p>The node where {{c2::a page is located}} is typically referred to as the {{c1::home node}} for that page.</p>",
                ""
            ],
            "guid": "dVb3V9]6J&",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Replacement</h2>\n<p>OS can keep track of the {{c1::dirty bit}} maintained by the MMU hardware which keeps track of whether or not a given page has been modified.</p>",
                "Pages which exist in memory and swap space, and have not been written to since fetching from swap, are still valid in swap and don't need to be written back. The dirty bit keeps track of this."
            ],
            "guid": "d_I<;uTfV?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Linux CFS Scheduler</h2>\nvruntime (virtual runtime) is {{c1::the amount of time that they spent running on the CPU}}.",
                ""
            ],
            "guid": "daEE%Qet-b",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Timesharing and Timeslices</h2>\nA timeslice (also known as a time quantum) is {{c1::the maximum amount of uninterrupted time that can be given to a task}}.",
                ""
            ],
            "guid": "dmee!7R:5F",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>Replication and Partitioning</h2>\n<p>If there is a particular file that is more frequently accessed by most clients in the system, we can run into the issue of {{c1::hotspots}}.</p>",
                ""
            ],
            "guid": "dr(*H>a~l;",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Kernel Level Structures in Solaris 2.0</h2>\n<p>The <strong>kernel level thread</strong> contains:</p>\n<ul>\n<li>{{c1::kernel-level registers}}</li>\n<li>{{c2::stack pointers}}</li>\n<li>{{c3::scheduling info}}</li>\n<li>{{c4::pointers to associated LWPs, and CPU structures}}</li>\n</ul>",
                ""
            ],
            "guid": "dxlB<CF<mk",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>What is Virtualization?</h2>\n<p>Virtualization is a model where {{c1::multiple operating systems}} can {{c2::concurrently be deployed on the same hardware platform}}.</p>",
                ""
            ],
            "guid": "e*tD9&Mtnd",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>What is Virtualization?</h2>\n<p>Each operating system, plus its applications and its virtual resources is called a {{c1::virtual machine (VM)}}.</p>",
                "VMs are sometimes referred to as&nbsp;<em>guests</em>&nbsp;or&nbsp;<em>domains</em>."
            ],
            "guid": "e-r$F;NDiZ",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Internet Services</h2>\n<p>Internet services are divided into three tiers:</p>\n<ul>\n<li>{{c1::presentation}} tier is typically responsible for {{c2::static content related to the webpage layout}}</li>\n<li>{{c1::business logic}} tier integrates all of the {{c3::business-specific processing}}, including all of the {{c3::dynamic, user-specific content}}</li>\n<li>{{c1::database}} tier&nbsp;deals with all of the {{c4::data storage and management}}</li>\n</ul>",
                ""
            ],
            "guid": "e6t8,*Ym]%",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Allocation</h2>\n<p>Kernel level allocators are responsible for {{c1::allocating pages for the kernel and also for certain static state of processes when they are created - the code, the stack and so forth.}}</p>",
                "In addition, the kernel level allocators are responsible for keeping track of the free memory that is available in the system."
            ],
            "guid": "e:($PQ%VRa",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Structure of RPC</h2>\n<p>A {{c1::stub implementation}} will look like the real procedure to the rest of the process.</p>",
                "The stub code itself is automatically generated via some tools that are part of the RPC package; that is, the programmer doesn't have to write the stub code."
            ],
            "guid": "e=pU=4yL`:",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction To Operating Systems</h1>\n<h2>Microkernel OS</h2>\nMicrokernel OS Pros/Cons\n<ul>\n<li>Pros</li>\n<ul>\n<li>{{c1::Size}}</li>\n<li>{{c2::Verifiability (great for embedded devices)}}</li>\n</ul>\n<li>Cons</li>\n<ul>\n<li>{{c3::Bad portability (often customized to underlying hardware)}}</li>\n<li>{{c4::Harder to find common OS components due to specialized use case}}</li>\n<li>{{c5::Expensive cost of frequent user/kernel crossing}}</li>\n</ul>\n</ul>\n",
                ""
            ],
            "guid": "eXa:$QI?|-",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Implementing DSM</h2>\n<p>Whenever an access to a remote address is performed, there will not be&nbsp;{{c1::a valid local mapping}}, and {{c2::the MMU}} will generate a {{c3::trap}}.</p>",
                "The OS will pass the access information to the DSM layer to send out the appropriate remote message."
            ],
            "guid": "e[Ry!]~*c3",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Condition Variable API</h2>\n<p>The condition variable data structure should contain:</p>\n<ul>\n<li>{{c1::mutex reference}}</li>\n<li>{{c1::list of waiting threads}}</li>\n</ul>\n",
                ""
            ],
            "guid": "e]3;r=Hd^5",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1><h2>Process Execution State</h2>The CPU's knowledge of the current executing line within a program is the {{c1::program counter}}.",
                ""
            ],
            "guid": "eil<4(r3}}",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Hardware Support</h2>\n<h3>A {{c1::fault}} can signal that:</h3>\n<ul>\n<li>{{c2::illegal memory access; unallocated memory}}.</li>\n<li>{{c3::insufficient permissions}}.</li>\n<li>{{c4::page is not present in memory and must be fetched from disk}}.</li>\n</ul>",
                ""
            ],
            "guid": "epWDGavdhL",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>File Sharing Semantics in DFS</h2>\n<p>With {{c1::transactions}}, the filesystem exports some API to allow clients to group file updates into a single batch to be applied atomically.</p>",
                ""
            ],
            "guid": "esX`V09VI.",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Architecture</h2>\n<p>The {{c1::owner node}} controls all of the {{c2::state modifications}} and drive the {{c3::coherence mechanisms}} for a given page.</p>",
                ""
            ],
            "guid": "evYl6K*-*C",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Scope of Multithreading</h2>\n<p>Managers have {{c1::process scope}} when they are at the {{c2::user level}}.</p>",
                "The user level library that manages all of the threads for the given process it is linked to. The user level library thread managers cannot see threads outside of their process."
            ],
            "guid": "e|yGgKcUCL",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Kernel Level Structures in Solaris 2.0</h2>\n<p>The <strong>CPU data structure</strong> contains:</p>\n<ul>\n<li>{{c1::current thread}}</li>\n<li>{{c2::list of kernel level threads}}</li>\n<li>{{c3::dispatching &amp; interrupt handing information}}</li>\n</ul>",
                ""
            ],
            "guid": "f0<[pw6N:T",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Memory Virtualization: Full Virtualization</h2>\n<h3>To achieve a linear address space for the guest OS, there three types of addresses:</h3>\n<ul>\n<li>{{c1::<b>virtual}}</b> addresses - {{c2::used by the applications in the guest}}</li>\n<li>{{c1::<b>physical}}</b> addresses - {{c3::used by the kernel of the guest}}</li>\n<li>{{c1::<b>machine}}</b> addresses - {{c4::physical addresses on the underlying physical platform}}</li>\n</ul>",
                ""
            ],
            "guid": "f3JdksfFEl",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Rationale For Data Structures</h2>\n<p>Single control block:</p>\n<ul>\n<li>{{c1::large continuous data structure}}</li>\n<li>{{c2::private for each entity (even though some information can be shared)}}</li>\n<li>{{c3::saved and restored in entirety on each context switch}}</li>\n<li>{{c4::updates may be challenging}}</li>\n</ul>",
                ""
            ],
            "guid": "f4Yw(!+)Ax",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads Case Study - PThreads</h1>\n<h2>Condition Variable Safety Tips</h2>\n<ul>\n<li>Don't forget to {{c1::notify waiting threads!}}</li>\n<li>When in doubt use {{c2::broadcast!}}</li>\n<li>You don't need a {{c3::mutex}} to {{c4::signal/broadcast}}.</li>\n</ul>",
                "<ul><li>When a condition changes, make sure to signal/broadcast the correct condition variable</li><li>Using broadcast incorrectly can incur a performance loss, but using signal incorrectly make cause your program to execute incorrectly.</li><li>May be best to notify after unlocking mutex to prevent spurious wake ups.</li></ul>"
            ],
            "guid": "f=[-!*~_To",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Threads_Case_Study_PThreads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Run To Completion Scheduling</h2>\n<p>Run To Completion scheduling {{c1::assumes that once a task is assigned to a CPU, it will run on that CPU until it is finished.}}</p>",
                ""
            ],
            "guid": "fCQo-p/_zh",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Process Execution State</h2>\nThe top of the stack is defined by the {{c1::stack pointer}}.",
                ""
            ],
            "guid": "fJ(Hsobc^P",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Paravirtualization</h2>\n<p>In paravirtualization, guest is {{c1::written to run in a virtualized environment on top of a hypervisor as opposed native physical resources}}.</p>",
                "<div>This approach was taken by Xen.</div>"
            ],
            "guid": "fWrRy9Zv<<",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Process Control Block</h2>\nProcess control block contains:\n<br><br><ul>\n<li>{{c1::virtual address mapping}}</li>\n<li>{{c2::stack}}</li>\n<li>{{c3::registers}}</li>\n</ul>\n",
                "Also:<br><ul><li>process state</li><li>process number</li><li>program counter</li><li>memory limits</li><li>CPU scheduling info</li></ul>"
            ],
            "guid": "fd934h+xWX",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>Inter Process Communication</h2>\n<p>Inter process communication (IPC) refers to a set of mechanisms that the {{c1::operating system}} must support in order to permit multiple processes to interact amongst each other.</p>",
                ""
            ],
            "guid": "g&z{unkHzE",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Queueing Lock</h2>\n<p>A queuing lock controls {{c1::which thread(s) see that the lock is free at which time}}.</p>",
                "Latency: OK<div>Delay: Good</div><div>Contention: Good</div>"
            ],
            "guid": "g2gt.WuM6&",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Condition Variable API</h2>\n<p>A wait procedure takes these arguments:</p>\n<ul>\n<li>{{c1::mutex}}</li>\n<li>{{c1::condition variable}}</li>\n</ul>\n",
                ""
            ],
            "guid": "g7mb2ph[//",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Why Disable Interrupts or Signals?</h2>\n<p>{{c1::Signal/interrupt masks}} allow us to dynamically make decisions as to whether or not signals/interrupts can actually interrupt the execution of a particular thread.</p>",
                ""
            ],
            "guid": "g;8m/[Ff`U",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling on Multiprocessors</h2>\n<p>In a shared memory multiprocessor, there are {{c1::multiple CPUs}}.</p>",
                "Each CPU has its own private L1/L2 cache, as well as a last-level cache (LLC) which may or may not be shared amongst the CPUs. Finally, there is system memory (DRAM) which is shared across the CPUs."
            ],
            "guid": "g@GbIqG@{~",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>CPU Device Interconnect</h2>\n<p>{{c1::Bridging controllers}} can handle any difference between different types of interconnects.</p>",
                ""
            ],
            "guid": "gC6MMT|(NZ",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Paravirtualization</h2>\n<p>A paravirtualized guest OS will make {{c1::hypercalls}} to the hypervisor instead of performing disallowed machine operations.</p>",
                ""
            ],
            "guid": "gHQZy_K;w/",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Sharing Granularity</h2>\n<p>In {{c1::<b>SMP</b>}} systems, the granularity of sharing is the {{c2::<b>cache line</b>}}.</p>",
                ""
            ],
            "guid": "gLL^pp&Hdt",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>Distributed File Systems</h2>\n<p>Distributed filesystems (DFS) are environments that involve {{c1::multiple machines for the delivery of the filesystem service}}.</p>",
                ""
            ],
            "guid": "gU7m9+ph5i",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Multithreading Models</h2>\n<p>Three multithreading models are (user threads to kernel threads):</p>\n<ul>\n<li>{{c1::One-to-One Model}}</li>\n<li>{{c1::Many-to-One Model}}</li>\n<li>{{c1::Many-to-Many Model}}</li>\n</ul>\n",
                ""
            ],
            "guid": "gXn)]FNH-]",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Java RMI</h2>\n<p>The Java {{c3::Remote Method Invocations}} (Java RMI) runtime is separated into two components:</p>\n<ul>\n<li>The&nbsp;{{c1::Remote Reference Layer}} contains all of the common code needed to provide reference semantics.</li>\n<li>The {{c2::Transport Layer}} implements all of transport protocol-related functionality.</li>\n</ul>",
                ""
            ],
            "guid": "g[]R$9YJ]#",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Why Does Cloud Computing Work?</h2>\n<p>Two basic principles:</p>\n<ul>\n<li>{{c1::<b>law of large numbers}}</b> - average resource needs across a large number of clients will remain fairly constant</li>\n<li>{{c1::<b>economies of scale}}</b> - leverage a large number of customers on a single piece of hardware</li>\n</ul>",
                ""
            ],
            "guid": "gi]5jA53Ns",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Priority Inversion</h2>\n<p>Priority inversion is {{c1::when threads get executed out of priority order}}.</p>",
                ""
            ],
            "guid": "gnC]15=LO`",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>DFS Models</h2>\n<p>Files may be {{c1::<b>replicated</b>}} across every machine or {{c2::<b>partitioned</b>}} amongst machines.</p>",
                ""
            ],
            "guid": "gni7M3s-tK",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads Case Study - PThreads</h1>\n<h2>PThread Creation</h2>\n<p>{{c1::Detached threads}} cannot be {{c2::joined}} back into the parent, allowing the parent to exit early and the child threads to continue their execution.</p>",
                ""
            ],
            "guid": "gym6JW.Hqz",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_Case_Study_PThreads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Hardware Protection Levels</h2>\n<p>More recent x86 architectures introduce two different {{c2::<b>protection modes</b>}}: {{c1::<b>root and non-root</b>}}.</p>",
                "Within each mode, the four rings exist."
            ],
            "guid": "g{it,x_.sn",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Linux Kernel Allocators</h2>\n<p>The {{c1::slab}} allocator builds custom object caches on top of {{c1::slabs}}. The {{c1::slabs}} themselves represent contiguously allocated physical memory which {{c2::subdivides evenly for the object type}}.</p>",
                "<div>Internal fragmentation is avoided. The entities being allocated in the slab are the exact size of the objects being stored in them. External fragmentation isn't really an issue either. Since each entry can store an object of a given size, and only objects of a given size will be stored, there will never be any un-fillable gaps in the slab.</div>"
            ],
            "guid": "h20:B_6F+Y",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Example Big Data Stacks</h2>\n<ul>\n<li>{{c1::Hadoop}}</li>\n<li>{{c2::Berkeley Data Analytics Stack (BDAS)}}</li>\n</ul>",
                ""
            ],
            "guid": "h3#+oq82+w",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Disk Access Optimizations</h2>\n<p>A main goal of {{c1::I/O scheduling}} is to reduce the disk head movement, which is a slow operation.</p>",
                "I/O schedulers can achieve this by maximizing sequential accesses over random accesses."
            ],
            "guid": "h6EFj=FK$%",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Hard and Light Process State</h2>\n<p>In the process control block {{c1::light process state}} is relevant for {{c2::a subset of user level threads associated with a particular kernel level thread}}.</p>",
                ""
            ],
            "guid": "h7x@zDgxM@",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1><br><h2>Stateless vs Stateful File Server</h2><p>A <strong>stateful</strong> server maintains information about:</p><ul><li>the {{c1::clients}} in the system</li><li>which {{c2::files are being accessed}}</li><li>which {{c3::types of accesses are being performed}}</li><li>which clients have {{c4::a file cached}}</li><li>which clients have {{c5::read/written the file}}</li></ul>",
                ""
            ],
            "guid": "hAT<>yk%5J",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>inodes with Indirect Pointers</h2>\n<p>An indirect pointer will point to a {{c1::block of pointers}}, where each pointer points to data.</p>",
                "A double indirect pointer will point to a block of single indirect pointers, while will point to pointers to data."
            ],
            "guid": "hX?r(*0{R)",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Signal Handling</h2>\n<p>Some <strong>synchronous signals</strong> include:</p>\n<ul>\n<li>{{c1::SIGSEGV}}</li>\n<li>{{c2::SIGFPE (divide by zero)}}</li>\n<li>{{c3::SIGKILL (from one process to another)}}</li>\n</ul>",
                ""
            ],
            "guid": "h[/9#tpV!&",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Spinlock Performance Comparisons</h2>\n<p>{{c1::Overhead}} is the {{c2::measured difference between the theoretical limit and the observed execution time}}.</p>",
                ""
            ],
            "guid": "hlnqcwc$1(",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Migration vs Replication</h2>\n<p>Since the core service provided by DSM solutions is access, the core performance metric to analyze is {{c1::access latency}}.</p>",
                ""
            ],
            "guid": "hmw,WVuFYj",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Cache Coherence</h2>\n<p>Hardware using the {{c1::<b>write-update (WU)</b>}} strategy will ensure that all cache entries of X are {{c2::<b>updated</b>}} once one CPU updates its copy of X.</p>",
                "Subsequent accesses of&nbsp;X&nbsp;by any of the CPUs will continue to be served by the cache."
            ],
            "guid": "i+eCSt+~}m",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>DFS Models</h2>\n<p>Replicated systems are {{c1::<b>fault tolerant</b>}} and {{c2::<b>highly available</b>}}.</p>",
                ""
            ],
            "guid": "iH.T.0UkaT",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Disk Access Optimizations</h2>\n<p>{{c1::<b>Journaling</b>}} writes updates to a {{c2::<b>log</b>}}, which will contain some description of the write that needs to take place, such as the block, the offset, and the content to be written.</p>",
                ""
            ],
            "guid": "iK[g3G~dZ^",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>XDR Encoding</h2>\n<p>XDR Encoding rules:</p>\n<ul>\n<li>All data types are encoded in multiples of {{c1::four bytes}}</li>\n<li>{{c2::Big}} endian is used as the transmission standard</li>\n<li>{{c3::Two's complement}} representation of integers</li>\n<li>{{c4::IEEE}} format&nbsp;for floating point numbers</li>\n</ul>",
                ""
            ],
            "guid": "iPX`*daBW.",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Internet Service Architectures</h2>\n<p>A service deployment can be {{c1::<b>scaled out</b>}} by running the service on {{c2::<b>more nodes</b>}}.</p>",
                ""
            ],
            "guid": "id48vl{|{7",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Hardware Support</h2>\n<p>The Memory Management Unit (MMU) is responsible for {{c1::converting virtual addresses into physical addresses}}.</p>",
                ""
            ],
            "guid": "isL-VI3>i3",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Architecture</h2>\n<p>The home node will have to keep track of the state for its memory pages:</p>\n<ul>\n<li>{{c1::pages accessed}}</li>\n<li>{{c2::modifications}}</li>\n<li>{{c3::caching enabled/disabled}}</li>\n<li>{{c4::lock status}}</li>\n</ul>",
                ""
            ],
            "guid": "iw16i{`o~!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory",
                "leech"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Disk Access Optimizations</h2>\n<p>{{c1::<b>Prefetching</b>}} increases cache hits by {{c2::<b>fetching nearby blocks during a request</b>}}.</p>",
                ""
            ],
            "guid": "i|f+-_wzaf",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Device Virtualization</h2>\n<p>Virtualization solutions adapt one of three key models to virtualize devices:</p>\n<ul>\n<li>{{c1::passthrough}} model - (AKA {{c2::VMM-bypass model}}) {{c3::the VMM-level driver is responsible for configuring the access permissions to a device}}</li>\n<li>{{c1::hypervisor-direct}} model - {{c4::the hypervisor intercepts every device access request that is performed by the guest VM}}</li>\n<li>{{c1::split device driver}} model - {{c5::devices accesses have components in both the guest VM and the hypervisor layer}}</li>\n</ul>",
                ""
            ],
            "guid": "j.)%*p@Lfi",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction To Operating Systems</h1>\n<h2>OS Services</h2>\nList OS Services <b>without</b> a direct link to hardware components:\n<br><br><ul>\n<li>{{c1::Process management}}</li>\n<li>{{c1::File management}}</li>\n<li>{{c1::Device management}}</li>\n<li>{{c2::Memory management}}</li>\n<li>{{c2::Storage management}}</li>\n<li>{{c2::Security}}</li>\n</ul>\n",
                ""
            ],
            "guid": "j.`s3kR`*W",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Basic Thread Mechanisms</h2>\n<p>A {{c1::condition variable}} is a mechanism by which a thread can wait on another thread, and to be able to exactly specify what condition the thread is waiting on.</p>",
                ""
            ],
            "guid": "j0%$qO=+Br",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Run To Completion Scheduling</h2>\n<p>In {{c1::First Come First Serve&nbsp;(FCFS)}} scheduling, the tasks are simply scheduled in the order in which they arrive. When a task completes, the scheduler will pick the next task in order.</p>",
                ""
            ],
            "guid": "j?/hJ6,$h?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Interrupts and Signals Intro</h2>\n<p>Components that may deliver <strong>interrupts</strong> can include:</p>\n<ul>\n<li>{{c1::I/O devices}}</li>\n<li>{{c2::Timers}}</li>\n<li>{{c3::Other CPUs}}</li>\n</ul>",
                ""
            ],
            "guid": "jL`WzZUC.W",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Flash Web Server</span><br></h2></div><div>In Flash, the helper reads the file in memory via&nbsp;{{c1::mmap}}&nbsp;and then the dispatcher checks via&nbsp;{{c2::mincore}}&nbsp;to see if the pages are in memory, and uses this information to determine if it should call a local handler or a helper.</div>",
                ""
            ],
            "guid": "jMbxoij3_E",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Monitors</h2>\n<p>Monitors are a {{c1::higher level synchronization construct that allow us to avoid manually invoking these synchronization operations}}.</p>",
                "A monitor will specify a shared resource, the entry procedures for accessing that resource, and potential condition variables used to wake up different types of waiting threads."
            ],
            "guid": "k*]ES!fZ2o",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Readers/Writer Problem</h2>\n<p>A {{c1::proxy variable}} reflects the state that the current resource is in.</p>",
                ""
            ],
            "guid": "k*vO1+g]v;",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Hardware Support</h2>\n<p>The translation lookaside buffer (TLB) is {{c1::a small cache of virtual/physical address translations}}.</p>",
                "<div>On modern x86 platforms, there is a 64-entry data TLB and 128-entry instruction TLB per core, as well as a shared 512-entry shared second-level TLB.</div>"
            ],
            "guid": "k2s|{o)Tz1",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Internet Services</h2>\n<p>An internet service is any type of service that is {{c1::accessible via a web interface}}.</p>",
                ""
            ],
            "guid": "k5g?Gx%d:V",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling for Hyperthreading Platforms</h2>\n<p>If a thread can issue an instruction on every CPU cycle, then that CPU bound thread will be able to maximize the {{c1::instructions per cycle (IPC) metric}}.</p>",
                ""
            ],
            "guid": "k<Hu};M*%R",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Hyperthreading</h2>\n<p>Hyperthreading is {{c1::CPUs with multiple sets of registers where each set of registers can describe the context of a separate thread}}.</p>",
                ""
            ],
            "guid": "k>k,zzGUS1",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>OS Elements</h2>\n<ul>\n<li>{{c1::abstractions}}</li>\n<li>{{c2::mechanisms}}</li>\n<li>{{c3::policies}}<br></li>\n</ul>",
                ""
            ],
            "guid": "kCWQ3GxIpY",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Scope of Multithreading</h2>\n<p>The {{c1::system}} scope applies to {{c2::operating system}} level thread managers.</p>",
                "These managers will look at the entire platform before making decision on how to run its threads."
            ],
            "guid": "kivt@=^bpk",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Virtual File system Abstractions</h2>\n<p>The filesystem will maintain a {{c1::dentry cache}} containing all of the directories that we have previously visited.</p>",
                "Note that dentry objects live only in memory; they are not persisted."
            ],
            "guid": "k{FLRA,#B]",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Mutual Exclusion</h2>\n<p>As a data structure, the mutex should have at least the following information:</p>\n<ul>\n<li>{{c1::lock status}}</li>\n<li>{{c1::owner}}</li>\n<li>{{c1::blocked threads}}</li>\n</ul>\n",
                ""
            ],
            "guid": "k}H*Ar^<A3",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>What Does a Process Look Like?</h2>\nDifferent types of process state in an address space:\n<ul>\n<li>{{c1::Code}}</li>\n<li>{{c2::Static state (globals)}}</li>\n<li>{{c3::Heap}}</li>\n<li>{{c4::Stack}}</li>\n</ul>\n",
                ""
            ],
            "guid": "l!@N/;09s#",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Segmentation</h2>\n<p>A segment represented with a contiguous section of physical memory would be defined by its {{c1::base address}} and its {{c2::limit registers}}.</p>",
                ""
            ],
            "guid": "l(QgXKU?bs",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Role of the CPU scheduler</h2>\nThe operating system must be able to {{c1::<b>preempt</b>}}; that is, interrupt the current process and save its context. The operating system must then run the {{c2::<b>scheduler</b>}} to {{c2::<b>schedule</b>}}, or select, the next process. Once the process is chosen, the operating system must {{c3::<b>dispatch</b>}} the process and switch into its context.\n",
                ""
            ],
            "guid": "l(i],*4%Gu",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Split Device Driver Model</h2>\n<p>The driver for the physical device - the {{c1::<b>back-end driver</b>}} - resides in the service VM (or the host in type 2 virtualization).</p>",
                ""
            ],
            "guid": "l44y<bxNbu",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling with Hardware Counters</h2>\n<p>A memory bound thread will take a lot of cycles to complete an instruction; therefore, it has a high&nbsp;{{c1::cycles per instruction (CPI)}} metric.</p>",
                ""
            ],
            "guid": "l5d~o26[a#",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Spinlock Performance Metrics</h2>\n<p>We can define {{c1::<b>delay</b>}} as {{c2::<b>the amount of time required for a thread to stop spinning and acquire a lock that has been freed</b>}}.</p>",
                "We want the spinlock to have&nbsp;<em>low delay/waiting time</em>."
            ],
            "guid": "lNojki]zEX",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Demand Paging</h2>\n<p>Requiring a page to be constantly present in memory is known as {{c1::pinning}} the page. This maintains its original physical address throughout its lifetime. In order words, swapping is disabled.</p>",
                ""
            ],
            "guid": "lQw5<5q|xP",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Sync vs. Async Access</h2>\n<p>For synchronous IO operations, the calling thread will {{c1::block}}.</p>",
                "The OS kernel will place the thread on the corresponding wait queue associated with the device, and thread will eventually become runnable again when the response to its request becomes available."
            ],
            "guid": "l[;U_82-e`",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>PThreads Sync for IPC</h2>\n<p>The keyword {{c1::PTHREAD_PROCESS_SHARED}} indicates that a synchronization variable is private to a process or shared among processes.</p>",
                ""
            ],
            "guid": "lc9L+%580+",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Specifying an IDL</h2>\n<p>{{c1::<b>SunRPC</b>}} uses an IDL called {{c2::<b>eXternal Data Representation (XDR)</b>}}.</p>",
                ""
            ],
            "guid": "lcaJ@!F2rm",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Cloud Deployment Model</h2>\n<ul>\n<li>{{c1::<b>public}}</b> clouds - {{c2::infrastructure belongs to the cloud provider}}</li>\n<li>{{c1::<b>private}}</b> clouds - {{c3::infrastructure and software is owned by the same entity}}</li>\n<li>{{c1::<b>hybrid}}</b> clouds - {{c4::combine public and private clouds. Private clouds may comprise the main compute resources for the applications, with failover/spikes being handled on public cloud resources. In addition, public clouds may be used for auxiliary tasks, such as load testing}}</li>\n<li>{{c1::<b>community}}</b> clouds - {{c5::public clouds that are used by certain types of users}}</li>\n</ul>",
                ""
            ],
            "guid": "lnoszVwKY0",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Specifying an IDL</h2>\n<p>An interface definition language will include:</p>\n<ul>\n<li>{{c1::name of the procedure}}</li>\n<li>{{c2::types of the different arguments}}</li>\n<li>{{c3::result type}}</li>\n<li>{{c4::version number}}</li>\n</ul>",
                ""
            ],
            "guid": "lp|8V]zPvo",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Size</h2>\n<p>If a large memory page is not densely populated, there will be larger unused gaps within the page itself, which will leads to wasted memory in pages, also known as {{c1::internal fragmentation}}.</p>",
                ""
            ],
            "guid": "lv3gM_Rws`",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Need for Hardware Support</h2>\n<p>We need the checking of the lock value and the setting of the lock value to happen {{c1::atomically}}, so that we can guarantee that only one thread at a time can successfully obtain the lock.</p>",
                ""
            ],
            "guid": "lvKgI&6^.Y",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Spinlocks</h2>\n<p>A spinlock is used to provide mutual exclusion, similar to a mutex, but when a spinlock is locked that thread is not {{c1::blocked}}.</p>",
                "Instead, the thread is spinning."
            ],
            "guid": "lxOfb}SA}U",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Virtualization Models: Bare Metal</h2>\n<p>The hypervisor model typical integrates a special virtual machine, a {{c1::<b>service VM</b>}}, that runs a standardized OS with full hardware access privileges, allowing it to manipulate hardware as if it were native.</p>",
                "This model is adapted by the&nbsp;<strong>Xen</strong>&nbsp;virtualization software and by the&nbsp;<strong>ESX</strong>&nbsp;hypervisor from VMware.<div>In <b>Xen</b>, privileged domain is referred to as&nbsp;<strong>dom0</strong>&nbsp;and the guest domains are referred to as&nbsp;<strong>domUs</strong>.<br></div>"
            ],
            "guid": "l|g!/_(|>+",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Shared Memory Multiprocessors</h2>\n<p>Shared memory multiprocessors are also referred to as {{c1::symmetric multiprocessors, or just SMPs}}.</p>",
                ""
            ],
            "guid": "m5DhuFGtE|",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>User Level Structures in Solaris 2.0</h2>\n<p>From the user level library perspective, {{c1::lightweight processes}} represent the {{c2::virtual CPUs}} onto which the {{c3::user level threads}} are scheduled.</p>",
                ""
            ],
            "guid": "m<D?Tp1_#x",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>More Synchronization Constructs</h2>\n<p>{{c1::Wait-free synchronization}} constructs are optimistic in the sense that they bet on the fact that there won't be any concurrent writes and that it is safe to allow reads to proceed concurrently.</p>",
                "An example of this is&nbsp;<strong>read-copy-update</strong>&nbsp;(RCU) lock that is part of the Linux kernel."
            ],
            "guid": "mE!}vVHY:G",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Event-Driven Model</span></h2></div><div>Events (in the case of a web server application) can correspond to:<br></div><div><ul><li>{{c1::receipt of request}}</li><li>{{c2::completion of send}}</li><li>{{c3::completion a disk read}}</li></ul></div>",
                ""
            ],
            "guid": "mH}IQ{T]bv",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>NFS Versions</h2>\n<p>For files that are not accessed concurrently, NFS behaves with {{c1::<b>session</b>}} semantics.</p>",
                ""
            ],
            "guid": "mN[oQ:^dPO",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Binding and {{c1::Registry}}</h2>\n<p>Systems software that maintains a database of all available services is often called a {{c1::<b>registry</b>}}.</p>",
                ""
            ],
            "guid": "m[guk+%F%<",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Virtual File System</h2>\n<p>A virtual filesystem (VFS) layer {{c1::hides all details regarding the underlying filesystem(s) from the higher level consumers}}.</p>",
                ""
            ],
            "guid": "maI{n6Fb(N",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>SysV Shared Memory API</h2>\n<ul>\n<li>To <strong>create or open</strong> a segment:<code>{{c1::shmget}}</code></li>\n<li>To <strong>generate</strong> the key:<code>{{c2::ftok}}</code></li>\n<li>To <strong>attach</strong> the shared memory segment:<code>{{c3::shmat}}</code></li>\n<li>To <strong>detach</strong> a segment:<code>{{c3::shmdt}}</code></li>\n<li>To send <strong>commands</strong>:<code>{{c4::shmctl}}</code></li>\n</ul>",
                "<div><i>IPC_RMID</i>&nbsp;as the <i>shmctl</i>&nbsp;destroys the segment.</div>"
            ],
            "guid": "m|NC*1y@?A",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>Networking File System (NFS) Design</h2>\n<p>When an open request comes to an NFS server, it will create a {{c1::file handle}}.</p>",
                "This handle will be returned back to the client machine. Whenever the client wants to access files via NFS, it can pass this handle."
            ],
            "guid": "n#&*/UE7n!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>I/O Device Features</h2>\n<p>Internally, the device will incorporate all other device-specific logic. This will include:</p>\n<ul>\n<li>{{c1::microcontroller - the device's CPU}}</li>\n<li>{{c2::on device memory}}</li>\n<li>{{c3::any other specialty hardware needed by the device}}</li>\n</ul>",
                "For example, some devices may need chips for converting analog to digital signals. As another example, network devices may need chips to interact with the physical network medium, be it optics or copper wire."
            ],
            "guid": "n(IqO76;CG",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Segmentation</h2>\n<p>With segments, the address space is divided into components of {{c1::arbitrary size}}.</p>",
                "Components will correspond to some logically meaningful section of the address space, like the code, heap, data or stack."
            ],
            "guid": "n0l:J%Tt}8",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Cache Coherence</h2>\n<p>There are two basic strategies by which the hardware can achieve cache coherence:</p>\n<ul>\n<li>{{c1::write-invalidate (WI)}}</li>\n<li>{{c1::write-update (WU)}}</li>\n</ul>",
                ""
            ],
            "guid": "n3gL[u21ak",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Distributed Shared Memory (DSM)</h2>\n<p>Distributed shared memory is becoming more relevant today because commodity interconnect technologies offer really low latencies between nodes in a system via {{c1::Remote Direct Memory Access (RDMA)}} interfaces.</p>",
                ""
            ],
            "guid": "n7_U8[`n]_",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Unmarshalling</h2>\n<p>Unmarshalling code takes the buffer provided by the network protocol, extracts the correct chunks of bytes from the buffer and use those bytes to initialize {{c1::<b>data structures</b>}} that correspond to the {{c2::<b>argument types</b>}}.</p>",
                ""
            ],
            "guid": "nWLW8np[^]",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Migration vs {{c1::Replication}}</h2>\n<p>{{c1::<b>Replication</b>}} copies the state to multiple nodes and can be accessed at the same time.</p>",
                ""
            ],
            "guid": "nv:zPJs5CA",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Kernel Level Structures in Solaris 2.0</h2>\n<p>The <strong>kernel</strong> sees:</p>\n<ul>\n<li>{{c1::Kernel level threads}}</li>\n<li>{{c2::CPUs}}</li>\n<li>{{c3::Kernel level scheduler}}</li>\n</ul>",
                ""
            ],
            "guid": "nx9Aqt)3!e",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>What is a Consistency Model?</h2>\n<p>The consistency model is a {{c1::guarantee that the state changes will behave in a certain way}} as long as {{c2::the upper software layers follow a certain set of rules}}.</p>",
                ""
            ],
            "guid": "o#M2ej@V`6",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling on Multiprocessors</h2>\n<p>Cache affinity is {{c1::scheduling tasks back on the same CPUs they had been executing on in the past such that we can maximize how \"hot\" we can keep our CPU caches}}.</p>",
                ""
            ],
            "guid": "o.}kmE2ONw",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Consistency Management</h2>\n<p><b>Polling</b> (periodically or on-demand) for modification information is referred to as:</p>\n<ul>\n<li>{{c1::reactive}}</li>\n<li>{{c2::lazy}}</li>\n<li>{{c3::optimistic}}</li>\n</ul>",
                ""
            ],
            "guid": "o0|J%JkP+.",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>I/O Devices</h2>\n<p>Examples of I/O devices include</p>\n<ul>\n<li>{{c1::keyboards}}</li>\n<li>{{c1::microphones}}</li>\n<li>{{c1::displays}}</li>\n<li>{{c1::speakers}}</li>\n<li>{{c1::mice}}</li>\n<li>{{c1::network interface cards}}</li>\n</ul>",
                ""
            ],
            "guid": "o3UpGG9ggM",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Size</h2>\n<p>Huge pages in Linux are {{c1::1GB}} in size, requiring an offset of {{c1::30}} bits.</p>",
                ""
            ],
            "guid": "oCF+0gSL!T",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Linux O(1) Scheduler</h2>\nNice values are {{c1::priority levels can be adjusted with so-called which span from -20 to 19, corresponding to system priorities of 120 - 20 to 120 + 19.}}",
                ""
            ],
            "guid": "oPw}?7-EV!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Replacement</h2>\n<p>The Least-Recently Used (LRU) policy looks at {{c1::how recently a page has been used, and uses that to inform a prediction about the page's future use.}}</p>",
                "This policy uses the&nbsp;<strong>access bit</strong>&nbsp;that is available on modern hardware to keep track of whether or not the page has been referenced."
            ],
            "guid": "oQ6Ufp=$-O",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>What is Virtualization?</h2>\n<p>Functionality supporting the coexistence of multiple VMs and deal with the allocation and management of the real hardware resources&nbsp;is provided by the {{c1::<b>virtualization layer</b>}}, also referred to as a {{c2::<b>virtual machine monitor</b>}} or {{c3::<b>hypervisor</b>}}.</p>",
                ""
            ],
            "guid": "oY0XI#zUFN",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Test and Set Spinlock</h2>\n<p>A test-and-set spinlock will have the following format:</p>\n<p><code>{{c1::spinlock_lock(lock): // spin...<br>&nbsp; while(test_and_set(lock) == busy);}}</code></p>",
                "Latency: good<div>Delay: good</div><div>Contention: bad;&nbsp;the processor has to continuously go to main memory on each instruction. This will delay all other CPUs that need to access memory.</div>"
            ],
            "guid": "olO&ysM(g:",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Failure Management Checkpointing</h2>\n<p>Debugging often relies on a technique called {{c1::rewind-replay}}.</p>",
                "Rewind means that we will restart the execution of a process from some earlier checkpoint. We will then replay the execution from that checkpoint onwards to see if we can reproduce the error. We can gradually go back to older and older checkpoints until we find the error."
            ],
            "guid": "opKWILd~Y=",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Virtual File system Abstractions</h2>\n<p>To help with certain operations on directories, Linux maintains a data structure called a {{c1::dentry (directory entry)}}.</p>",
                "Each dentry object corresponds to a single path component that is being traversed as we are trying to reach a particular file."
            ],
            "guid": "ov`VOcKrqI",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Virtual File system Abstractions</h2>\n<p>For each file the VFS maintains a persistent data structure called an {{c1::inode}}.</p>",
                "The inode maintains a list of all of data blocks corresponding to the file. In this way, the inode is the \"index node\" for a file."
            ],
            "guid": "p*RovgrISN",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Basic Thread Mechanisms</h2>\n<p>A {{c1::mutex}} is a mechanism that allows threads to operate on data in an exclusive manner. We call this {{c2::mutual exclusion}}.</p>",
                ""
            ],
            "guid": "p6$q;C{`7>",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>Copy vs. Map</h2>\n<p>{{c1::Local Procedure Calls (LPC)}} are a Windows mechanism which transfer messages under a threshold by copying in and out of a communication channel via a port-like interface. Otherwise the data is mapped into the address space of the target process.</p>",
                "The&nbsp;<b>Local Inter-Process Communication</b>&nbsp;(<b>LPC</b>, often also referred to as&nbsp;<b>Local Procedure Call</b>&nbsp;or&nbsp;<b>Lightweight Procedure Call</b>) is an internal, undocumented&nbsp;<a href=\"https://en.wikipedia.org/wiki/Inter-process_communication\">inter-process communication</a>&nbsp;facility provided by the&nbsp;<a href=\"https://en.wikipedia.org/wiki/Microsoft\">Microsoft</a>&nbsp;<a href=\"https://en.wikipedia.org/wiki/Windows_NT\">Windows NT</a>&nbsp;<a href=\"https://en.wikipedia.org/wiki/Kernel_(computer_science)\">kernel</a>&nbsp;for lightweight&nbsp;<a href=\"https://en.wikipedia.org/wiki/Inter-process_communication\">IPC</a>&nbsp;between&nbsp;<a href=\"https://en.wikipedia.org/wiki/Process_(computing)\">processes</a>&nbsp;on the same computer."
            ],
            "guid": "pBMf&.{ULd",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Replacement</h2>\n<p>Periodically, when the amount of occupied memory reaches a particular threshold, the operating system will run some {{c1::page out daemon}} to look for pages that can be freed.</p>",
                ""
            ],
            "guid": "pPW7=ke~:@",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>CPU/Device Interactions</h2>\n<p>{{c1::Memory-mapped I/O}} uses a portion of the physical memory on the system which is dedicated for device interactions.</p>",
                "The portion of the memory that is reserved for these interactions is controlled by the&nbsp;<strong>Base Address Registers</strong>&nbsp;(BAR)."
            ],
            "guid": "pS1$]?79*a",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Architecture</h2>\n<p>In addition to creating page copies via caching, page replicas can be explicitly created for {{c1::<b>load balancing</b>}}, {{c2::<b>performance</b>}} or {{c3::<b>reliability reasons</b>}}.</p>",
                ""
            ],
            "guid": "pVP~,!k[6j",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Goals</h2>\n<p>Allocation requires that the operating system incorporate certain mechanisms and data structures so that it can track {{c1::<b>how memory is used</b>}} and {{c2::<b>what memory is free</b>}}.</p>",
                ""
            ],
            "guid": "pkj?sfY8hD",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Split Device Driver Model</h2>\n<p>The {{c1::front-end driver}} resides in the guest VM.</p>",
                ""
            ],
            "guid": "pnuDAA:?./",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Consistency Management</h2>\n<p>Pushing invalidation messages when data is written to is&nbsp;referred to as:</p>\n<ul>\n<li>{{c1::proactive}}</li>\n<li>{{c2::eager}}</li>\n<li>{{c3::pessimistic}}</li>\n</ul>",
                ""
            ],
            "guid": "p}PcT6BQ{C",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Tasks in Linux</h2>\n<p>Linux <strong>clone</strong> with all bits set/unset:</p>\n<ul>\n<li>When all of the bits {{c1::are set}}, we are basically creating a new thread where <b>all of the state is shared</b> with the parent thread.</li>\n<li>If all of the bits {{c1::are not set}}, where are not sharing anything, which is more akin to <strong>creating an entirely new process</strong>. In fact, fork in Linux is basically implemented by clone with all sharing flags cleared.</li>\n</ul>",
                ""
            ],
            "guid": "q.]V[9,Bu?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Table Entry</h2>\n<p>The page fault handler determines the action to take based on the {{c1::<b>error code</b>}} and the {{c2::<b>faulting address</b>}}.</p>",
                "<div>On x86 platforms, the error code is generated from some of the flags in the page table entry and the faulting address is stored in the&nbsp;<strong>CR2 register</strong>.</div>"
            ],
            "guid": "q.oRXc$Nni",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Table Entry</h2>\n<h3>Every page table entry will have at least a PFN and some bits/flags about the entry:</h3>\n<ul>\n<li>{{c1::<b>valid bit</b> - also called a present bit, as it represents whether or not the contents of the virtual memory are present in physical memory or not.}}<br></li>\n<li>{{c2::<b>dirty bit</b> - gets set whenever a page is written to. This is useful in file systems, where files are cached in memory. We can use this dirty bit to see which files have been written to and thus which files need to be updated on disk.}}<br></li>\n<li>{{c3::<b>access bit</b> - can tell us whether the page has been accessed period, for reads or for writes.}}<br></li>\n<li>{{c4::<b>protection bits</b> - specify whether a page is allowed to be read, written, or executed.}}<br></li>\n</ul>",
                ""
            ],
            "guid": "q03kb<did~",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Synchronization Related Issues</h2>\n<p>{{c1::Adaptive}} mutexes are mutexes which {{c2::sometimes block}} and {{c2::sometimes spin}}.</p>",
                "These only make sense on multiprocessor systems, since we only want to spin if the owner of the mutex is currently executing in parallel to us."
            ],
            "guid": "q1]~#I/-H?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction To Operating Systems</h1>\n<h2>Modular OS</h2>\nModular OS Pros/Cons\n<ul>\n<li>Pros</li>\n<ul>\n<li>{{c1::Maintainability}}</li>\n<li>{{c2::Smaller footprint/Less resource needs}}</li>\n</ul>\n<li>Cons</li>\n<ul>\n<li>{{c3::All the modularity/indirection can reduce some opportunities for optimization (but eh, not really)}}</li>\n<li>{{c4::Maintenance can still be an issue as modules from different codebases can be slung together at runtime}}</li>\n</ul>\n</ul>\n",
                ""
            ],
            "guid": "q4s?^9f=q|",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Requirements for the Cloud</h2>\n<p>Clouds must provide {{c1::<b>fungible</b>}} resources which can easily be repurposed to support different customers with different types of requirements.</p>",
                ""
            ],
            "guid": "qA*_pz$/>`",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Weak Consistency</h2>\n<p>A system may provide an {{c1::entry/acquire}} point, which can be invoked when a particular process requires that all of the <b>updates</b> performed by other processors are <b>visible to it</b>.</p>",
                ""
            ],
            "guid": "qXB1<|{uZY",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads Case Study - PThreads</h1>\n<h2>Mutex Safety Tips</h2>\n<ul>\n<li>Shared data should always be accessed through&nbsp;{{c1::single mutex}}</li>\n<li>Mutex scope must be {{c2::global}}</li>\n<li>{{c3::Globally order locks}} to prevent deadlocks</li>\n<li>Always {{c4::unlock the (correct) mutex}}</li>\n</ul>",
                ""
            ],
            "guid": "qdvp0+jw?r",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_Case_Study_PThreads"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>Networking File System (NFS) Design</h2>\n<p>The NFS client interacts with the NFS server via {{c1::RPC}}.</p>",
                ""
            ],
            "guid": "qkGxucWw)R",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>OS Protection Boundary</h2>\nComputer systems distinguish between at least two modes of execution:\n<ul>\n<li>{{c1::user-level (unprivileged)}}</li>\n<li>{{c1::kernel-level (privileged)}}</li>\n</ul>\n",
                ""
            ],
            "guid": "qrnP#5EiXP",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Heterogenous Architectures</h2>\n<p>Benefits:</p>\n<ul>\n<li>{{c1::benefit from <b>caching</b> and locality}}</li>\n</ul>\n<p>Downsides:</p>\n<ul>\n<li>{{c2::front-end needs to be more <b>complex</b>}}</li>\n<li>{{c3::<b>overall management</b> of this system becomes more complex}}</li>\n</ul>",
                ""
            ],
            "guid": "qx#ZfiRu0h",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Preemptive Scheduling: Priority</h2>\n{{c1::<b>Priority aging</b>}} is a mechanism to protect against {{c2::<b>starvation</b>}}.",
                "The priority of a task is not just the numerical priority, but rather a function of the actual priority and the amount of time the task has spent in the runqueue."
            ],
            "guid": "r&EARm7Z_L",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>CPU Bound or Memory Bound</h2>\n<p>Some software interfaces for accessing hardware counters are:</p>\n<ul>\n<li>{{c1::oprofile}}</li>\n<li>{{c1::Linux perf tool}}</li>\n</ul>",
                ""
            ],
            "guid": "r+x/^w3~0G",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2><div>{{c1::Client-perceived performance}} is {{c2::a metric where a threshold needs to be met, but maximizing it is not useful}}.<br></div>",
                "&nbsp;(e.g. framerates above 30fps)"
            ],
            "guid": "r;2igW6s`1",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Lightweight Threads paper</h2>\n<p>The <b>lightweight thread data structure</b> contains different fields for:</p>\n<ul>\n<li>{{c1::execution context}}</li>\n<li>{{c2::registers}}</li>\n<li>{{c3::signal mask}}</li>\n<li>{{c4::priority}}</li>\n<li>{{c5::stack pointer}}</li>\n<li>{{c6::thread local storage}}</li>\n<li>{{c7::stack}}</li>\n</ul>",
                ""
            ],
            "guid": "r<tO7e,rl-",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Sharing Granularity</h2>\n<p>{{c1::<b>False sharing</b>}} occurs when {{c2::<b>the granularity of the sharing is larger than the granularity of the access</b>}}.</p>",
                "e.g. Two variables within the same shared frame being accessed by two different processes."
            ],
            "guid": "rGT&)0X6r<",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Block Device Stack</h2>\n<p>In order to mask device-specific differences, the block device stack introduces another layer: the {{c1::generic block layer}}.</p>",
                "The intent of this layer is to provide a standard for a particular operating system to all types of block devices."
            ],
            "guid": "rJ,&/&2P3D",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Page Tables</h2>\n<p>Allocation on first touch is when {{c1::the physical memory is only allocated when the process is trying to access it}}.</p>",
                ""
            ],
            "guid": "rd{n^?9.S2",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Signal Handling</h2>\n<p>Some <strong>asynchronous signals</strong> include:</p>\n<ul>\n<li>{{c1::SIGKILL (as the receiver)}}</li>\n<li>{{c2::SIGALARM (timeout from timer expiration)}}</li>\n</ul>",
                ""
            ],
            "guid": "ri3VX57M-G",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Message Passing IPC</h2>\n<p>Message Passing Pros/Cons<br><ul><li>Pros:</li><ul><li>{{c1::OS managed}}</li><li>{{c2::Exising system calls}}</li></ul><li>Cons:</li><ul><li>{{c3::Overhead (round trip into kernel space)}}</li></ul></ul></p>\n",
                ""
            ],
            "guid": "rlWAYR[QgW",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Sequential Consistency</h2>\n<ul>\n<li>memory updates from different processors may be {{c1::arbitrarily interleaved}}</li>\n<li>all processes see {{c2::the same ordering of updates}}</li>\n<li>operations from the same process always appear {{c3::in the order they were issued}}</li>\n</ul>",
                ""
            ],
            "guid": "r}9<GwMdZ>",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Thread Creation</h2>\n<p>A data structure to represent a thread includes:</p>\n<ul>\n<li>{{c1::Thread ID}}</li>\n<li>{{c2::Program counter}}</li>\n<li>{{c3::Stack pointer}}</li>\n<li>{{c4::Register values}}</li>\n<li>{{c5::Stack}}</li>\n<li>Other attributes (priority attributes, etc.)</li>\n</ul>\n",
                ""
            ],
            "guid": "s-&m6d9x<6",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction To Operating Systems</h1>\n<h2>OS Services</h2>\nList OS Services <b>with</b> a direct link to hardware components:\n<ul>\n<li>{{c1::Scheduling component (CPU)}}</li>\n<li>{{c2::Memory manager (physical memory)}}</li>\n<li>{{c3::Block device driver (block device)}}</li>\n</ul>\n",
                ""
            ],
            "guid": "s;L;aH{N=)",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling Overview</h2>\nThe ready queue is also known as a {{c1::runqueue}}.",
                ""
            ],
            "guid": "sQ`@%CF[ia",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2>{{c1::Helper Threads And Processes}}</h2></div><div>{{c1::A&nbsp;helper thread}} handles {{c2::the blocking I/O operation}} and interacts with {{c3::the dispatcher}} as necessary.</div>",
                "Helpers are necessary on platforms where&nbsp;<b>asynchronous I/O calls are not available.</b>"
            ],
            "guid": "sSZ+kXsbTG",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Cache Coherence and Atomics</h2>\n<p>Atomic operations always bypass the {{c1::caches}}.</p>",
                "They are issued directly to the memory location where the particular target variable is stored."
            ],
            "guid": "s^{nfmx>l%",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Binary Translation</h2>\n<p>When the guest OS is {{c1::<b>not modified</b>}}, this type of virtualization is called {{c2::<b>full virtualization</b>}}.</p>",
                ""
            ],
            "guid": "s`-BXmF2<~",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Summarizing Timeslice Length</h2>\n<p>{{c1::CPU}} bound tasks prefer {{c2::longer}} timeslices. {{c1::I/O}} bound tasks prefer {{c2::short}} timeslices.</p>",
                "<div>CPU bound tasks prefer longer timeslices as this limits the number of context switching overheads that the scheduling will introduce. This ensures that CPU utilization and throughput will be as high as possible.</div>\n<div><br></div><div>On the other hand, I/O bound tasks prefer short timeslices. This allows I/O bound tasks to issue I/O requests as soon as possible, and as a result this keeps CPU and device utilization high and well improves user-perceived performance (remember wait times are low).</div>"
            ],
            "guid": "sce*}V^@?P",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Interrupts and Signals Intro</h2>\n<p>A {{c1::mask}} is used to disable or delay the notification of an incoming interrupt or signal.</p>",
                "<div>Both interrupts and signals can be&nbsp;<strong>masked</strong>.<br></div>"
            ],
            "guid": "siRY83aYOj",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>File Sharing Semantics in DFS</h2>\n<p>With {{c1::immutable}} files, you never modify an old file, but rather create a new file instead.</p>",
                ""
            ],
            "guid": "snxk0>uH|]",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Interrupts and {{c1::Signals}} Intro</h2>\n<p>{{c1::Signals}} are events that are triggered by the CPU and the software running on it.</p>",
                "<p>Two identical platforms will have the same interrupts, but will have different signals if they are running different operating systems.</p>\n<p>Signals can appear both synchronous and asynchronously. Signals can occur in direct response to an action taken by a CPU, or they can manifest similar to interrupts.</p>"
            ],
            "guid": "t8b#fHa/[]",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Memory Virtualization: Paravirtualization</h2>\n<p>Since an OS knows that it is in a virtualized environment in paravirtualization:</p>\n<ul>\n<li>No need for {{c1::contiguous}} memory addresses</li>\n<li>Guest OS can explicitly {{c2::register its page tables}} with the hypervisor, so there is no need for {{c3::two page tables}}</li>\n</ul>",
                ""
            ],
            "guid": "tC?tb[9Led",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Timesharing and Timeslices</h2>\n<h3>Pros of timeslicing:</h3><ul><li>{{c1::short tasks finish sooner}}</li>\n<li>{{c2::scheduler is more responsive to changes in the system}}</li>\n<li>{{c3::lengthy I/O operations can be initiated sooner}}</li>\n</ul>\n<h3>Cons of timeslicing:</h3>\n<ul>\n<li>{{c4::overhead of context switches}}</li>\n</ul>",
                ""
            ],
            "guid": "tqzHt@l8io",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Preemptive Scheduling: Priority</h2>\nAn effective way to be able to quickly tell a task's priority is to {{c1::maintain a separate runqueue for each priority level}}.",
                ""
            ],
            "guid": "tsf8%g0;%>",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Binary Translation</h2>\n<p>Binary translation allows for full virtualization by {{c1::dynamically rewriting code to never issue certain instructions}}.</p>",
                ""
            ],
            "guid": "tuC3G%E?|:",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>POSIX Shared Memory API</h2>\n<p>To create/open:<span>&nbsp;</span><code>{{c1::shm_open}}</code>.</p>\n<p>To attach shared memory:<span>&nbsp;</span><code>{{c2::mmap}}</code>.</p>\n<p>To detach shared memory:<span>&nbsp;</span><code>{{c2::munmap}}</code>.</p>\n<p>To destroy a shared memory region:<span>&nbsp;</span><code>{{c1::shm_unlink}}</code>.</p>",
                ""
            ],
            "guid": "tubd,9(z+F",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                " <h1>Introduction to Operating Systems</h1>\n<h2>Operating System Definition</h2>\n  An operating system is a layer of systems software that:\n  <ul>\n<li>{{c1::Directly has privileged access to the underlying hardware}}</li>\n<li>{{c2::Manages hardware on behalf of one or more applications according to some predefined policies}}</li>\n<li>{{c3::Ensures that applications are isolated and protected from one another}}</li>\n</ul>",
                ""
            ],
            "guid": "u(5mV@}l}1",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Hardware Protection Levels</h2>\n<p>x86 architecture has four protection levels, called {{c1::rings}}.</p>",
                "In virtualization setups, the hypervisor sits in ring 0, pushing the OS to ring 1. The applications remain at ring 3."
            ],
            "guid": "u5yA@7hNR(",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Why Are We Still Talking About Synchronization?</h2>\n<p>{{c1::Atomic instructions}} are low level support via hardware for {{c2::synchronization constructs}}.</p>",
                ""
            ],
            "guid": "uCB#Y}FrXn",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Hardware vs Software DSM</h2>\n<p>Hardware-supported DSM relies on a {{c1::physical interconnect}}.</p>",
                "The OS running on each physical node is under the impression that it has access to much larger physical memory, and is allowed to establish virtual to physical mappings that point to physical addresses on other nodes."
            ],
            "guid": "uI]QB9,KNR",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Multithreading</h2>\n<p>In the Many-to-Many Model, an {{c1::unbound}} thread is where a {{c2::user}} level thread can be scheduled on any allocated {{c2::kernel}} level thread.</p>",
                ""
            ],
            "guid": "udBu>pn,5b",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Access Algorithm</h2>\n<p>For a {{c1::single reader/single writer}} application, the main role of the DSM layer is to provide the application with the ability to {{c2::access additional, remote memory}}.</p>",
                ""
            ],
            "guid": "uibQa}W*.h",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>More Synchronization Constructs</h2>\n<p>{{c1::Barriers}} are like reverse semaphores. While a semaphore allows n threads to proceed before it blocks, a {{c1::barrier}} blocks until n threads arrive at that point.</p>",
                ""
            ],
            "guid": "uoJQubYX)>",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Goals</h2>\n<p>Arbitration requires that the operating system can quickly interpret and verify {{c1::a process memory access}}.</p>",
                ""
            ],
            "guid": "urI.r?Zm:u",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Virtualization Models: Hosted</h2>\n<p>In the hosted (or type 2) model, there is a {{c1::full-fledged host OS that manages all of the hardware resources}}.</p>",
                ""
            ],
            "guid": "uy8gJBUkX<",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Runqueue Data Structure</h2>\nA multi-level feedback queue is a structure that {{c1::maintains multiple distinct queues, each differentiated by their timeslice value. More CPU intensive tasks get progressively moved to queues with longer timeslice values}}.",
                ""
            ],
            "guid": "u}viPQF%>[",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Picking a Delay</h2>\n<p>With {{c1::<b>dynamic delays</b>}}, each thread will take a random delay value from a range of possible delays that increases with the \"perceived\" contention in the system.</p>",
                ""
            ],
            "guid": "u~U%o2g)|^",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Condition Variable API</h2>\n<p>A {{c1::broadcast}} procedure allows a thread to signal to all {{c1::other threads waiting on a condition}} that the condition has been met.</p>",
                ""
            ],
            "guid": "v)hwK~gNwt",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Allocation Challenges</h2>\n<p>External fragmentation occurs when there are {{c1::non-contiguous holes of free memory}}, but {{c2::requests for large contiguous blocks of memory cannot be satisfied}}.</p>",
                ""
            ],
            "guid": "v.f5ov2gor",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>DSM Design: Sharing Granularity</h2>\n<p>DSM has larger granularities for sharing:</p>\n<ul>\n<li>{{c1::<b>variable}}</b> granularity</li>\n<li>{{c1::<b>page}}</b> granularity</li>\n<li>{{c1::<b>object}}</b> granularity</li>\n</ul>",
                ""
            ],
            "guid": "v1xNHXy3>=",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>More Synchronization Constructs</h2>\n<p>{{c1::Rendezvous Points}} also wait for multiple threads to arrive at a particular point in execution.</p>",
                ""
            ],
            "guid": "v@pu6LxhTF",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>Crossing the OS Boundary</h2>\nHardware initiates transfer of control from process to operating system when a {{c1::trap}}&nbsp;occurs.",
                ""
            ],
            "guid": "vStw(Ap?79",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>I/O Device Features</h2>\n<p>In general, a device will have a set of control registers which can be accessed by the CPU and permit CPU/device interactions. These registers are typically divided into:</p>\n<ul>\n<li>{{c1::<strong>command registers</strong>, that the CPU uses to control the device}}<br></li>\n<li>{{c2::<strong>data registers</strong>, that are used by the CPU to transfer data in and out of the device}}<br></li>\n<li>{{c3::<strong>status registers</strong> that are used by the CPU to understand what is happening on the device.}}<br></li>\n</ul>",
                ""
            ],
            "guid": "vn(~PG@Hp.",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>{{c1::Demand Paging}}</h2>\n<p>In {{c1::paging or demand paging}}, pages are swapped from DRAM to a secondary storage device like a disk, where they reside on a special {{c2::swap partition}}.</p>",
                ""
            ],
            "guid": "vp`!+e#E0+",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Scheduling on Multiprocessors</h2>\n<p>In a multicore system, each CPU can have {{c1::multiple internal cores}}.</p>",
                "Each core has it's own private L1/L2 cache, and the CPU as a whole shares an LLC. DRAM is present in this system as well."
            ],
            "guid": "vr7iL}w5}>",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Thread Management Visibility and Design</h2>\n<p>The <strong>user level library</strong> sees:</p>\n<ul>\n<li>{{c1::User level threads}}</li>\n<li>{{c2::Available kernel level threads}}</li>\n</ul>",
                ""
            ],
            "guid": "vw,ns73/rh",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Inter Process Communication</h1>\n<h2>SysV Shared Memory</h2>\n<p>{{c1::Segments}} are a type of shared memory, which don't need to correspond to contiguous physical pages.</p>",
                ""
            ],
            "guid": "vxp@WrpoQ!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Inter_Process_Communication"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>Linux CFS Scheduler</h2>\nFairness is the concept that {{c1::in a given time interval, a task should be able to run for an amount of time that is relative to its priority.}}",
                ""
            ],
            "guid": "vzs21z|)k:",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Virtual File system Abstractions</h2>\n<p>The {{c1::file}} abstraction represent the elements on which the VFS operates.</p>",
                ""
            ],
            "guid": "w&o3QUU8sy",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>More Synchronization Constructs</h2>\n<p>{{c1::Path Expressions}} require that a programmer specify a regular expression that captures the correct synchronization behavior.</p>",
                ""
            ],
            "guid": "w+p0}Jt!u)",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Process Life Cycle: States</h2>\n<ul>\n<li>{{c1::new}}</li>\n<li>{{c1::ready}}</li>\n<li>{{c1::running}}</li>\n<li>{{c1::waiting}}</li>\n<li>{{c1::terminated}}</li>\n</ul>\n",
                ""
            ],
            "guid": "w,Su75bU+a",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>{{c1::Deadlocks}}</h2>\n<p>A {{c1::deadlock}} occurs when two or more competing threads are waiting on each other to complete, but none of them ever do.</p>",
                ""
            ],
            "guid": "w/G}EG4t4L",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Performance Considerations</h1>\n<h2>Are Threads Useful?</h2>\n<h3>How are threads useful?</h3>\n<ul>\n<li>{{c1::parallelize problems}}</li>\n<li>{{c2::hot cache (via specialization)}}</li>\n<li>{{c3::lower memory requirements (vs multiprocess)}}</li>\n<li>{{c4::cheaper to synchronize (vs multiprocess)}}</li>\n<li>{{c5::hide latency of I/O operations (even on single CPU)}}</li>\n</ul>",
                ""
            ],
            "guid": "w6(qp3MzdT",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>OS Elements</h2>\nExamples of abstractions/mechanisms include:\n<ul>\n<li>(application abstractions) {{c1::process, thread}} -&gt; {{c3::create/schedule}}</li>\n<li>(hardware abstractions) {{c2::file, socket, memory page}} -&gt;&nbsp;{{c4::open/write/allocate}}</li>\n</ul>",
                ""
            ],
            "guid": "w8i*}V*}l[",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>Marshaling</h2>\n<p>The encoding in the marshaling process specifies the layout of the data upon {{c1::<b>serialization</b>}} into a {{c2::<b>byte stream</b>}}.</p>",
                ""
            ],
            "guid": "w=RK)w.d|O",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Implementing DSM</h2>\n<p>The DSM layer must intercept every single access to the shared state for two reasons:</p>\n<ul>\n<li>{{c1::detecting whether an access is local or remote}}</li>\n<li>{{c2::detecting that a node is performing an update operation to a locally-controlled portion of the shared memory}}</li>\n</ul>",
                ""
            ],
            "guid": "wF?lwd`o;?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Reader/Writer Locks</h2>\n<p>A reader/writer lock behaves similarly to a mutex; however, {{c1::now the developer only has to specify the type of access that they wish to perform - read vs. write - and the lock takes care of access control behind the scenes}}.</p>",
                ""
            ],
            "guid": "w`aY<Ue``)",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>System Call Flow</h2>\nThe OS also exposes an interface of {{c1::system calls}}, which the application can invoke, which allows privileged access of hardware resources for the application on behalf of the operating system.",
                ""
            ],
            "guid": "wf)[a@{]`k",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Strict Consistency</h2>\n<p>For a perfect consistency model, we would like to achieve {{c1::<b>absolute ordering</b>}} and {{c2::<b>immediate visibility</b>}} of any state update and access.</p>",
                "In this model, every node in the system will see all the writes in the system in the exact same order immediately as they are applied. This is only possible if changes are instantaneous and immediately visible anywhere."
            ],
            "guid": "wh%^s;&q6b",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Shared Memory Multiprocessors</h2>\n<p>In a {{c1::<b>write-through</b>}}&nbsp;system, the CPU write may be {{c2::<b>applied both to the cache and in memory</b>}}.</p>",
                ""
            ],
            "guid": "whe7,qp.z-",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Thread Creation</h2>\n<p>When the parent thread calls {{c1::join}} with the thread id of the child it will be blocked until the child thread is finished processing.</p>",
                ""
            ],
            "guid": "x8iL=0u=T-",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>OS Design Principles</h2>\n<ul>\n<li>{{c1::Separation of mechanism and policy}}</li>\n<li>{{c2::Optimize for the common case}}</li>\n</ul>\n",
                ""
            ],
            "guid": "x9.u,YDBJj",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>{{c1::Wait time}} is {{c2::the time after submitting for a&nbsp;job to start executing}}.<br></div>",
                ""
            ],
            "guid": "x:d9cQv(/3",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Failure Management Checkpointing</h2>\n<p>Checkpointing is a {{c1::failure and recovery management}} technique.</p>",
                "The idea behind checkpointing is to periodically save process state."
            ],
            "guid": "xid<NS*mCd",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>CPU Device Interconnect</h2>\n<p>Controllers are connected to the rest of the system via a {{c1::Peripheral Component Interconnect (PCI)}} bus.</p>",
                "Modern platforms typical support&nbsp;<strong>PCI Express</strong>, which is more technologically advanced than PCI-X and PCI. PCI Express has more bandwidth, is faster, has lower latency, and supports more devices than PCI-X."
            ],
            "guid": "xoe<!f%/@!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>{{c1::Inverted Page}} Tables</h2>\n<p>{{c1::Inverted page}} tables have entries keyed by {{c2::the PID}} and {{c2::virtual address}},and point to {{c3::a frame in main memory}}.</p>",
                "Inverted page tables are managed on a system-wide (not on per-process) basis."
            ],
            "guid": "xrD|+Otl3?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Device Access DMA</h2>\n<p>Direct Memory Access (DMA) supported devices require additional hardware support in the form of a {{c1::DMA controller}}.</p>",
                "For devices that have DMA support, the CPU still writes commands directly to the command registers on the device. However, the data movement is controlled by configuring the DMA controller to know which data needs to be moved from memory to the device, and vice versa."
            ],
            "guid": "xrS(gdPTi#",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Multithreading Patterns</h2>\n<ul>\n<li>{{c1::Boss/Workers Pattern}}</li>\n<li>{{c1::Pipeline Pattern}}</li>\n<li>{{c1::Layered Pattern}}</li>\n</ul>",
                ""
            ],
            "guid": "y7#K._HP+N",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>Thread Management Visibility and Design</h2>\n<p>The process jumps to the user level library scheduler when:</p>\n<ul>\n<li>{{c1::ULTs explicitly yield}}</li>\n<li>{{c2::Timer set by the by UL library expires}}</li>\n<li>{{c3::ULTs call library functions like lock/unlock}}</li>\n<li>{{c4::blocked threads become runnable}}</li>\n</ul>",
                ""
            ],
            "guid": "y7gv5s.:ZP",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed File Systems</h1>\n<h2>DFS Models</h2>\n<p>In a system of {{c1::<b>peers</b>}}, every node is responsible for maintaining the files and providing the filesystem service.</p>",
                ""
            ],
            "guid": "yO}:OS=;:U",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_File_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Goals</h2>\n<p>With <b>segmentation</b>, or a <b>segment-based memory approach</b>, the allocation process {{c1::doesn't use fixed-size pages, but rather more flexibly-sized segments that can be mapped to some regions in physical memory as well as swapped in and out of physical memory}}.</p>",
                "Arbitration of accesses uses&nbsp;<strong>segment registers</strong>&nbsp;that are typical supported on modern hardware."
            ],
            "guid": "y[&!t.o#Dy",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Synchronization Constructs</h1>\n<h2>Test and Test and Set Spinlock</h2><div>A test-and-test-and-set spinlock will have the following format:</div>\n<pre><code>spinlock_lock(lock):\n    while({{c1::(lock == busy) OR (test_and_set(lock) == busy)}});</code></pre>",
                "&nbsp;It is also called a spin-on-read or spin-on-cached-value spinlock."
            ],
            "guid": "y_iIgm2Cuv",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Synchronization_Constructs"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>{{c1::Platform efficiency}} measures {{c2::how well resources are utilized}} in order to {{c3::deliver a certain measure of throughput}}.<br></div>",
                ""
            ],
            "guid": "yd1;fpxq)}",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "leech",
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>{{c1::Inter Process Communication}}</h2>\nMechanisms that allow processes to talk to one another are known as {{c1::inter-process communication (IPCs)}}.\n",
                ""
            ],
            "guid": "ymi$Zc>p$A",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Management: Goals</h2>\n<p>The physical memory is divided into {{c1::page frames}}.</p>",
                "Physical memory <b>page frames</b> are equal in size to virtual memory <b>pages</b>."
            ],
            "guid": "yqP8[Mx+~_",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Virtualization</h1>\n<h2>Virtualization Models: Hosted</h2>\n<p>The {{c1::kernel-based VM (KVM)}} is built into Linux and provides all aspects of the physical hardware management and can run regular Linux applications directly.</p>",
                "The support for running guest VMs comes from a combination of the KVM (VMM) module and a hardware emulator called&nbsp;<strong>QEMU</strong>."
            ],
            "guid": "y|pb?~=n{!",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Virtualization"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Datacenter Technologies</h1>\n<h2>Homogenous Architectures</h2>\n<p>Benefits:</p>\n<ul>\n<li>{{c1::front-end (load balancer) can be kept very <b>simple</b>}}</li>\n</ul>\n<p>Downsides:</p>\n<ul>\n<li>{{c2::little opportunity to benefit from <b>caching</b>}}</li>\n</ul>",
                ""
            ],
            "guid": "z:9[0%]*&`",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Datacenter_Technologies"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Scheduling</h1>\n<h2>CPU Bound or Memory Bound</h2>\n<p>{{c1::Hardware counters}}&nbsp;get updated as the processor executes and keep information about various aspects of execution, like:</p>\n<ul>\n<li>{{c2::L1, L2 … LLC cache misses}}</li>\n<li>{{c3::Instructions Per Cycle (IPC) metrics}}</li>\n<li>{{c4::Power/Energy usage data}}</li>\n</ul>",
                ""
            ],
            "guid": "z?(^7,1<&P",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Scheduling"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>Device Drivers</h2>\n<p>Device drivers are responsible for all aspects of device {{c1::<b>access</b>}}, {{c1::<b>management</b>}} and {{c1::<b>control</b>}}.</p>",
                ""
            ],
            "guid": "z?m%#0Tz/Z",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Introduction to Operating Systems</h1>\n<h2>OS Protection Boundary</h2>\nWhen privileged instructions are encountered during a non-privileged execution, the application will be {{c1::trapped}}",
                ""
            ],
            "guid": "zDiIx[RZ_o",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Introduction_to_Operating_Systems"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Performance Metrics</span></h2></div><div>If concerned about energy requirements, I might look at {{c1::performance per watt}}&nbsp;when making decisions about new pieces of hardware.<br></div>",
                ""
            ],
            "guid": "zU8^=C|B6-",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Distributed Shared Memory</h1>\n<h2>Distributed Shared Memory (DSM)</h2>\n<p>Distributed shared memory is a service that {{c1::manages memory across multiple nodes}} so that {{c2::applications will have the illusion that they are running on a single shared-memory machine}}.</p>",
                ""
            ],
            "guid": "zWw[3$3+R?",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Distributed_Shared_Memory"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Processes and Process Management</h1>\n<h2>Process Address Space</h2>\n{{c1::Virtual addresses}} are so called because they don't have to correspond to actual locations in the physical memory.",
                ""
            ],
            "guid": "zZ%+?BiPAY",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>IO Management</h1>\n<h2>CPU/Device Interactions</h2>\n<p>In the {{c1::I/O Port}} Model, the CPU can access devices via special instructions in the instruction set.</p>",
                "x86 platforms specify certain in/out instructions that are used for accessing devices. Each instruction needs to specify the target device - the I/O port -as well as some value that will be passed to the device."
            ],
            "guid": "z`Tvl1q({I",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "IO_Management",
                "leech"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Memory Management</h1>\n<h2>Memory Allocation</h2>\n<p>User level allocators are used for {{c1::dynamic process state - the heap}}.</p>",
                "<div>Once the kernel allocates some memory through a&nbsp;malloc&nbsp;call, the kernel is no longer involved in the management of that memory. That memory is now under the purview of the user level allocator.</div>"
            ],
            "guid": "zcJ:>;C[D_",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Memory_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Thread Performance Considerations</h1><h2><span style=\"font-weight: 400;\">Event-Driven Model</span><br></h2></div><div>To determine which file descriptor has input, we can use the&nbsp;{{c1::<b>select</b>}}&nbsp;system call. {{c2::<b>Poll</b>}} and {{c2::<b>epoll</b>}} are other options.<br></div>",
                ""
            ],
            "guid": "zf4;KjvdR6",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Performance_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Threads And Concurrency</h1>\n<h2>Mutual Exclusion</h2>\n<p>The portion of the code protected by the mutex is called the {{c1::critical section}}.</p>",
                ""
            ],
            "guid": "zoB<n-y8S,",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Threads_And_Concurrency"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Thread Design Considerations</h1>\n<h2>{{c1::Tasks}} in Linux</h2>\n<p>A {{c1::task}} is the main abstraction that linux uses to represent an execution context.</p>",
                "A task is essentially the execution context of a kernel level thread. A single-threaded process will have one task, and a multithreaded process will have many tasks."
            ],
            "guid": "zpwD^0Y2.r",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Thread_Design_Considerations"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<div><h1>Processes and Process Management</h1><h2>Role of the {{c1::CPU scheduler}}</h2></div><div>The {{c1::CPU scheduler}}&nbsp;manages how processes use the CPU resources.<br></div>",
                ""
            ],
            "guid": "zzFOYA_@q=",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Processes_and_Process_Management"
            ]
        },
        {
            "__type__": "Note",
            "fields": [
                "<h1>Remote Procedure Calls</h1>\n<h2>What is SunRPC?</h2>\n<p>SunRPC makes the following design choices:</p>\n<ul>\n<li>{{c1::The server machine}} is known up front (registry per machine)</li>\n<li>{{c2::Programming language}}&nbsp;agnostic for client and server</li>\n<li>Allows the use of&nbsp;{{c3::pointers}} and serializes the {{c3::pointed-to data.}}</li>\n<li>Supports mechanisms for dealing with {{c4::errors (e.g. retry mechanism)}}</li>\n<li>Return {{c5::meaningful errors}} as often as possible</li>\n</ul>",
                ""
            ],
            "guid": "z{7j3m1VI*",
            "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "tags": [
                "Remote_Procedure_Calls"
            ]
        }
    ],
    "reviewLimit": null,
    "reviewLimitToday": null
}