{
    "__type__": "Deck",
    "children": [
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e0d1dea-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "Lesson 01: Introduction, History, and Internet Architecture",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Transport and Network Layer</h2><div>The UDP protocol provides {{c1::a connectionless best-effort service to the applications that are running in the layer above, without reliability, flow or congestion control}}.<br></div><div>At the transport layer, we refer to the packet of information as a {{c2::segment}}.<br></div>\n",
                        ""
                    ],
                    "guid": "CX(Av;y3aL",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Transport and Network Layer</h2><div>The services that TCP offers include:</div><div><ul><li>a {{c1::connection}}-oriented service to the applications that are running on the layer above</li><li>{{c2::guaranteed delivery}} of the application-layer messages</li><li>{{c3::flow control}} which in a nutshell matches the sender’s and receiver’s speed</li><li>{{c4::a congestion-control mechanism}}, so that the sender slows its transmission rate when it perceives the network to be congested.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "C];?!/z$Te",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>A Brief History of the Internet</h2><div>Roberts continued developing the computer network concept, which resulted in the first network which was connecting four nodes (from UCLA, Stanford Research Institute, UCSB, and Univ. of Utah, respectively) into the initial {{c1::ARPANET}} by the end of 1969.<br></div>\n",
                        ""
                    ],
                    "guid": "DRz2GKG}K-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Layers Encapsulation</h2><div>The path that connects the sending and the receiving hosts may include intermediate layer-3 devices, such as {{c1::routers}}, and layer-2 devices such as {{c1::switches}}. The difference is that {{c1::routers}} and layer-2 {{c1::switches}} {{c2::do not implement all the layers in the protocol stack}}; {{c1::routers}} implement layers {{c3::1, 2, 3}}, and layer-2 {{c1::switches}} implement layers {{c3::1, 2}}.</div>\n",
                        "&nbsp;End-hosts implement all five layers while the intermediate devices don’t. This design choice ensures that the Internet architecture puts much of its complexity and intelligence at the edges of the network while keeping the core simple."
                    ],
                    "guid": "F6.IG>=HZ9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Evolutionary Architecture Model</h2><div><div>Which of the following are ramifications of the “hourglass shape of the internet”?</div></div>\n",
                        "<div><div><ul><li>Many technologies that were not originally designed for the internet have been modified so that they have versions that can communicate over the internet (such as Radio over IP).</li><li>It has been a difficult and slow process to transition to IPv6, despite the shortage of public IPv4 addresses.</li><li>Applications like BitTorrent leverage peer-to-peer networking instead of a more traditional client-server model for better performance.</li></ul></div></div>",
                        "<div><ul><li><span style=\"color: rgb(0, 0, 255);\">Many technologies that were not originally designed for the internet have been modified so that they have versions that can communicate over the internet (such as Radio over IP).</span></li><ul><li>Correct: Modifying a technology so that it is compatible with the rest of the internet (i.e., by making it compatible with IP) greatly enhances market penetration (from the vendor’s perspective), and/or decreases the amount of extra development that would need to happen.<br></li></ul><li><span style=\"color: rgb(0, 0, 255);\">It has been a difficult and slow process to transition to IPv6, despite the shortage of public IPv4 addresses.</span></li><ul><li>Correct: A big part of the Internet infrastructure uses IPV4 while the cost of transitioning is high. This reflects as a consequence of the narrow waist.<br></li></ul><li><strike>Applications like BitTorrent leverage peer-to-peer networking instead of a more traditional client-server model for better performance.</strike></li><ul><li>Not relevant here. The hourglass shape of the Internet refers to Internet architecture in terms of protocols available at the different layers.</li></ul></ul></div>"
                    ],
                    "guid": "FnFzv;XyTN",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson01",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div>At every round, each node keeps track of {{c1::the best configuration message that it has received so far}}, and it compares that against {{c2::the configuration messages it receives from neighboring nodes at that round}}.</div>\n",
                        ""
                    ],
                    "guid": "Gs~7R>S0F2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Internet Architecture Introduction</h2><div><div>Every layer works based on the service provided by the layer {{c1::below}} it, and also it provides some service to the layer that is {{c1::above}}.&nbsp;&nbsp;<br></div><div><br></div><div>Some of the advantages of having a layered network stack include scalability, modularity and {{c2::the flexibility to add or delete components which make for cost-effective implementations}}.</div></div>\n",
                        ""
                    ],
                    "guid": "H+P@BaDtGZ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Transport and Network Layer</h2><div>The <b>transport</b> layer is responsible for {{c1::the end-to-end communication between end hosts}}.&nbsp;In this layer, there are two transport protocols, namely {{c2::TCP}} and {{c2::UDP}}.</div>\n",
                        ""
                    ],
                    "guid": "H]x5MVo04~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Application, Presentation, and Session Layers</h2><div>The <b>session</b> layer is responsible for {{c1::managing the different transport streams that belong to the same session between end-user application processes}}.<br></div>\n",
                        "For example, in the case of teleconference application, it is responsible to tie together the audio stream and the video stream."
                    ],
                    "guid": "I+GP5i7gWM",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Layers Encapsulation</h2><div>The entire combination of the segment and the network header is called a {{c1::datagram}}. We say that the {{c1::datagram}}&nbsp;{{c2::encapsulates}} the segment. The header information that the network layer appends includes {{c3::the source and destination addresses of the end hosts}}.</div><div>At each layer the message is a combination of two parts:</div><div><ul><li>{{c4::the payload which is the message from the layer above}}</li><li>{{c4::the new appended header information.}}</li></ul></div><div><br></div><div>At the receiving end, the process is reversed, with headers being stripped off at each layer. This reverse process is known as {{c5::de-encapsulation}}.<br></div>\n",
                        "The same process continues for the link layer which in turn appends its own header information(Hl)."
                    ],
                    "guid": "IEx2?H!+[]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Internet Architecture Introduction</h2><div>The functionalities in the network architecture are implemented by dividing the architectural model into {{c1::layers}}.</div>\n",
                        "Each layer offers different services."
                    ],
                    "guid": "I[XYqR:q>2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div><div>Between two configurations, a node selects one configuration as better if:</div><div><ol><li>{{c1::The root of the configuration has a smaller ID}}</li><li>{{c1::The roots have equal IDs, but one configuration indicates a smaller distance from the root}}</li><li>{{c1::Both roots IDs are the same and the distances are the same, then the node breaks the tie by selecting the configuration of the sending node that has with the smallest ID}}</li></ol></div></div>\n",
                        ""
                    ],
                    "guid": "KW)2}FgS`|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>The End to End Principle</h2><div>Some data link layer protocols, such 802.11 (WiFi), implement some basic error correction as the physical medium used is easily prone to interference and noise (such as a nearby running microwave). Is this a violation of the end-to-end principle?<br></div>\n",
                        "<div>No, because violations of the e2e principle typically refer to scenarios where it is not possible to implement a functionality entirely at the end hosts, such as NAT and firewalls.</div><div>In this question, we have a lower level protocol implementing error checking.</div>"
                    ],
                    "guid": "LaC/PSe;[r",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Transport and Network Layer</h2><div>In the&nbsp;<b>network</b> layer, we refer to the packet of information as a {{c1::datagram}}. The network layer is responsible for {{c2::moving datagrams from one Internet host to another}}.</div><div>The protocols in the network layer are:</div><div><ul><li>{{c3::The IP Protocol, which we often refer to as “the glue” that binds the Internet together. All Internet hosts and devices that have a network layer must run the IP protocol}}.</li><li>{{c3::The routing protocols that determine the routes that the datagrams can take between sources and destinations}}.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "Ls%9]#hGkM",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div><div>The Spanning Tree Algorithm presented in the lectures always results in a spanning tree that places the root in a topologically central location, so that all the nodes are as “close” as possible to the root.&nbsp;</div><div>T/F?<br></div></div>\n",
                        "False.<br>The Spanning Tree Algorithm presented guarantees a unique spanning tree that all the nodes will agree to, but sometimes this isn’t the most “optimal” tree possible. Network administrators can configure the switch ID if they want to have a specific spanning tree."
                    ],
                    "guid": "MH?y:Z2=VG",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Violations of the End-to-End Principle and NAT Boxes</h2><div><b>Firewalls</b> violate the e2e principle since {{c1::they are intermediate devices operated between two end hosts and can drop the end hosts' communication}}.&nbsp;<br></div>\n",
                        ""
                    ],
                    "guid": "P(7IgEYgP%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div><div>At every round, each node sends to each neighbor node a configuration message with three fields:</div><div><ul><li>{{c1::the sending node’s ID}}</li><li>{{c1::the ID of the root as perceived by the sending node}}</li><li>{{c1::the number of hops between that (perceived) root and the sending node}}</li></ul></div></div>\n",
                        ""
                    ],
                    "guid": "P2J+%hP-Te",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>A Brief History of the Internet</h2><div>The initial ARPANET Host-to-Host protocol called {{c1::Network Control Protocol (NCP)}} was introduced in 1970, and it allowed the network users to begin developing applications.<br></div>\n",
                        "One of the first applications that launched was email in 1972."
                    ],
                    "guid": "Pr`lOy23?]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Learning Bridges</h2><div><div>A bridge is a device with multiple {{c1::inputs/outputs}}. A bridge selectivly transfers frames from an input to one (or multiple) outputs.</div><div>A learning bridge learns, populates and maintains, a {{c2::forwarding table}}. The bridge consults its {{c2::forwarding table}} so that it only forwards frames on specific ports, rather than all ports.&nbsp;&nbsp;</div><div>When the bridge receives any frame this is {{c3::a “learning opportunity” to know which hosts are reachable through which ports}}. It learns by {{c4::observing the port over which a frame arrives and the source host}}.<br></div></div>\n",
                        ""
                    ],
                    "guid": "bi~z8pIGN#",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Data Link Layer and Physical Layer</h2><div><div>The <b>physical</b> layer facilitates the interaction with {{c1::the actual hardware}}. It is responsible to transfer {{c2::bits}} within a {{c2::frame}} between two nodes that are connected through a physical link.</div></div>\n",
                        "One of the main protocols in the data link layer, Ethernet, has different physical layer protocols for twisted-pair copper wire, coaxial cable, and single-mode fiber optics."
                    ],
                    "guid": "bjB!KHZ*d=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Application, Presentation, and Session Layers</h2><div>The most popular protocols at the <b>application</b> layer include:</div><div><ul><li>{{c1::The HTTP protocol}} (web)</li><li>{{c1::SMTP}} (e-mail)</li><li>{{c1::The FTP protocol}} (transfers files between two end hosts)</li><li>{{c1::The DNS protocol}} (translates domain names to IP addresses)</li></ul></div><div><br></div><div>At the application layer, we refer to the packet of information as a {{c2::message}}.<br></div>\n",
                        ""
                    ],
                    "guid": "c(VS$,#[Eu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Application, Presentation, and Session Layers</h2><div>The <b>presentation</b> layer plays the intermediate role of {{c1::formatting the information that it receives from the layer below and delivering it to the application layer}}.<br></div>\n",
                        "Some functionalities of this layer are formatting a video stream or translating integers from big endian to little endian format."
                    ],
                    "guid": "cMf[Z8f/Kc",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Interconnecting Hosts and Networks</h2><div>{{c1::Repeaters}} and {{c1::Hubs}} operate on the {{c2::physical layer (L1)::layer name and number}}, as they receive and forward digital signals to connect different Ethernet segments. They provide connectivity between hosts that are {{c3::directly connected (in the same network)}}. They are simple and inexpensive devices, and they can be arranged in a hierarchy. Unfortunately, hosts that are connected through these devices {{c4::belong to the same collision domain}}, meaning that they {{c5::compete for access to the same link}}.</div>\n",
                        ""
                    ],
                    "guid": "c[_%4k0pfk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>The Hourglass Shape of Internet Architecture</h2><div>Researchers have suggested a model called {{c1::the Evolutionary Architecture model, or&nbsp;EvoArch}}, that can help to study layered architectures and their evolution in a quantitative manner.<br></div>\n",
                        "Through this model researchers were able to explain how the hierarchical structure of the layer architecture eventually lead to the hourglass shape."
                    ],
                    "guid": "d<b+OvAY0>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Interconnecting Hosts and Networks</h2><div>Repeaters and Hubs, Bridges and Layer2-Switches, and Routers and Layer3-Switches offer different services and they operate over {{c1::different layers}}.</div>\n",
                        ""
                    ],
                    "guid": "g?yH-.1IJ%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Violations of the End-to-End Principle and NAT Boxes</h2><div>Network Address Translation (NAT) boxes violate the e2e principle because {{c1::the hosts behind NAT boxes are not globally addressable or routable}}.</div>\n",
                        ""
                    ],
                    "guid": "gz~!%8cO?X",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>The End to End Principle</h2><div>The End to End Principle (e2e) principle is summarized as: the network core should be {{c1::simple and minimal}}, while the end systems should {{c1::carry the intelligence}}. Systems designers should avoid building any more than {{c2::the essential and commonly shared functions}} into the network.<br></div>\n",
                        ""
                    ],
                    "guid": "hNM9>|U7Np",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div>At the very first round of the algorithm, every node thinks that {{c1::itself}} is the root.</div>\n",
                        ""
                    ],
                    "guid": "h{*7smhI+i",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>The OSI Model</h2><div><div>Some disadvantages of the layered protocol stack model include:</div><ul><li>Some layers functionality depends on {{c1::the information from other layers, which can violate the goal of layer separation}}.</li><li>One layer may {{c2::duplicate lower layer functionalities.}}</li><li>Some additional overhead that is caused by {{c3::the abstraction between layers}}.</li></ul></div>\n",
                        "For example, the functionality of error recovery can occur in lower layers, but also on upper layers as well."
                    ],
                    "guid": "i;%[@8x%BR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Data Link Layer and Physical Layer</h2><div>In the <b>data link</b> layer, we refer to the packets of information as {{c1::frames}}. Some example protocols in this layer include {{c2::Ethernet, PPP, WiFi}}.&nbsp;<div>The data link layer is responsible to {{c3::move the frames from one node (host or router) to the next node}}.</div></div>\n",
                        ""
                    ],
                    "guid": "iG%LI20<ui",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>The OSI Model</h2><div>The traditional Internet architecture model only has {{c1::five}} layers. The {{c2::application}}, {{c2::presentation}}, and {{c2::session}} layers of the OSI model are combined into a single {{c2::application}} layer.&nbsp;The interface between the {{c3::application}} layer and the {{c3::transport}} layer are the {{c4::sockets}}.<br></div>\n",
                        ""
                    ],
                    "guid": "ku>-qPEi9%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div>A node stops sending configuration messages over a link (port) when {{c1::the node receives a configuration message that indicates that it is not the root}}.</div><div>&nbsp;</div><div>e.g., when it receives a configuration message from a neighbor that is:</div><div><ol><li>{{c2::closer to the root}}</li><li>{{c2::or has the same distance from the root, but it has a smaller ID}}</li></ol></div>\n",
                        ""
                    ],
                    "guid": "mY!}x.?;_M",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Violations of the End-to-End Principle and NAT Boxes</h2><div><div>Some workarounds allow hosts to initiate connections to hosts that exist behind NATs:</div><div><ul><li>{{c1::STUN}} is a tool that enables hosts to discover NATs and the public IP address and port number that the NAT has allocated for the applications for which the host wants to communicate</li><li>{{c2::UDP hole punching}} establishes bidirectional UDP connections between hosts behind NATs</li></ul></div></div>\n",
                        ""
                    ],
                    "guid": "mu}zaHRW<r",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div><div>Network traffic cannot traverse an inactive link.<br></div></div><div>T/F?</div>\n",
                        "False.<br>Traffic (e.g. configuration messages) can still reach the link, but the link is not used to forward traffic."
                    ],
                    "guid": "o$4F+~~341",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Interconnecting Hosts and Networks</h2><div>{{c1::Routers}} and {{c1::Layer3-Switches}} operate on {{c2::the network layer (L3)::layer name and number}}.</div>\n",
                        ""
                    ],
                    "guid": "otBN`0/9so",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>{{c1::The OSI Model}}</h2><div>The International Organization for Standardization (ISO) proposed the seven-layered {{c1::Open Systems Interconnection (OSI) model}} shown below, which consists of the following layers:</div><div><ol><li>{{c2::application layer}}</li><li>{{c2::presentation layer}}</li><li>{{c2::session layer}}</li><li>{{c2::transport layer}}</li><li>{{c2::network layer}}</li><li>{{c2::data link layer}}</li><li>{{c2::physical layer}}</li></ol></div>\n",
                        ""
                    ],
                    "guid": "qf1aGL!oM/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Interconnecting Hosts and Networks</h2><div>{{c1::Bridges}} and {{c1::Layer2-Switches}} can enable communication between hosts that are not directly connected. They operate on the {{c2::data link layer (L2)::layer name and number}} based on {{c3::MAC addresses::addressing scheme}}.</div>\n",
                        ""
                    ],
                    "guid": "sI/,!UI!J2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>A Brief History of the Internet</h2><div>The {{c1::Domain Name System (DNS)}}, which was designed to {{c2::translate domain names to IP addresses}} by a scalable distributed mechanism, was introduced by Paul Mockapetris at USC in 1983.</div><div>More applications sprung up quickly. One of the first and most popular applications was the World Wide Web (WWW), which was introduced by a team of researchers led by {{c3::Tim Berners-Lee}}.<br></div>\n",
                        ""
                    ],
                    "guid": "t~zY-+dt3e",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the {{c2::Spanning Tree}} Algorithm</h2><div><div>Using bridges to connect LANs fails if the {{c1::network topology results in loops (cycles)}}. Links that lead to loops can be excluded by running the {{c2::spanning tree}} algorithm.&nbsp;The goal of the {{c2::spanning tree}} algorithm is to have the {{c3::bridges}} select which {{c3::links (ports)}} to use for {{c3::forwarding}} eliminating loops.</div></div>\n",
                        ""
                    ],
                    "guid": "vpv:8&4S!Q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>A Brief History of the Internet</h2><div>The first vision of a Network - proposed as “{{c1::Galactic Network}}” - by {{c2::J.C.R. Licklider}} was at {{c3::MIT}} back in {{c4::1962::year}}. {{c2::Licklider}}, who was at the time the head of the research program at {{c5::Defense Advanced Research Projects Agency (DARPA)}}, led a group of researchers to experiment connecting two computers. An MIT researcher, Lawrence G. Roberts, connected one computer in {{c6::Massachusetts}} to another computer located in {{c6::California}} via {{c7::low-speed dial-up telephone line}}.<br></div>\n",
                        ""
                    ],
                    "guid": "wgzfs6wEVp",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>Looping Problem in Bridges and the Spanning Tree Algorithm</h2><div>The Spanning Tree Algorithm helps to prevent broadcast storms.<br></div><div>T/F?</div>\n",
                        "True.<br>That is the purpose of the Spanning Tree Algorithm. Although it is still possible to have broadcast storms on the network (such as from a bad network card), STP prevents broadcast storms that result from having loops present in the network topology."
                    ],
                    "guid": "xY#Ef8Pb]W",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 1:&nbsp;Introduction, History, and Internet Architecture</h1>\n<h2>A Brief History of the Internet</h2><div>A new version of the NCP protocol which would eventually be called the {{c1::Transmission Control Protocol / Internet Protocol (TCP/IP)}}.<br></div>\n",
                        ""
                    ],
                    "guid": "zWToWG5,0Z",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson01"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e10e7fe-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "tcpConnectionTeardown.png",
                "tcpFairness.svg"
            ],
            "name": "Lesson 02: Transport and Applications Layers",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Flow Control</h2><div><div>The <b>receiving</b> host allocates a receive buffer of size&nbsp;{{c1::RcvBuffer::var name}}&nbsp;to the connection and maintains two variables:</div><ul><li>{{c2::LastByteRead}}:&nbsp;{{c3::the number of the last bytes in the data stream read from the buffer by the application process}}</li><li>{{c2::LastByteRcvd}}: {{c4::the number of the last bytes in the data stream that has arrived from the network and has been placed in the receive buffer}}</li></ul></div>\n",
                        ""
                    ],
                    "guid": "<P8A,IDBI",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control in Modern Network Environments: TCP CUBIC</h2><div>Time in TCP CUBIC is {{c1::the time elapsed since the last loss event instead of the usual ACK-based timer used in TCP Reno}}. This also makes TCP CUBIC {{c2::RTT-fair}}.<br></div>\n",
                        ""
                    ],
                    "guid": "AU@ob2R)=2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control at TCP - AIMD</h2><div>\"{{c1::Probing}}\" refers to the fact that a TCP sender increases its transmission rate to {{c1::probe}} for the rate at which congestion onset begins, backs off from that rate, and then begins {{c1::probing}} again to see if the congestion onset rate has changed.&nbsp;<br></div>\n",
                        ""
                    ],
                    "guid": "A|,%;{(1K",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Connection Oriented and Connectionless Multiplexing and Demultiplexing</h2><div>When hosts run multiple processes, each process will have {{c1::its own UDP socket and, therefore, a distinct associated port number}}, though an application can {{c2::bind to multiple ports}}. When a host receives UDP segments with a specific&nbsp;destination&nbsp;port number, it will forward the segments to {{c3::the same destination process via the same destination socket, even if the segments are coming from different source hosts or different source port numbers}}.</div>\n",
                        ""
                    ],
                    "guid": "B:f&>FSRhf",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>The TCP Three-Way Handshake</h2><div>Connection Teardown<div><ol><li>When the client wants to end the connection, it sends a segment with {{c1::FIN}} bit set to 1 to the server.</li><li>The server {{c2::acknowledges that it has received the connection closing request and is now working on closing the connection}}.</li><li>The server then sends a segment with {{c3::FIN}} bit set to 1, indicating that connection is closed.</li><li>The client sends an {{c4::ACK}} for it to the server. It also waits for sometime to resend this acknowledgment in case the first {{c4::ACK}} segment is lost.</li></ol></div></div>\n",
                        "<img src=\"tcpConnectionTeardown.png\">"
                    ],
                    "guid": "BV11;$~<@w",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control at TCP - AIMD</h2><div>If we plot&nbsp;<i>cwnd</i>&nbsp;with respect to time, we observe that it follows a {{c1::sawtooth}} pattern.<br></div>\n",
                        ""
                    ],
                    "guid": "D<6,S&s%Xy",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Slow start in TCP</h2><div>When we have a new connection that starts from a cold start, the sending host can take much longer to {{c1::increase the congestion window by using AIMD}}. So for a new connection, we need a mechanism that can {{c2::rapidly increase the congestion window from a cold start}}.<br></div>\n",
                        ""
                    ],
                    "guid": "DWEZN5hrUY",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Introduction to Transport Layer and the Relationship between Transport and Network Layer</h2><div>The transport layer on the sending host receives a {{c1::message}} from the {{c1::application layer}} and appends {{c1::its own header}}. We refer to this combined message as a&nbsp;{{c2::segment}}. This transport layer {{c2::segment}} is then sent to the {{c3::network layer}}.<br></div>\n",
                        ""
                    ],
                    "guid": "FIgrz4JKTR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion control flavors: {{c1::E2E vs Network-assisted}}</h2><div><div>Broadly speaking, there can be two approaches to implement congestion control.</div><div><ul><li>{{c1::Network-assisted}} congestion control.&nbsp;The network layer to provide explicit feedback to the sender about congestion in the network.</li><li>{{c1::End-to-end}} congestion control.&nbsp;Hosts infer congestion from the network behavior and adapt the transmission rate.</li></ul></div></div>\n",
                        "Eventually, TCP ended up using the end-to-end approach. This methodology largely aligns with the end-to-end principle adopted in the design of the networks. Congestion control is a primitive provided in the transport layer, whereas routers operate at the network layer."
                    ],
                    "guid": "G72dB57p:-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control at TCP - AIMD</h2><div>The idea behind additive increase is to increase the window by {{c1::one packet every RTT (Round Trip Time)}}.<br></div>\n",
                        ""
                    ],
                    "guid": "G:TJ78TWCl",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Connection Oriented and Connectionless Multiplexing and Demultiplexing</h2><div>The identifier of a {{c1::UDP}} socket is a {{c2::two}}-tuple that consists of {{c2::a destination IP address}} and {{c2::a destination port number}}.</div>\n",
                        ""
                    ],
                    "guid": "H3|}=6C#<-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>{{c1::Flow Control}}</h2><div>TCP provides a rate control mechanism, also known as {{c1::flow control}}, that helps match the sender’s rate against the receiver’s rate of reading the data. In addition, the sender maintains a {{c2::receive window (<i>rwnd</i>)}} variable. It provides the sender {{c3::an idea of how much data the receiver can handle at the moment}}.</div>\n",
                        ""
                    ],
                    "guid": "HN?c*+oQyn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>How Does a TCP Sender Limit the Sending Rate?</h2><div><div>TCP uses a {{c1::probe-and-adapt}} approach in adjusting the {{c2::congestion window}}. Under normal conditions, {{c3::TCP increases the congestion window}} trying to achieve the available throughput. Once it detects congestion, {{c3::the congestion window is decreased}}.</div><div><br></div><div>In the end, the number of unacknowledged data that a sender can have is {{c4::the minimum of the congestion window and the receive window}}.&nbsp;</div><div>LastByteSent – LastByteAcked&nbsp;\\(\\leq\\)&nbsp;{{c4::min{cwnd, rwnd} }}</div></div>\n",
                        ""
                    ],
                    "guid": "J+F!@9i|J4",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Multiplexing: Why Do We Need It?</h2><div><div>An {{c1::IP address}} alone does not say anything about which {{c2::processes}} on the host should get the packets. Thus, we need an addressing mechanism to distinguish the many {{c2::processes}} sharing the same {{c1::IP address}} on the same host.</div><div><br></div><div>The transport layer solves this problem by using additional identifiers known as&nbsp;{{c3::ports}}. Each application binds itself to a unique {{c3::port number}} by opening {{c4::sockets}} and listening for any data from a remote application.</div></div>\n",
                        ""
                    ],
                    "guid": "Lr8B>q65;O",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Reliable Transmission</h2><div>If the sender does not receive an acknowledgment within a given period of time, the sender can {{c1::assume the packet is lost and resend it}}. This method of using acknowledgments and timeouts is also known as&nbsp;{{c2::Automatic Repeat Request or ARQ}}.&nbsp;<br></div>\n",
                        ""
                    ],
                    "guid": "LydYjJXNk[",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Introduction to Transport Layer and the Relationship between Transport and Network Layer</h2><div>The two most common transport layer protocols are&nbsp;{{c1::User Datagram Protocol (UDP)}}&nbsp;and&nbsp;{{c1::Transmission Control Protocol (TCP)}}.<br></div>\n",
                        ""
                    ],
                    "guid": "M$zEs$w!/g",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Connection Oriented and Connectionless {{c1::Multiplexing and Demultiplexing}}</h2><div>The sending host will need to gather data from different sockets and encapsulate each data chunk with header information to create segments, and then forward the segments to the network layer. We refer to this job as {{c1::multiplexing}}.</div>\n",
                        ""
                    ],
                    "guid": "NQLOa@v)yf",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Flow and Congestion Control</h2><div>Transmission control is needed to:</div><div><ul><li>{{c1::Protect the receiver buffer from overflowing}}</li><li>{{c1::Avoid congestion in the network}}</li></ul></div>\n",
                        ""
                    ],
                    "guid": "PM<5.]dfLp",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Introduction to Transport Layer and the Relationship between Transport and Network Layer</h2><div>An additional layer is needed between the application and the network layer because the network layer offers a {{c1::best-effort}} delivery service model. It does not guarantee {{c2::the delivery of packets}}, nor does it guarantee {{c2::the integrity of the data}}.</div><div><br></div><div>The transport layer allows application programmers to develop applications assuming {{c3::a standard set of functionalities}} provided by the transport layer. So the applications can run over {{c4::diverse networks regardless of different network interfaces or possible unreliability of the network}}.</div>\n",
                        ""
                    ],
                    "guid": "P_fIqcDMs+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>How a host infers congestion? Signs of congestion</h2><div><div>There are mainly two signals of congestion.</div><div><ul><li>{{c1::Packet delay}}.&nbsp;As the network becomes congested, the queues in the router buffers build-up, leading to increased packet delays. Thus, an increase in the round trip time, which can be estimated based on ACKs, can indicate congestion in the network. However, it turns out that packet delays in a network tend to be variable, making delay-based congestion inference quite tricky.&nbsp;</li><li>{{c1::Packet loss}}.&nbsp;As the network gets congested, routers start dropping packets. Note that packets can also be lost due to other reasons such as routing errors, hardware failure, time-to-live (TTL) expiry, error in the links, or flow control problems, although it is rare.&nbsp;</li></ul></div></div>\n",
                        "The earliest implementation of TCP used packet loss as a signal for congestion. This is mainly because TCP already detected and handled packet losses to provide reliability."
                    ],
                    "guid": "PtX9^vQu(M",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Slow start in TCP</h2><div><div>There is one more scenario where slow start kicks in: {{c1::when a connection dies while waiting for a timeout to occur}}.</div></div>\n",
                        ""
                    ],
                    "guid": "QCkZc7bh-n",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Connection Oriented and Connectionless Multiplexing and Demultiplexing</h2><div>Sockets are identified based on special fields in the segment such as the&nbsp;{{c1::source port number}} field&nbsp;and the&nbsp;{{c1::destination port number}} field.&nbsp;<br></div>\n",
                        ""
                    ],
                    "guid": "QqzL9yh:0Q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Reliable Transmission</h2><div>A sender can send multiple packets without waiting for acknowledgments. More specifically, the sender may send at most N unacknowledged packets typically referred to as the&nbsp;{{c1::window size}}.<br></div>\n",
                        ""
                    ],
                    "guid": "b1Za#OSMrh",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Connection Oriented and Connectionless {{c1::Multiplexing and Demultiplexing}}</h2><div>The job of delivering the data included in the transport-layer segment to the appropriate socket, as defined in the segment fields, is called&nbsp;{{c1::demultiplexing}}.<br></div>\n",
                        ""
                    ],
                    "guid": "b4E^k^c]*-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>{{c1::Connection Oriented}} and {{c1::Connectionless}} Multiplexing and Demultiplexing</h2><div>We have two flavors of multiplexing/demultiplexing: {{c1::connectionless}} and {{c1::connection-oriented}}.<br></div>\n",
                        ""
                    ],
                    "guid": "caqp*>p@j3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>{{c2::Multiplexing}}: Why Do We Need It?</h2><div>One of the desired functionalities of the transport layer is the ability for a host to {{c1::run multiple applications to use the network simultaneously}}, known as&nbsp;{{c2::multiplexing}}.&nbsp;<br></div>\n",
                        ""
                    ],
                    "guid": "ej0lpV3-#2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>What are the goals of congestion control?</h2><div><ul><li>{{c1::Efficiency}}. We should get high throughput, or utilization of the network should be high.</li><li>{{c1::Fairness}}.&nbsp;Each user should have their fair share of the network bandwidth. The notion of fairness is dependent on the network policy. For this context, we will assume that every flow under the same bottleneck link should get equal bandwidth.</li><li>{{c1::Low delay}}. We want the network delays to be minor.</li><li>{{c1::Fast convergence}}.&nbsp;The idea here is that a flow should converge to its fair allocation fast.</li></ul></div>\n",
                        "In theory, it is possible to design protocols with consistently high throughput assuming infinite buffer. Essentially, we could keep sending the packets to the network, and they will get stored in the buffer and eventually get delivered. However, it will lead to long queues in the network leading to delays. Thus, applications sensitive to network delays such as video conferencing will suffer.<br><br>Fast convergence is crucial since a typical network’s workload is composed of many short flows and few long flows. If the convergence to fair share is not fast enough, the network will still be unfair for these short flows."
                    ],
                    "guid": "f^EX7Z,Cgt",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>The TCP Three-Way Handshake</h2><div>The TCP Three way Handshake<div><ol><li>The TCP client sends a special segment ({{c1::containing no data}}) with the {{c2::SYN}} bit set to 1. The client also generates {{c3::an initial sequence number (client_isn)}} and includes it in this special {{c2::TCP SYN}} segment.</li><li>The server, upon receiving this packet, allocates the required resources for the connection and sends back the special \"{{c4::connection-granted}}\" segment which we call {{c4::SYNACK}} segment. This packet has the {{c5::SYN}} bit set to 1, the {{c5::acknowledgement}} field of the TCP segment header set to&nbsp;{{c6::client_isn+1}}, and {{c7::a randomly chosen initial sequence number (server_isn)}} for the server.&nbsp;&nbsp;</li><li>When the client receives the {{c4::SYNACK}} segment, it also allocates buffer and resources for the connection and sends {{c8::an acknowledgment}} with {{c8::SYN bit set to 0}}.</li></ol></div></div>\n",
                        ""
                    ],
                    "guid": "h7nK}@#>S",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Reliable Transmission</h2><div>TCP uses&nbsp;{{c1::selective}} ACKing. The sender retransmits {{c2::only those packets that it suspects were received in error}}. Then, the receiver would acknowledge a correctly received packet even if {{c3::it is not in order}}. The out-of-order packets are buffered until {{c4::any missing packets have been received}}, at which point the batch of the packets can be delivered to the application layer.&nbsp;</div>\n",
                        ""
                    ],
                    "guid": "i}uH2/NfJ6",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>A Word About the UDP Protocol</h2><div><div>UDP has a {{c1::64}}-bit header consisting of the following fields:</div><ul><li>{{c2::Source port number}}</li><li>{{c2::Destination port number}}</li><li>{{c2::Length of the UDP segment (header and data)}}</li><li>{{c2::Checksum (an error checking mechanism)}}</li></ul></div>\n",
                        "The checksum provides a basic error checking since there is no guarantee for link-by-link reliability."
                    ],
                    "guid": "kGqef-])g=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Reliable Transmission</h2><div>TCP <b>also</b> uses {{c1::duplicate acknowledgments}} as a means to detect packet loss. A {{c1::duplicate ACK}} is {{c2::an additional acknowledgment of a segment for which the sender has already received acknowledgment earlier}}. When the sender receives {{c3::3 duplicate ACKs for a packet}}, it considers the packet to be lost and will retransmit it instead of waiting for the timeout. This is known as&nbsp;{{c4::fast retransmit}}.<br></div>\n",
                        ""
                    ],
                    "guid": "kn}X_?i>Kk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control in Modern Network Environments: TCP CUBIC</h2><div>TCP CUBIC was also implemented in {{c1::the Linux kernel}}. It uses a CUBIC polynomial as {{c2::the growth function}}.<br></div>\n",
                        ""
                    ],
                    "guid": "lfWA][_{]3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control at TCP - AIMD</h2><div>When the TCP sender detects that a loss event has occurred, then it sets&nbsp;<i>cwnd</i>&nbsp;to {{c1::half of its previous value}}.<br></div>\n",
                        ""
                    ],
                    "guid": "m;r!$sJ%Rw",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Reliable Transmission</h2><div>One method for Reliable Transmission is for the receiver to send an ACK for the most recently received in-order packet. The sender would then {{c1::send all packets from the most recently received in-order packet, even if some of them had been sent before}}. The receiver can simply discard any out-of-order received packets. This is called&nbsp;{{c2::Go-back-N}}.<br></div>\n",
                        ""
                    ],
                    "guid": "n8#;3E4#)(",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Introduction to Transport Layer and the Relationship between Transport and Network Layer</h2><div>The transport layer provides an {{c1::end-to-end connection between two applications running on different hosts}}. It provides this logical connection regardless of whether {{c2::the hosts are in the same network}}.</div>\n",
                        ""
                    ],
                    "guid": "ns82=TG`]d",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Flow Control</h2><div><div>The sender also keeps track of two variables,&nbsp;{{c1::LastByteSent}}&nbsp;and&nbsp;{{c1::LastByteAcked}}.&nbsp;</div><div>UnACKed Data Sent = {{c1::LastByteSent - LastByteAcked}}</div><div><br></div><div>To not overflow the receiver’s buffer, the sender must ensure that the maximum number of {{c2::unacknowledged bytes}} it sends is no more than the&nbsp;{{c3::rwnd}}.&nbsp;Thus we need</div><div>{{c1::LastByteSent – LastByteAcked}}&nbsp;&nbsp;\\(\\leq\\)&nbsp;{{c3::rwnd}}</div></div>\n",
                        ""
                    ],
                    "guid": "om;muG3YJs",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Connection Oriented and Connectionless Multiplexing and Demultiplexing</h2><div>As we have seen, UDP and TCP use port numbers to identify the sending application and destination application. Why don’t UDP and TCP just use process IDs rather than define port numbers?<br></div>\n",
                        "<ul><li>Process IDs are specific to operating systems and therefore using process IDs rather than a specially defined port would make the protocol operating system dependent.</li><li>A single process can set up multiple channels of communications and so using the process ID as the destination identifier wouldn’t be able to properly demultiplex.</li><li>Having processes listen on well-known ports (like 80 for http) is an important convention.</li></ul>"
                    ],
                    "guid": "otvlyuF2>3",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>{{c1::Slow start}} in TCP</h2><div>TCP Reno has a {{c1::slow start}} phase where the congestion window is increased {{c2::exponentially}} instead of {{c2::linearly, as in the case of AIMD}}. The source host adds 1 to cwnd for {{c3::each ACK it receives}}. Once the congestion window becomes more than a threshold, often called the {{c1::slow start}} threshold, it starts using AIMD.<br></div>\n",
                        ""
                    ],
                    "guid": "q@yh5}_,6|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>A Word About the UDP Protocol</h2><div><div>UDP is an {{c1::unreliable}} protocol that {{c1::does not guarantee delivery}}, but it offers fewer delays and better control over sending data because of:</div><ul><li>{{c2::No congestion control or similar mechanisms}}</li><li>{{c2::No connection management overhead}}</li></ul></div>\n",
                        "So with some real-time applications that are sensitive to delays, UDP is a better option, despite possibly higher packet loss."
                    ],
                    "guid": "qf.9,eh,s%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Reliable Transmission</h2><div>TCP guarantees {{c1::in-order}} delivery of the application-layer data without {{c2::any loss or corruption}}.<br></div>\n",
                        ""
                    ],
                    "guid": "qyZ^sAUupT",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Introduction to Transport Layer and the Relationship between Transport and Network Layer</h2><div>UDP and TCP protocols offer {{c1::different functionalities}} to application developers. UDP provides {{c2::basic functionality}} and relies on {{c2::the application layer to implement the remaining}}. On the other hand, TCP provides {{c3::strong primitives to make end-to-end communication more reliable and cost-effective}}.<br></div>\n",
                        "Because of these primitives, TCP has become quite ubiquitous and is used for most applications today."
                    ],
                    "guid": "r5w3{QP.W$",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>TCP Fairness</h2><div>Is TCP fair? Why?<br></div>\n",
                        "Yes.<br><img src=\"tcpFairness.svg\"><br>When a link is under-utilized, both connections increase their window size. When the link is over utlized, both connections decrease their window size, but the connection which previously had the bigger share is decreased more (because halving the larger connection has more effect). Thus the utilization moves towards equal bandwidth share."
                    ],
                    "guid": "rN.%GJB;ic",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Caution About Fairness</h2><div>Another case of unfairness arises if a single application uses {{c1::multiple parallel TCP connections}}.<br></div>\n",
                        ""
                    ],
                    "guid": "sEQ3bkjD4K",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Flow Control</h2><div><div>To not overflow the buffer, TCP needs to make sure that:</div><div>{{c1::LastByteRcvd - LastByteRead}}&nbsp;\\(\\leq\\)&nbsp;{{c2::RcvBuffer}}</div><div><br></div><div>The extra space that the receive buffer has is specified using a parameter termed as {{c3::receive window}}.&nbsp;</div><div>{{c3::rwnd}} = {{c4::RcvBuffer - [LastByteRcvd - LastByteRead]}}</div></div>\n",
                        "The receiver advertises the value&nbsp;<i>rwnd</i>&nbsp;in every segment/ACK it sends back to the sender.&nbsp;"
                    ],
                    "guid": "sYh@&Z`-b",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>A Word About the UDP Protocol</h2><div>For the checksum, the UDP sender {{c1::adds the bits of the source port, the destination port, and the packet length}}. It performs a {{c2::1's complement on the sum (all 0s are turned to 1 and all 1s are turned to 0s)}}, which is the value of the checksum. The receiver adds all the four 16-bit words (including the checksum). The result should be {{c3::all 1's}} unless {{c3::an error has occurred}}.</div>\n",
                        ""
                    ],
                    "guid": "s^Di~_1`;B",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control at TCP - {{c2::AIMD}}</h2><div>TCP {{c1::decreases the congestion window}} when the level of congestion goes up, and it {{c1::increases the window}} when the level of congestion goes down. We refer to this combined mechanism as&nbsp;{{c2::additive increase/multiplicative decrease (AIMD)}}.<br></div>\n",
                        ""
                    ],
                    "guid": "slLj(@R]K1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Reliable Transmission</h2><div>{{c1::Stop and Wait}} ARQ is when {{c2::the sender sends a packet and waits for its acknowledgment from the receiver}}. It is the simplest form of ARQ.<br></div>\n",
                        ""
                    ],
                    "guid": "t(<|YS},%y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Flow Control</h2><div><div>If the receiver informs the sender that&nbsp;<i>rwnd</i> = 0, the sender would {{c1::stop sending data and the receiver would have nothing to ACK and include <i>rwnd</i> when there is buffer space available again}}.</div><div><br></div><div>TCP resolves this problem by {{c2::making the sender continue sending segments of size 1 byte even after&nbsp;rwnd = 0}}. When the receiver acknowledges these segments, it will {{c3::specify the&nbsp;rwnd&nbsp;value, and the sender will know as soon as the receiver has some room in the buffer}}.</div></div>\n",
                        "Also, assume that B has nothing to send to A."
                    ],
                    "guid": "t53*C349VS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control at TCP - AIMD</h2><div><div>TCP Reno uses two types of loss events as a signal of congestion:</div><div><ul><li>{{c1::Triple duplicate ACKs}}: {{c2::considered&nbsp;mild congestion. In this case, the congestion window is reduced to half the original}}.</li><li>{{c1::Timeout}}: {{c3::Is considered a more severe form of congestion, and the congestion window is reset to the initial window size}}.&nbsp;</li></ul></div></div>\n",
                        "Timeout is when no ACK is received within a specified amount of time."
                    ],
                    "guid": "tT78ofzrs1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>TCP Fairness</h2><div>In congestion control, fairness means that for k connections passing through one common link with capacity R bps, each connection gets an average throughput of {{c1::\\(\\frac{R}{k}\\)&nbsp;}}.<br></div>\n",
                        ""
                    ],
                    "guid": "tr3(o(f1Nw",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Slow start in TCP</h2><div><div>Slow start is called “slow” start despite using an exponential increase because, {{c1:: in the beginning, it sends only one packet and starts doubling it after each RTT}}.</div></div>\n",
                        "Thus, it is slower than starting with a large window.&nbsp;"
                    ],
                    "guid": "t{}zrFcr_N",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Connection Oriented and Connectionless Multiplexing and Demultiplexing</h2><div>The identifier for a {{c1::TCP}} socket is a {{c2::four}}-tuple that consists of {{c2::the source IP, source port, destination IP, and destination port}}.<br></div>\n",
                        ""
                    ],
                    "guid": "uD>L<`~_n8",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1><div><div>UDP and TCP use 1’s complement for their checksums. But why is it that UDP takes the 1’s complement of the sum – why not just use the sum? Exploring this further, using 1’s complement, how does the receiver compute and detect errors? Using 1’s complement, is it possible that a 1-bit error will go undetected? What about a 2-bit error?</div></div>\n",
                        "To detect errors, the receiver adds the four words (the three original words and the checksum). If the sum contains a zero, the receiver knows there has been an error. While all one-bit errors will be detected, but two-bit errors can be undetected (e.g., if the last digit of the first word is converted to a 0 and the last digit of the second word is converted to a 1)."
                    ],
                    "guid": "y3rM~#e3r_",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Caution About Fairness</h2><div>Connections with {{c1::smaller}} RTT values would increase their congestion window {{c2::faster}} than those with {{c1::longer}} RTT values.<br></div>\n",
                        ""
                    ],
                    "guid": "z32p.l5MB~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 2: Transport and Applications Layers</h1>\n<h2>Congestion Control in Modern Network Environments: TCP CUBIC</h2><div>TCP Reno has low network utilization, especially when {{c1::the network bandwidth is high}} or {{c1::the delay is large}}. Such networks are also known as {{c2::high bandwidth delay product}} networks.<br></div>\n",
                        ""
                    ],
                    "guid": "zKZc9WULcj",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson02"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e133d56-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 1,
            "extendRev": 0,
            "media_files": [
                "lesson-3-ls-topology.png"
            ],
            "name": "Lesson 03: Intradomain Routing",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Linkstate Routing Algorithm</h2>\n<div>The algorithm exits by returning {{c1::the shortest paths}}, and {{c1::their costs}}, from {{c2::the source node u}} to {{c2::every other node v in the network}}.<br></div>",
                        ""
                    ],
                    "guid": "Aa}*W*gs2S",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<p>A packet is {{c1::forwarded}} when it is moved from a router's input link to the appropriate link.</p>",
                        ""
                    ],
                    "guid": "B58XtVW+T@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1><h2>Distance Vector Routing</h2><p>Determine which of the following can cause the count-to-infinity problem.</p>",
                        "<ul><li>Poison reversing</li><li>Routing Loops</li><li>Hot potato routing</li><li>Dropped packets</li></ul>",
                        "<ul><li><strike>Poison reversing</strike></li><li><span style=\"color: rgb(0, 0, 255);\">Routing Loops</span></li><li><strike>Hot potato routing</strike></li><li><strike>Dropped packets</strike></li></ul>"
                    ],
                    "guid": "B7(9^V;C?/",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "l3q3",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Distance Vector Routing</h2>\n<div>The DV routing algorithm is:</div><div><ul><li>{{c1::iterative}}: {{c2::the algorithm continues in steps until the neighbors do not have new updates to send to each other}}</li><li>{{c1::asynchronous}}: {{c3::the algorithm does not require the nodes to be synchronized with each other}}</li><li>{{c1::distributed}}: {{c4::direct nodes send information to one another, and then they resend their results back after performing their own calculations, so the calculations are not happening in a centralized manner}}</li></ul></div>",
                        ""
                    ],
                    "guid": "BKLO1jw<Vd",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Distance Vector Routing</h2>\n<div>Hot potato routing always selects the egress point that is geographically closest to the ingress point. T/F?<br></div>",
                        "False<br><br>Hot potato routing is a technique/practice of choosing a path within the network, by choosing the closest egress point based on intradomain path cost (Interior Gateway Protocol/IGP cost)."
                    ],
                    "guid": "Cehqj]|iiN",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "l3q5",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Distance Vector Routing</h2>\n<div>There may be multiple egress points from an administrative domain to an external destination. T/F?<br></div>",
                        "True"
                    ],
                    "guid": "DE[obN0!Vq",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "l3q5",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Linkstate Routing Algorithm</h2>\n<div>In the&nbsp;Linkstate Routing Algorithm:</div><div><ul><li>u represents {{c1::the source node}}</li><li>v represents {{c2::every other node in the network}}</li><li>D(v) represents {{c3::the cost of the current least cost path from u to v}}</li><li>p(v) represents {{c4::the previous node along the current least cost path from u to v}}</li><li>c(u,v) represents {{c5::the cost from u to directly attached neighbor v}}</li><li>N’ represents {{c6::the subset of nodes along the current least-cost path from u to v}}</li></ul></div>",
                        ""
                    ],
                    "guid": "E&$8ScctH|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>{{c1::Linkstate Routing}} Protocol Example: OSPF</h2>\n<div>Open Shortest Path First (OSPF) is a routing protocol that uses {{c1::a link-state routing algorithm}} to find the best path between the source and the destination router.<br></div>",
                        ""
                    ],
                    "guid": "Ea:W3LkAwr",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Link state routing algorithm\n</h2>\n<p>Consider the following topology. Let b be the source node. Use Dijkstra’s algorithm to determine the cost of the least cost path from node b to all other nodes in the network upon termination of the algorithm.</p><p><img src=\"lesson-3-ls-topology.png\"><br></p>",
                        "<div><ul><li>Cost to node a: 3</li><li>Cost to node c: 4</li><li>Cost to node d: 6</li><li>Cost to node e: 8</li><li>Cost to node f: 9</li></ul></div>"
                    ],
                    "guid": "E~%Uc+7~r[",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "l3q2",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<p>Dijkstra’s algorithm is a {{c1::global}} routing algorithm, which is also referred to as a {{c1::link-state}} algorithm.</p>",
                        ""
                    ],
                    "guid": "Fm}S~SC26Q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "l3q4",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<p>Intradomain routing must involve multiple&nbsp;administrative&nbsp;domains. T/F?</p>",
                        "<div>False</div>"
                    ],
                    "guid": "G6<uI~.AS}",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1><div>What could the weights on the graph edges represent in intradomain routing diagrams, when we are seeking the least-cost path between two nodes?<br></div>",
                        "<div><ul><li>Length of the cable</li><li>Time delay to traverse the link</li><li>Monetary cost</li><li>Business relationships</li><li>Link capacity</li><li>Current load on the link</li></ul></div>",
                        "<ul><li><span style=\"color: rgb(0, 0, 255);\">Length of the cable</span></li><li><span style=\"color: rgb(0, 0, 255);\">Time delay to traverse the link</span></li><li><span style=\"color: rgb(0, 0, 255);\">Monetary cost</span></li><li><strike>Business relationships</strike></li><li><span style=\"color: rgb(0, 0, 255);\">Link capacity</span></li><li><span style=\"color: rgb(0, 0, 255);\">Current load on the link</span></li></ul><br>A special note about current load on the link – this means that the weights are&nbsp;not&nbsp;static and change dramatically as traffic moves over the network. This is a non-trivial problem which can cause pathological behavior with link-state algorithms.<br>"
                    ],
                    "guid": "Gv5P#PgMW/",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>Linkstate Routing Algorithm</h2>\n<div>In the Linkstate routing protocol, the {{c1::link costs}} and the {{c1::network topology}} are known to {{c2::all nodes (for example by broadcasting these values)}}.</div>",
                        ""
                    ],
                    "guid": "IAK>-AJ/jc",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Routing Algorithms</h2>\n<div><div>When we have routers that belong to the same administrative domain, we refer to the routing as {{c1::intradomain}} routing.<br></div><br></div>",
                        ""
                    ],
                    "guid": "LVTCg,imIC",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Link state routing algorithm\n</h2>\n<p>How will the number of neighbors of the starting point affect the number of iterations for the link state routing algorithm?</p>",
                        "<div>They will execute the same number of iterations, as the number of immediate neighbors has no impact on the number of iterations the algorithm requires.</div>"
                    ],
                    "guid": "LzfV8Wqa;r",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "l3q2",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Distance Vector Routing Example</h2>\n<div>When there are no further updates sent from the nodes, the nodes are not doing any further calculations on their distance vectors. The nodes {{c1::enter a waiting mode}}, until there is a change in the link costs.<br></div>",
                        ""
                    ],
                    "guid": "M%&qv(qgi`",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Hot Potato Routing</h2>\n<div>Hot potato routing effectively reduces {{c1::the network’s resource consumption}} by {{c2::getting the traffic out as soon as possible}}.</div>",
                        ""
                    ],
                    "guid": "Mg,e|A`5CS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1><h2>Distance Vector Routing</h2><p>Select the words that can be used to describe the distance vector algorithm.</p>",
                        "<div><div><ul><li>Distributed</li><li>Centralized</li><li>Iterative</li><li>Asynchronous</li><li>Synchronous</li><li>Non-terminating</li></ul></div></div>",
                        "<ul><li><span style=\"color: rgb(0, 0, 255);\">Distributed</span></li><li><strike>Centralized</strike></li><li><span style=\"color: rgb(0, 0, 255);\">Iterative</span></li><li><span style=\"color: rgb(0, 0, 255);\">Asynchronous</span></li><li><strike>Synchronous</strike></li><li><strike>Non-terminating</strike></li></ul>"
                    ],
                    "guid": "Ny)eDMeT&e",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "l3q2",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Distance Vector Routing Protocol Example: RIP</h2>\n<div>In RIP, routing updates are exchanged between neighbors periodically, using {{c1::a RIP response message}}, as opposed to distance vectors in the DV Protocols. These messages, called RIP advertisements, contain information about {{c2::sender’s distances to destination subnets}}.<br></div>",
                        ""
                    ],
                    "guid": "O}WbpWQkrU",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Linkstate Routing Protocol Example: OSPF</h2>\n<div>OSPF was introduced as an advancement of {{c1::the RIP Protocol}}, operating in upper-tier ISPs. Advances include {{c2::authentication}} of messages exchanged between routers, the option to use {{c3::multiple same cost paths}}, and support for {{c4::hierarchy}} within a single routing domain.</div>",
                        ""
                    ],
                    "guid": "cCCgzv[^F[",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Linkstate Routing Algorithm - Example</h2>\n<div><div>In the Linkstate algorithm, the goal is to compute the least-cost paths from u to {{c1::all nodes v in the network}}.&nbsp;</div></div>",
                        ""
                    ],
                    "guid": "d#E<AE./C5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Routing Algorithms</h2>\n<div><div>{{c1::Forwarding}} refers to {{c2::transferring a packet from an incoming link to an outgoing link within a single router}}.</div>{{c1::Routing}} refers to {{c2::how routers work together using routing protocols to determine the good paths}}.<br></div>",
                        ""
                    ],
                    "guid": "f6r62D[Tx}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>{{c1::Distance Vector Routing Protocol}} Example: RIP</h2>\n<div>The Routing Information Protocol (RIP) is based on {{c1::the Distance Vector protocol}}.<br></div>",
                        ""
                    ],
                    "guid": "g2k*b>`Do|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1><p>Determine which action is network-wide (i.e. involves multiple routers).</p>",
                        "<ul><li>Routing</li><li>Forwarding</li></ul>",
                        "<ul><li><span style=\"color: rgb(0, 0, 255);\">Routing</span></li><li><strike>Forwarding</strike></li></ul>"
                    ],
                    "guid": "gOt82N?9,f",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Linkstate Routing Algorithm</h2>\n<div>Iterations</div><div>After the initialization step, the algorithm follows with a loop that is executed for {{c1::every destination node v in the network}}. At each iteration, we:</div><div><ul><li>look at {{c2::the set of nodes that are not included in N’}}</li><li>identify the node (say w) with {{c3::the least cost path from the previous iteration}}</li><li>add that node w into {{c4::N’}}</li><li>for every neighbor v of w, we update {{c5::D(v)}} with {{c5::the new cost}} which is {{c6::either the old cost from u to v (from the previous iteration)}} or {{c6::the known least path cost from source node u to w, plus the cost from w to v (whichever between the two quantities is the minimum)}}</li></ul></div>",
                        ""
                    ],
                    "guid": "h&<&<x~KHu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  {{c1::Poison Reverse}}</h2>\n<div>{{c1::Poison reverse}} will solve the count-to-infinity problem with 2 nodes, however it will not solve a general count to infinity problem involving 3 or more nodes that are not directly connected.<br></div>",
                        ""
                    ],
                    "guid": "hL?Ttn00(1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Hot Potato Routing</h2>\n<div><a href=\"https://youtu.be/HlxpRTOKaAo?t=118\">Hot potato</a> routing is a technique/practice of choosing a path within the network, by choosing the closest egress point based on {{c1::intradomain path cost (Interior Gateway Protocol/IGP cost)}}.<br></div>",
                        ""
                    ],
                    "guid": "j3QK=s9~W)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Linkstate Routing Algorithm - Example</h2>\n<div><div>In the Linkstate initialization step, we set all the currently known least-cost paths from u to it’s {{c1::directly attached neighbors}}. For the rest of the nodes in the network we set the cost to {{c2::infinity}}, because they are not immediate neighbors to source node u</div></div>",
                        ""
                    ],
                    "guid": "jj|*(3$3N/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Routing Algorithms</h2>\n<div><div><div>We have two hosts that have established a connection between them using TCP or UDP.</div><div>Each of the two hosts knows the {{c1::default router (or first-hop router)::default router/entire path}}.</div><br></div></div>",
                        ""
                    ],
                    "guid": "jv4q}J%5km",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1><h2>Distance Vector Routing</h2><div>Select all statements that correctly complete the sentence.</div><div>The Routing Information Protocol (RIP) is an example of ______________.&nbsp;</div>",
                        "<ul><li>a link-state algorithm</li><li>a distance vector algorithm</li><li>poison reverse</li><li>an interdomain routing algorithm.</li><li>an intradomain routing algorithm</li></ul>",
                        "<ul>\n<li><span style=\"text-decoration: line-through;\">a link-state algorithm</span></li>\n<li><span style=\"color: rgb(0, 0, 255);\">a distance vector algorithm</span></li>\n<li><span style=\"text-decoration: line-through;\">poison reverse</span></li>\n<li><span style=\"text-decoration: line-through;\">an interdomain routing algorithm.</span></li>\n<li><span style=\"color: rgb(0, 0, 255);\">an intradomain routing algorithm</span></li>\n</ul>"
                    ],
                    "guid": "l(vqzk-Ylp",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "l3q4",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Distance Vector Routing</h2>\n<div>Each node x updates its own distance vector using the {{c1::Bellman Ford}} equation:&nbsp;&nbsp;{{c2::\\(D_x(y) = min_v\\{c(x,v) + D_v(y)\\}\\)}}&nbsp;for each destination node y in the network.<br></div>",
                        ""
                    ],
                    "guid": "mlYSq!{lsk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Distance Vector Routing</h2>\n<div>Neighboring nodes receive {{c1::a neighbor's distance vector}} and they use it to {{c2::update their own distance vectors}}.</div>",
                        "In other words, the neighboring nodes exchange their distance vectors to update their own view of the network."
                    ],
                    "guid": "qhl1z`S{U0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Hot Potato Routing</h2>\n<div>Hot Potato Routing can be used when {{c1::the final destination of the traffic is outside the network}} and {{c1::egress points (routers) are equally good in the sense that they offer similarly good external paths to the final destination}}.</div>",
                        ""
                    ],
                    "guid": "u#|QIK-$<a",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  {{c1::Distance Vector}} Routing</h2>\n<p>The Bellman Ford equation is used by the {{c1::distance vector}} algorithm.</p>",
                        ""
                    ],
                    "guid": "uB$.xnRY_h",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "l3q4",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 3: Intradomain Routing</h1>\n<h2>\n  Linkstate Routing Algorithm - Computational Complexity</h2>\n<div>What is the computational complexity of the linkstate routing algorithm?<br></div>",
                        "\\(O(n^2)\\)<br>In the first iteration we need to search through all nodes to find the node with the minimum path cost. But as we proceed in the next iterations, this number decreases. So in the second iteration we search through (\\(n-1\\)) nodes. This decrease continues at every step. So by the end of the algorithm, after we go through all the iterations, we will need to search through&nbsp;\\(\\frac{n(n+1)}{2}\\)&nbsp;nodes."
                    ],
                    "guid": "ww]wg#lau}",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson03"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e150258-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "Lesson 04: AS Relationships and Interdomain Routing",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>The border routers of the ASes use {{c1::the Border Gateway Protocol (BGP)}} to exchange routing information with one another.<br>",
                        ""
                    ],
                    "guid": "A@HR^(xYsD",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2><div>The main job of a router is to implement the {{c1::forwarding plane}} functions and the {{c1::control plane}} functions.</div>",
                        ""
                    ],
                    "guid": "AUp]T%qjEg",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>What order does an AS to import its routes based on their incentive?</div><div>{{c1::Customers}} → {{c1::Peers}} → {{c1::Providers}}</div>",
                        ""
                    ],
                    "guid": "B2F`sM7E-!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2>\n<h3>What's Inside a Router?</h3>\n<h4>Route processing</h4><div>The routers build their forwarding tables using routing protocols such as:</div><div><ul><li>{{c1::RIP}}</li><li>{{c1::OSPF}}</li><li>{{c1::BGP}}</li></ul></div>",
                        "These protocols are implemented in the routing processors."
                    ],
                    "guid": "BFF$yzkQ7l",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Challenges with BGP: Scalability and Misconfigurations\n</h2><div>Long, specific prefixes can be filtered to {{c1::encourage route aggregation}}.<br></div>",
                        ""
                    ],
                    "guid": "B{AvCgPQD?",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs</h2><div><div>IXPs users may use route servers for an additional cost.</div></div><div>T/F?</div>",
                        "False<br><br>Many IXPs also include service level agreements (SLAs) and <b>free</b> use of the IXP’s route servers for participants."
                    ],
                    "guid": "B~?<[WuxU}",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>BGP Configuration Verification</h2><div>Path visibility means that {{c1::route destinations are correctly propagated through the available links in the network}}.<br></div>",
                        ""
                    ],
                    "guid": "CFkD,X~u3-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04",
                        "optional"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs</h2><div><div>Participation of an AS in an IXP is free.</div></div><div>T/F?</div>",
                        "False"
                    ],
                    "guid": "D@2a9x*j&o",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>BGP Configuration Verification</h2><div>Route validity means that {{c1::the traffic meant for a given destination reaches it}}.<br></div>",
                        ""
                    ],
                    "guid": "DyGTI3.Z%6",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04",
                        "optional"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP and Design Goals\n</h2><div><div>What are the design goals of the BGP protocol?</div><div><ul><li>{{c1::Scalability}}</li><li>{{c2::Express}} routing policies</li><li>Allow {{c3::cooperation among ASes}}</li><li>{{c4::Security}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "ErO_FetfMr",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at {{c1::IXPs}}\n</h2><div>ASes can either peer with one another directly or peer at&nbsp;{{c1::Internet Exchange Points (IXPs)}}.<br></div>",
                        "IXPs are infrastructures that facilitate peering and provide more services."
                    ],
                    "guid": "F6qF6=RM%[",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div><div>Assume that AS X prefers routes advertised to AS Y to go through R1 as opposed to R2. For AS Y to be influenced to choose R1 to forward traffic to AS X, R1 must have a {{c1::Lower::Lower/Higher}} MED value, assuming that all other attributes are equal.</div></div>",
                        ""
                    ],
                    "guid": "F<in4yhI?0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  iBGP and eBGP\n</h2><div>What is the difference between iBGP and IGP?&nbsp;<br></div>",
                        "<div>IGP-like protocols are used to establish paths between the internal routers of an AS based on specific costs within the AS. In contrast, iBGP is only used to disseminate external routes within the AS.<br></div>"
                    ],
                    "guid": "F^UQL=Y$LN",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div>Remote peering through resellers: {{c1::Third parties resell IXP ports wherever they have infrastructure connected to the IXP}}. These third parties can offer the IXP’s service {{c2::remotely, which will enable networks that have little traffic also to use the IXP}}.<br></div>",
                        ""
                    ],
                    "guid": "GAs8B:s0>5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs: How Does a Route Server Work?</h2><div>{{c1::Import::Import/Export}} filters are applied to ensure that each IXP member AS only advertises routes that it should advertise.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "Gs!D7x9KU0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at {{c1::IXPs}}\n</h2><div>The ASes that interconnect at an {{c1::IXP}} are called {{c2::participant ASes}}.<br></div>",
                        ""
                    ],
                    "guid": "H%2hHF/BlF",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>{{c1::CDNs}} are {{c2::networks that are created by content providers with the goal of having greater control of how the content is delivered to the end-users while reducing connectivity costs}}.<br>",
                        "<b><span style=\"color: rgb(45, 59, 69); font-weight: 400;\">Some examples of CDNs are Google and Netflix. These networks have multiple data centers, and each one of them may be housing hundreds of servers that are distributed across the world.&nbsp;</span></b>"
                    ],
                    "guid": "H)v6u_xha{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div>DDoS blackholing:&nbsp;A few IXPs support customer-triggered blackholing, which allows {{c1::users to alleviate the effects of DDoS attacks against their network}}.<br></div>",
                        ""
                    ],
                    "guid": "I/[BKq@+}y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  iBGP and eBGP\n</h2><div>Each eBGP speaking router has an iBGP session with {{c1::every other BGP router in the AS}} to send updates about the routes it learns (over eBGP).</div>",
                        ""
                    ],
                    "guid": "IApK_>c+ep",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>IXPs are {{c1::interconnection}} infrastructures, which provide {{c2::the physical infrastructure}}, where multiple networks (e.g., ISPs and CDNs) can {{c3::interconnect and exchange traffic locally}}.<br>",
                        "<b><span style=\"color: rgb(45, 59, 69); font-weight: 400;\">As of 2019, there are approximately 500 IXPs around the world.</span></b>"
                    ],
                    "guid": "ITn.JSb/Mw",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  iBGP and eBGP\n</h2><div>eBGP is used to disseminate routes for {{c1::external::internal/external}} destinations.</div>",
                        ""
                    ],
                    "guid": "J]2Ilo<#FJ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div><div>A pair of routers, known as&nbsp;{{c1::BGP peers}}, exchange routing information over a semi-permanent {{c2::TCP port connection}} called a&nbsp;{{c3::BGP session}}. In order to begin a {{c3::BGP session}}, a router will {{c4::send an OPEN message to another router}}. Then the sending and receiving routers will send each other {{c5::announcements}} from {{c6::their routing tables}}. The time it takes to exchange routes varies from {{c7::a few seconds}} to {{c7::several minutes}}, depending on the number of routes exchanged.</div></div>",
                        ""
                    ],
                    "guid": "J^x[!Uen}:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div><div>A BGP session between a pair of routers in two different ASes is called {{c1::an&nbsp;external BGP (eBGP) session}}, and a BGP session between routers that belong to the same AS is called {{c1::an&nbsp;internal BGP&nbsp;(iBGP)&nbsp;session}}.<br></div></div>",
                        ""
                    ],
                    "guid": "JeTXY),>~z",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2><div><div>The input ports perform several functionalities:</div><ul><li>{{c1::Physically terminate the incoming links to the router}}</li><li>{{c2::decapsulates the packets (data link processing unit)}}</li><li>{{c3::perform the lookup function}}</li></ul></div>",
                        "The input ports consult the forwarding table to ensure that each packet is forwarded to the appropriate output port through the switch fabric."
                    ],
                    "guid": "Jmb/mC9grb",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Challenges with BGP: Scalability and Misconfigurations\n</h2><div>An AS can limit the number of routing changes, explicitly limiting the propagation of unstable routes by using a mechanism known as&nbsp;{{c1::flap damping}}. To apply this technique, an AS will {{c2::track the number of updates to a specific prefix over a certain amount of time. If the tracked value reaches a configurable value, the AS can suppress that route until a later time}}.<br></div>",
                        ""
                    ],
                    "guid": "KiXLo7qo+H",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>BGP Configuration Verification</h2><div>{{c1::The Router Configuration Checker, or&nbsp;rcc,}}&nbsp;is a tool researchers propose that detects BGP configuration faults.<br></div>",
                        ""
                    ],
                    "guid": "NFyUp0Jv1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04",
                        "optional"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div><div>Why have IXPs become increasingly popular, and why are they important to study?</div><ul><li>IXPs are interconnection hubs handling {{c1::large traffic volumes}}</li><li>An important role in mitigating {{c2::DDoS attacks}}</li><li>“Real-world” infrastructures with a plethora of {{c3::research opportunities}}</li><li>IXPs are active {{c4::marketplaces}} and {{c4::technology innovation hubs}}</li></ul></div>",
                        ""
                    ],
                    "guid": "N^Bh?+t4}j",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>\nToday's Internet is a complex ecosystem which includes:<br><ul><li>{{c1::Internet Service Providers (ISPs)}}</li><li>{{c1::Internet Exchange Points (IXPs)}}</li><li>{{c1::Content Delivery Networks (CDNs)}}</li></ul>",
                        ""
                    ],
                    "guid": "NmA&tv)a]p",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>Provider&nbsp;ASes&nbsp;have a financial&nbsp;incentive&nbsp;to forward as much of their customers’ traffic as possible.&nbsp;<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "Nobd;ui>f7",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs</h2><div><div>One of the reasons why networks choose to peer at IXPs is because critical players in today’s Internet ecosystem often “incentivize” other networks to connect at IXPs.</div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "Nt7j-G)AgO",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div><div>A router within an AS decides which route to export by first applying import policies to exclude routes entirely from further consideration.</div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "O1N!~PeNM%",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs: How Does a Route Server Work?</h2><div>Bilateral sessions for every pair of ASes exchanging traffic in an IXP does not scale. To mitigate this, some IXPs operate a {{c1::route server}}, which helps to make peering&nbsp;more manageable.<br></div>",
                        ""
                    ],
                    "guid": "Orx$2H1@pY",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2>\n<h3>What's Inside a Router?</h3>\n<div>After the packet has been switched to a specific output, it will need to be {{c1::queued (if the link is congested)}}.<br></div>",
                        "The queue may be as simple as First-In-First-Out (FIFO), or it may be more complex (e.g., weighted fair queuing) to provide delay guarantees or fair bandwidth allocation."
                    ],
                    "guid": "P3.B^xTx@p",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div><div>What are the different types of routes that an AS (let's call it X) decides whether to export?</div><ul><li>{{c1::Routes learned from customers}}</li><li>{{c1::Routes learned from peers}}</li><li>{{c1::Routes learned from providers}}</li></ul></div>",
                        ""
                    ],
                    "guid": "P:ERoB@ar!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>As the Internet has been evolving, the dominant presence of {{c1::IXPs}} and {{c1::CDNs}} has caused the structure to begin morphing from {{c2::hierarchical}} to {{c2::flat}}.<br>",
                        ""
                    ],
                    "guid": "P?0=WZf{s0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div><div>After BGP peers establish a session,&nbsp;&nbsp;they can exchange BGP messages to {{c1::provide reachability information}} and {{c1::enforce routing policies}}.</div></div>",
                        ""
                    ],
                    "guid": "PK<Me1Uw*;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Challenges with BGP: Scalability and Misconfigurations\n</h2><div>Some small ASes also have the option to configure&nbsp;{{c1::default routes}}&nbsp;into their forwarding tables.<br></div>",
                        ""
                    ],
                    "guid": "QQyob?so)/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2><div>The main components of a router are:</div><div><ul><li>{{c1::input/output ports}}</li><li>{{c1::switching fabric}}</li><li>{{c1::routing processor}}</li></ul></div>",
                        ""
                    ],
                    "guid": "RcC`=Z.#Lc",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div><div><b>Imported</b> routes are ranked the way they are because the AS...</div><ul><li>{{c1::wants to ensure that routes towards its customers do not traverse other ASes unnecessarily generating costs}}</li><li>{{c2::uses routes learned from peers since these are usually \"free\" (under the peering agreement)}}</li><li>{{c3::and finally resorts to importing routes learned from providers as these will add to costs}}</li></ul></div>",
                        ""
                    ],
                    "guid": "bk*7qgO}%3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs</h2><div><div>IXPs handle large volumes of traffic.</div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "cg22u#~K.G",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2><div><div>The BGP protocol is used within an AS and focuses on optimizing a path metric within the network. Examples of BGP protocols are Open Shortest Paths First (OSPF) and Routing Information Protocol.</div></div><div>T/F?</div>",
                        "False"
                    ],
                    "guid": "dZ#8UNkE5>",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div>Route servers and Service level agreements allow participants to {{c1::arrange instant peering with many co-located participant networks using essentially a single agreement/BGP session}}.<br></div>",
                        ""
                    ],
                    "guid": "e)k3_rsd*r",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs: How Does a Route Server Work?</h2><div>Route Servers&nbsp;keep track of the BGP sessions they maintain with each participant AS through RIBs.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "eTA<4d5UPk",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div>In the BGP protocol, destinations are represented by {{c1::IP prefixes}}. Each {{c1::prefix}} represents {{c2::a subnet or a collection of subnets that an AS can reach}}. Gateway routers running {{c3::eBGP}} advertise {{c4::the IP prefixes they can reach}} according to the AS's specific export policy to routers in neighboring ASes. Then, using separate {{c5::iBGP sessions}}, the gateway routers disseminate these routes for external destinations to other internal routers according to {{c6::the AS's import policy}}. Internal routers run {{c5::iBGP}} to propagate {{c7::the external routes}} to {{c7::other internal iBGP speaking routers}}.&nbsp;&nbsp;</div>",
                        ""
                    ],
                    "guid": "eY@YDLo{}}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Business Relationships\n</h2><div>What are the prevalent forms of business relationships between ASes:<br></div><div><ul><li>{{c1::Provider-Customer relationship (or transit)}}</li><li>{{c1::Peering relationship}}</li></ul></div>",
                        ""
                    ],
                    "guid": "e]}3PhT;Gq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2>\n<h3>What's Inside a Router?</h3>\n<div>Modern fast routers use {{c1::crossbar switches}} for the switching task.<br></div>",
                        "Scheduling the switch (matching available inputs with outputs) is difficult because multiple inputs may want to send packets to the same output.&nbsp;"
                    ],
                    "guid": "ewP;*q|i!!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div>Public peering:&nbsp;The most well-known use of IXPs is public peering service, in which {{c1::two networks use the IXP’s network infrastructure to establish a connection to exchange traffic based on their bilateral relations and traffic requirements}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "fQ{^<-ec)o",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div>One of the services offered by IXPs is protection against ________ attacks.<br></div>",
                        "<div><ul><li>BGP Hijacking&nbsp;</li><li>DDoS&nbsp;</li><li>Malware&nbsp;</li><li>Phishing</li></ul></div>",
                        "<ul><li><strike>BGP Hijacking</strike></li><li><span style=\"color: rgb(0, 0, 255);\">DDoS</span></li><li><strike>Malware</strike></li><li><strike>Phishing</strike></li></ul>"
                    ],
                    "guid": "fp:6bMjl2C",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Business Relationships\n</h2><div>In a {{c1::peering relationship}}, two ASes share access to {{c2::a subset of each other's routing tables}}.</div>",
                        ""
                    ],
                    "guid": "g)92MsVkR@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div>NEXT HOP:&nbsp;This attribute refers to the next-hop router's {{c1::IP address (interface) along the path towards the destination}}. Internal routers use the field to store {{c2::the IP address of the border router}}.<br></div>",
                        "Internal BGP routers will forward all traffic bound for external destinations through the border router. Suppose there is more than one such router on the network, and each advertises a path to the same external destination. In that case, NEXT HOP allows the internal router to store in the forwarding table the best path according to the AS routing policy."
                    ],
                    "guid": "i]$TE!Hiw&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div><div>Why do networks choose to peer at IXPs?</div><ul><li>They are keeping {{c1::local traffic local}}</li><li>{{c2::Lower costs}}</li><li>{{c3::Network performance}}</li><li>{{c4::Incentives}}</li></ul></div>",
                        "Critical players in today’s Internet ecosystem often “incentivize” other networks to connect at IXPs. For example, a prominent content provider may require another network to be present at a specific IXP or IXPS in order to peer with them."
                    ],
                    "guid": "ifCA$WGwrH",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>In a peering relationship, the traffic exchanged between the two peers must be highly&nbsp;asymmetric&nbsp;so that there is enough incentive for both parties to&nbsp;peer with each other.<br></div><div>T/F?</div>",
                        "False"
                    ],
                    "guid": "j%S|U-asg6",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div><div>In addition to the reachable IP prefix field, advertised&nbsp;BGP routes&nbsp;consist of several&nbsp;{{c1::BGP attributes}}. Two notable {{c1::attributes}} are {{c2::AS-PATH}} and {{c2::NEXT-HOP}}.</div></div>",
                        ""
                    ],
                    "guid": "jCoj%IN]-4",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Challenges with BGP: Scalability and Misconfigurations\n</h2><div>A possible misconfiguration or an error can create {{c1::an excessively large number of updates}}, resulting in:</div><div><ul><li>route {{c2::instability}}</li><li>{{c3::router processor and memory overloading}}</li><li>{{c4::outages}}</li><li>{{c5::router failures}}</li></ul></div>",
                        ""
                    ],
                    "guid": "jK1GLeH{U+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs: How Does a Route Server Work?</h2><div><div>A Route Server (RS)&nbsp;does the following:</div><ul><li>{{c1::Collects and shares routing information from its peers or participants of the IXP that connect to the RS}}</li><li>{{c1::Executes its own BGP decision process and re-advertises the resulting information (e.g., best route selection) to all RS's peer routers}}</li></ul></div>",
                        ""
                    ],
                    "guid": "jf<]yO[@Lz",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>{{c1::Route filters}} are {{c2::rules that determine which routes an AS's router should advertise to the routers of neighboring ASes}}.<br></div>",
                        ""
                    ],
                    "guid": "kcH<@5@Jo_",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>To complete the picture of today's Internet interconnection ecosystem, we note that ISPs may also connect through:<br><ul><li>{{c1::Points of Presence (PoPs)}}</li><li>{{c1::multi-homing}}</li><li>{{c1::peering}}</li></ul>",
                        "PoPs are one (or more) routers in a provider's network, which a customer network can use to connect to that provider. Also, an ISP may choose to multi-home by connecting to one or more provider networks. Finally, two ISPs may choose to connect through a settlement-free agreement where neither network pays the other to directly send traffic to one another."
                    ],
                    "guid": "ky4Lb?N=1t",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  iBGP and eBGP\n</h2><div>Which protocol is used to disseminate routes for external destinations?</div>",
                        "Both iBGP and eBGP"
                    ],
                    "guid": "k}$-uIYXb6",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2><div>The internet topology has been evolving from a {{c1::hierarchical}}&nbsp;structure into a {{c1::flat}}&nbsp;structure.&nbsp;</div>",
                        ""
                    ],
                    "guid": "lMwzZ#KBKt",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Remote Peering</h2><div>The primary method of identifying remote peering is {{c1::to measure the round-trip time (RTT) between a vantage point (VP) inside the IXP and the IXP peering interface of a member}}.<br></div>",
                        "<span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">However, this method fails to account for the changing landscape of IXPs today and even misinfers latencies of remote members as local and local members as being remote.</span>"
                    ],
                    "guid": "lN*K_OC%bn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04",
                        "optional"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div><div>Each AS is identified by its&nbsp;{{c1::autonomous system number (ASN)}}. As an announcement passes through various ASes, their identifiers are included in the {{c2::ASPATH}} attribute.&nbsp;This attribute {{c3::prevents loops}} and is used to {{c4::choose between multiple routes to the same destination, the route with the shortest path}}.</div></div>",
                        ""
                    ],
                    "guid": "m2yB^h~{CD",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2>\n<h3>What's Inside a Router?</h3>\n<h4>Protocol Processing</h4><div><div>The routers need to implement the following protocols to implement their functions:</div><ul><li>{{c1::Simple Network Management Protocol (SNMP)}} for a set of counters for remote inspection</li><li>{{c2::TCP and UDP}} for remote communication with the router</li><li>{{c3::Internet Control Message Protocol (ICMP)}} for sending error messages, e.g., when time-to-live (TTL) time is exceeded</li></ul></div>",
                        ""
                    ],
                    "guid": "m[uqhx>qu>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div><div>The MED ({{c1::Multi-Exit Discriminator}}) value is used by ASes connected by multiple links to designate which of those links are preferred for {{c2::Inbound}} traffic.</div></div>",
                        ""
                    ],
                    "guid": "nMAPbmZtq:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>There is no incentive for smaller ISPs to peer with each other.&nbsp;<br></div><div>T/F?</div>",
                        "False"
                    ],
                    "guid": "o*i)+y|gXY",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  iBGP and eBGP\n</h2><div>IGP-like protocols are used to {{c1::establish paths between the internal routers of an AS based on specific costs within the AS}}. In contrast, iBGP is {{c2::only used to disseminate external routes within the AS}}.</div>",
                        ""
                    ],
                    "guid": "o=&-zC88[A",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP and Design Goals\n</h2><h3>What are the design goals of the BGP protocol?</h3><div><b>Security</b>: There have been several efforts to enhance BGP security ranging from</div><div><ul><li>{{c1::protocols (e.g., S-BGP)}}</li><li>{{c2::additional infrastructure (e.g., registries to maintain up-to-date information about which ASes own which prefixes ASes)}}</li><li>{{c3::public keys for ASes}}, etc.</li></ul></div>",
                        ""
                    ],
                    "guid": "oHs:wi8o5`",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div>Attributes are set:</div><div><ul><li>locally by the AS (e.g., {{c1::LocalPref}})</li><li>by the neighboring AS (e.g., {{c2::MED}})</li><li>by the protocol (e.g., {{c3::if a route is learned through eBGP or iBGP}})</li></ul></div>",
                        ""
                    ],
                    "guid": "oh-u(>`djj",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>Routes learned from peers:&nbsp;It does not make sense for X to advertise to provider A the routes it receives from provider B because {{c1::providers A and B will use X to reach the advertised destinations without X making revenue}}.</div>",
                        ""
                    ],
                    "guid": "p7qHzs4DI;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div><div>There are two kinds of updates:</div><div><ul><li>{{c1::Announcements}}: {{c2::messages that advertise new routes and updates to existing routes. They include several standardized attributes.}}</li><li>{{c1::Withdrawals}}: {{c3::a previously announced route is no longer available.}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "pM~%gjZjd7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2>\n<h3>What's Inside a Router?</h3>\n<div>The routers use the {{c1::longest prefix matching}} algorithms to resolve any disambiguities. Some routers offer a more specific and complex type of lookup, called {{c2::packet classification}}, where the lookup is based on {{c3::destination or source IP addresses, port, and other criteria}}.<br></div>",
                        ""
                    ],
                    "guid": "pN4L>J8Ksf",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP and Design Goals\n</h2><h3>What are the design goals of the BGP protocol?</h3>\n<div><b>Express routing policies</b>: BGP has defined route attributes that allow ASes to implement policies (which routes to import and export) through {{c1::route filtering}} and {{c1::route ranking}}.<br></div>",
                        "<div>\n  Each ASes routing decisions can be kept confidential, and each AS can implement them independently of one another.\n</div>"
                    ],
                    "guid": "pbYI$-v`)i",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2><h3>What's Inside a Router?</h3><div>Control plane functions refer to:</div><div><ul><li>implementing the {{c1::routing protocols}}</li><li>maintaining the {{c1::routing tables}}</li><li>computing the {{c1::forwarding table}}</li></ul></div>",
                        "These functions are implemented in software in the routing processor, or could be implemented by a remote controller."
                    ],
                    "guid": "qUHG3f,k%X",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>{{c1::An AS (Autonomous System)}} is {{c2::a group of routers (including the links among them) that operate under the same administrative authority}}.<br>",
                        "An ISP, for example, may operate as a single AS, or it may operate through multiple ASes. Each AS implements its own set of policies, makes its own traffic engineering decisions and interconnection strategies, and determines how the traffic leaves and enters its network."
                    ],
                    "guid": "qnh8CrEl4t",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Remote Peering</h2><div>Remote peering (RP) is {{c1::peering at the peering point without the necessary physical presence}}. The&nbsp;remote peering provider&nbsp;is {{c2::an entity that sells access to IXPs through their own infrastructure}}.<br></div>",
                        "RP removes the barrier to connecting to IXPs around the world, which in itself can be a more cost-effective solution for localized or regional network operators."
                    ],
                    "guid": "r(GvX&j1YS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04",
                        "optional"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2>\n<h3>What's Inside a Router?</h3>\n<div>When a packet arrives at the input link,&nbsp; the router looks at {{c1::the destination IP address}} and determines the output link by {{c2::looking at the forwarding table (or Forwarding Information Base or FIB)}}. The {{c2::FIB}} provides {{c3::a mapping between destination prefixes and output links}}.</div>",
                        ""
                    ],
                    "guid": "r*$dsZ9v-h",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Business Relationships\n</h2><div><div>One major factor determining a provider's revenue is the data rate of an interconnection. A provider usually charges in one of two ways:</div><div><ul><li>{{c1::Based on a fixed price, given that the bandwidth used is within a predefined range.}}</li><li>{{c1::Based on the bandwidth used. The bandwidth usage is calculated based on periodic measurements, e.g., five-minute intervals. The provider then charges by taking the 95th percentile of the distribution of the measurements.}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "r8vkdhs69N",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>In order of decreasing preference, the imported routes are the&nbsp;{{c1::customer}}&nbsp;routes, then the&nbsp;{{c1::peer}}&nbsp;routes, and finally the&nbsp;{{c1::provider}}&nbsp;routes.<br></div>",
                        ""
                    ],
                    "guid": "r:>[Mlqg,f",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div><div>What services are offered at IXPs?</div><ul><li>{{c1::Public peering}}</li><li>{{c1::Private peering}}</li><li>{{c2::Route servers and Service level agreements}}</li><li>{{c2::Remote peering through resellers}}</li><li>{{c2::Mobile peering}}</li><li>{{c3::DDoS blackholing}}</li><li>{{c3::Free value-added services}}</li></ul></div>",
                        ""
                    ],
                    "guid": "rts0H~iQ{5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Peering at IXPs: How Does a Route Server Work?</h2><div>Route servers maintain two types of route filters.</div><div><ul><li>{{c1::Import filters&nbsp;are applied to ensure that each member AS only advertises routes that it should advertise.}}</li><li>{{c1::Export filters&nbsp;are&nbsp;typically triggered by the IXP members themselves to restrict the set of other IXP member ASes that receive their routes.}}</li></ul></div>",
                        ""
                    ],
                    "guid": "s,Pa[ABGMD",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2><div><div>An Autonomous System is a group of routers that operate under {{c1::the same::the same/multiple}}&nbsp;administrative {{c1::authority::authority/authorities}}.</div></div>",
                        ""
                    ],
                    "guid": "sPdc:j84R*",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Protocol Basics\n</h2><div><div>We have two types of <b>BGP messages</b>:&nbsp;</div><ul><li>{{c1::UPDATE}}&nbsp;messages: {{c2::contain information about the routes that have changed since the previous update.}}</li><li>{{c1::KEEPALIVE}}&nbsp;messages: {{c3::are exchanged between peers to keep a current session going.}}</li></ul></div>",
                        ""
                    ],
                    "guid": "sV8o{0lmrw",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  iBGP and eBGP\n</h2><div>iBGP is used to disseminate routes for {{c1::external::internal/external}} destinations.</div>",
                        "iBGP is used to communicate external routes to internal (non-border) routers within the AS."
                    ],
                    "guid": "t?xZI<oN-I",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>A&nbsp;customer-provider&nbsp;relationship between&nbsp;ASes&nbsp;is based on a financial settlement, which determines how much the&nbsp;customer will pay the provider. The provider&nbsp;takes care of connecting the customer&nbsp;network with&nbsp;destinations found in the provider's routing&nbsp;table.&nbsp;The customer pays regardless of the direction of the traffic.&nbsp;&nbsp;<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "tYE<]:byHV",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div><b>Routes learned from customers</b>: Since provider X is getting paid to provide reachability to a customer AS, it makes sense that X wants to advertise these customer routes to {{c1::as many other neighboring ASes as possible}}.<br></div>",
                        ""
                    ],
                    "guid": "tyh?j]G[k9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div><div>The LocalPref attribute is used to prefer routes learned through a specific AS over other ASes for {{c1::Outbound::Inbound/Outbound}}&nbsp;traffic.&nbsp;</div></div>",
                        ""
                    ],
                    "guid": "uM8=]/eO2k",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2><div>The output ports {{c1::receive and queue the packets from the switching fabric}} and then {{c2::send them over to the outgoing link}}.<br></div>",
                        ""
                    ],
                    "guid": "uxukLh}o~s",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>An AS <b>receives</b> route advertisements from its {{c1::customers}}, {{c1::providers}}, and {{c1::peers}}.</div>",
                        ""
                    ],
                    "guid": "v+s~AV6EVi",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP and Design Goals\n</h2><h3>\n  What are the design goals of the BGP protocol?\n</h3><div><b>Scalability</b>: One of the design goals of BGP is to manage the complications of this growth while {{c1::achieving convergence in reasonable timescales}}&nbsp;and {{c2::providing loop-free paths}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "vJ0*r(4o3?",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Business Relationships\n</h2><div>{{c1::A Provider-Customer relationship (or transit)}} is based on {{c2::a financial settlement that determines how much the customer will pay the provider}}.<br></div>",
                        "The provider forwards the customer's traffic to destinations found in the provider's routing table (including the opposite direction of the traffic)."
                    ],
                    "guid": "vpppg45/$n",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  Peering at IXPs</h2><div>Private peering:&nbsp;Most operational IXPs also provide a private peering service (Private Interconnects, or PIs) that allows {{c1::direct traffic exchange between the two parties, and doesn’t use the IXP’s public peering infrastructure}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "w:H#biC!.9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>{{c1::Advertising}} a route for a destination to a neighboring AS means that {{c2::this route may be selected by that AS}}, and {{c2::traffic will start to flow through}}.<br></div>",
                        ""
                    ],
                    "guid": "wFxm#WmIm2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>{{c1::Internal Gateway Protocols (IGPs)}} operate {{c2::within an AS::locality}}, and they are focused on {{c3::\"optimizing a path metric\" within that network}}.<br>",
                        "Example IGPs include Open Shortest Paths First (OSPF), Intermediate System - Intermediate System (IS-IS), Routing Information Protocol (RIP), and E-IGRP."
                    ],
                    "guid": "wZdKI+6fLq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2><div>The switching fabric {{c1::moves the packets from input to output ports}}, and it {{c1::makes the connections between the input and the output ports}}.</div><div>There are three types of switching fabrics:</div><div><ul><li>{{c2::memory}}</li><li>{{c2::bus}}</li><li>{{c2::crossbar}}</li></ul></div>",
                        ""
                    ],
                    "guid": "w~Z)V%!p5%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div>A router compares a pair of routes by {{c1::going through the list of attributes}}.</div>",
                        "For each attribute, it selects the route with the attribute value that will help apply the policy. If for a specific attribute, the values are the same, then it goes to the next attribute."
                    ],
                    "guid": "x*C2y1];.;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 4: AS Relationships and Interdomain Routing</h1><h2>Router Design and Algorithms</h2>\n<h3>What's Inside a Router?</h3>\n<h4>Header validation and checksum</h4><div>The router checks the packet's {{c1::version number}}, decrements&nbsp;the {{c2::time-to-live (TTL) field}}, and recalculates {{c3::the header checksum}}.</div>",
                        ""
                    ],
                    "guid": "x+V)/BfmE0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2>ISPs can be categorized into three tiers or types:<br><ul><li>{{c1::access ISPs (or Tier-3)}}</li><li>{{c1::regional ISPs (or Tier-2)}}</li><li>{{c1::large global scale ISPs (or Tier-1)}}</li></ul>",
                        "There are a dozen of large-scale Tier-1 ISPs that operate at a global scale, and essentially they form the \"backbone\" network over which smaller networks can connect. Some example Tier-1 ISPs include AT&amp;T, NTT, Level-3, and Sprint. In turn, regional ISPs connect to Tier-1 ISPs, and smaller access ISPs connect to regional ISPs."
                    ],
                    "guid": "xneYA[(8fd",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  iBGP and eBGP\n</h2><div>What is the difference between iBGP and eBGP?<br></div>",
                        "Both flavors (iBGP and eBGP) take care of disseminating <i>external</i> routes. An eBGP session is established between two border routers that belong to different ASes. An iBGP session is established between routers that belong to the same AS. Once a router hears about a route that is learned through eBGP, then it disseminates that route to other internal routers in the same AS, using iBGP."
                    ],
                    "guid": "xuRj4ue#?-",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div><div>Assume that <b>AS X</b> learns of a route to the same destination a via <b>AS Y</b> and <b>AS Z</b>. If <b>X</b> prefers to route its traffic through <b>Z</b> due to peering or business, it can assign a {{c1::Higher::Lower/Higher}} LocalPref value to routes it learns from <b>Z</b>, and thus using LocalPref, <b>AS X</b> can control where traffic exits the AS.&nbsp;</div></div>",
                        ""
                    ],
                    "guid": "y-<:}j]CJy",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Decision Process: Selecting Routes at a Router\n</h2><div>A router receives incoming BGP messages and processes them. When a router receives advertisements, it:</div><div><ul><li>{{c1::applies the import policies}} to exclude routes from further consideration.</li><li>Then the router implements the decision process to {{c2::select the best routes}} that reflect the policy in place.</li><li>Next, the&nbsp;newly selected routes are {{c3::installed in the forwarding table}}.</li><li>Finally, the router decides which neighbors to export the route to by {{c4::applying the export policy}}.&nbsp;</li></ul></div>",
                        ""
                    ],
                    "guid": "ygp!h8ER5{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  BGP Routing Policies: Importing and Exporting Routes\n</h2><div>Routes learned from providers: Advertising these routes does not make&nbsp;sense since {{c1::the AS does not have the financial incentive to carry traffic for its provider's routes}}.<br></div>",
                        ""
                    ],
                    "guid": "z4VqSkseZ?",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson04"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>\n  Lesson 4: AS Relationships and Interdomain Routing</h1>\n<h2>\n  AS Relationships and Interdomain Routing\n</h2><div><div>Autonomous Systems implement their own set of policies, make their own traffic engineering decisions and interconnection strategies, and determine how traffic leaves and enters the network.</div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "zq4EPUa0-A",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lesson04",
                        "lesson_quiz"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e17702e-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 23,
            "extendRev": 0,
            "media_files": [
                "multibitTrie.svg",
                "unibitTrie.jpg",
                "unibitTrieQuiz.svg"
            ],
            "name": "Lesson 05: Router Design and Algorithms",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>{{c1::Prefix Expansion}}</h2>\n<div><div>A strategy called&nbsp;{{c1::controlled prefix expansion}}, expands variable sized prefixes to a multiple of the chosen stride length.</div><div>&nbsp;&nbsp;</div><div>For example with a stride size of 3, P3 = 11001* gets expanded to {{c2::110010* and 110011*}}.&nbsp;</div></div>",
                        ""
                    ],
                    "guid": "A!A~RH;rY)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><div><div>Classify each function as an operation of either the data plane or control plane.</div><div><ul><li>Computing paths based on a protocol = {{c1::Control::Data/Control}} Plane</li><li>Forwarding packets at Layer 3 = {{c2::Data::Data/Control}} Plane</li><li>Switching packets at Layer 2 =&nbsp; {{c3::Data::Data/Control}} Plane</li><li>Running protocols to build a routing table = {{c4::Control::Data/Control}} Plane</li><li>Running the Spanning Tree protocol = {{c5::Control::Data/Control}} Plane</li><li>Decrementing Time To Live (TTL) = {{c6::Data::Data/Control}} Plane</li><li>Computing an IP header checksum = {{c7::Data::Data/Control}} Plane</li><li>Running a protocol/logic to configure a middle box device for load balancing = {{c8::Control::Data/Control}} Plane</li><li>Forwarding packets according to installed rules in a middlebox device = {{c9::Data::Data/Control}} Plane</li></ul></div></div>",
                        ""
                    ],
                    "guid": "A:FN&>+kpE",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<!--\ngraph {\n    0 [label=\"\"];\n    1 [label=\"a\" style=filled color=\"lightblue\"];\n    2 [label=\"b\" style=filled color=\"lightblue\"];\n    3 [label=\"\"];\n    4 [label=\"c\" style=filled color=\"lightblue\"];\n    5 [label=\"d\" style=filled color=\"lightblue\"];\n    6 [label=\"\"];\n    7 [label=\"e\" style=filled color=\"lightblue\"];\n    8 [label=\"f\" style=filled color=\"lightblue\"];\n    9 [label=\"\"];\n    10 [label=\"g\" style=filled color=\"lightblue\"];\n    11 [label=\"h\" style=filled color=\"lightblue\"];\n    \n    0 -- 1 [label=\"0\"];\n    0 -- 2 [label=\"1\"];\n    1 -- 3 [label=\"0\"];\n    1 -- 4 [label=\"1\"];\n    2 -- 5 [label=\"0\"];\n    2 -- 6 [label=\"1\"];\n    3 -- 7 [label=\"0\"];\n    6 -- 8 [label=\"1\"];\n    7 -- 9 [label=\"1\"];\n    9 -- 10 [label=\"0\"];\n    9 -- 11 [label=\"1\"];\n}\n-->\n<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Unibit Tries</h2>\n<div><div>Consider the following unibittrie. Nodes in blue represents stored prefixes.</div><div><img src=\"unibitTrieQuiz.svg\"><br></div><div>For each prefix look up, determine the node we return.</div></div><div><div><ul><li>&nbsp;0* : {{c1::a}}</li><li>&nbsp;1* :&nbsp; {{c1::b}}</li><li>&nbsp;01* : {{c1::c}}</li><li>00* : {{c2::a}}</li><li>0000* : {{c2::e}}</li><li>00011* : {{c2::h}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "B@F]v~(U:J",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Multibit Tries: Variable Stride</h2>\n<div><div>Some&nbsp;key points&nbsp;about variable stride:</div><ul><li>Every node can have {{c1::a different number of bits to be explored}}.</li><li>The optimizations to the stride length for each node are all done to {{c2::save trie memory and the least memory accesses}}.</li><li>An optimum variable stride is selected by using {{c3::dynamic programming}}</li></ul></div>",
                        ""
                    ],
                    "guid": "B^R:)v4K!-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Multibit Tries</h2>\n<div>A multibit trie is {{c1::shorter}}  than a unibit trie representing the same prefix database and requires {{c1::fewer}} memory accesses to perform a lookup.</div>",
                        ""
                    ],
                    "guid": "EkAcP6MT>7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><h2>Different Types of Switching</h2><div><b>Switching via interconnection network</b>: A crossbar switch is an interconnection network that connects N input ports to N output ports using {{c1::2N::How many?}} buses. A Crossbar network can carry multiple packets at the same time, as long as {{c2::they are using different input and output ports}}.<br></div>",
                        ""
                    ],
                    "guid": "F4e<QzU2zj",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>{{c1::Multibit Tries}}</h2>\n<div>A {{c1::multibit trie}} is a {{c1::trie}} where each node has {{c2::\\(2^k\\)}}&nbsp;children, where k is the stride.<br></div>",
                        ""
                    ],
                    "guid": "IM7|oc~w>n",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><div><div>The control plane functions of a traditional router are implemented in {{c1::software}}.</div></div>",
                        ""
                    ],
                    "guid": "Mwvr7$2q|@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<!--\ngraph {\n    n1 -- n2 [label=00]\n    n1 -- n3 [label=01]\n    n1 -- n4 [label=10]\n    n1 -- n5 [label=11]\n    n3 -- n6 [label=00]\n    n3 -- n7 [label=01]\n    n3 -- n8 [label=10]\n    n3 -- n9 [label=11]\n    n4 -- n10 [label=0]\n    n4 -- n11 [label=1]\n    n5 -- n12 [label=00]\n    n5 -- n13 [label=01]\n    n5 -- n14 [label=10]\n    n5 -- n15 [label=11]\n    n6 -- n16 [label=0]\n    n6 -- n17 [label=1]\n}\n-->\n<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Multibit Tries</h2>\n<div><div>Consider the following prefix database that provides a mapping between nodes (a,b,c,..) and prefixes (eg 0*,1*, etc).</div><div><ul><li>a =&gt; 0*</li><li>b =&gt; 01000*</li><li>c =&gt; 011*</li><li>d =&gt; 1*</li><li>e =&gt; 100*</li><li>f =&gt; 1100*</li><li>g =&gt; 1101*</li><li>h =&gt; 1110*</li><li>i =&gt; 1111*&nbsp;</li></ul></div><div>Construct the following variable-stride multibit trie. Based on the above database, fill in the nodes (eg n1, n2, n3, etc) with the corresponding nodes from the database (a, b, c, etc).</div><img src=\"multibitTrie.svg\"><br></div>\n<table border=\"1\">\n<tbody>\n<tr>\n<td>\n<p>n1: {{c1::none}}</p>\n</td>\n<td>\n<p>n2: {{c1::a}}</p>\n</td>\n<td>\n<p>n3: {{c1::a}}</p>\n</td>\n</tr>\n<tr>\n<td>\n<p>n4: {{c1::d}}</p>\n</td>\n<td>\n<p>n5: {{c1::d}}</p>\n</td>\n<td>\n<p>n6: {{c2::none}}</p>\n</td>\n</tr>\n<tr>\n<td>\n<p>n7: {{c2::none}}</p>\n</td>\n<td>\n<p>n8: {{c2::c}}</p>\n</td>\n<td>\n<p>n9: {{c2::c}}</p>\n</td>\n</tr>\n<tr>\n<td>\n<p>n10: {{c3::e}}</p>\n</td>\n<td>\n<p>n11: {{c3::none}}</p>\n</td>\n<td>\n<p>n12: {{c4::f}}</p>\n</td>\n</tr>\n<tr>\n<td>\n<p>n13: {{c4::g}}</p>\n</td>\n<td>\n<p>n14: {{c4::h}}</p>\n</td>\n<td>\n<p>n15: {{c4::i}}</p>\n</td>\n</tr>\n<tr>\n<td>\n<p>n16: {{c5::b}}</p>\n</td>\n<td>\n<p>n17: {{c5::none}}</p>\n</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>",
                        ""
                    ],
                    "guid": "O]4V{X4|sw",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><h2>Different Types of Switching</h2><div><b>Switching via memory</b>:&nbsp;Input/Output ports operate as {{c1::I/O devices}} in an operating system, controlled by the routing processor. When an input port receives a packet, it sends {{c2::an interrupt}} to the routing processor, and the packet is copied to the processor's memory. Then the processor extracts the destination address and looks into the {{c3::forward table}} to find the output port, and finally, the packet is copied into that output's port buffer.<br></div>",
                        ""
                    ],
                    "guid": "OaNvLi3hac",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><h2>Different Types of Switching</h2><div><b>Switching via bus</b>: When an input port receives a new packet, it {{c1::puts an internal header that designates the output port}}, and it sends the packet to the shared bus. Then {{c2::all the output ports}} will receive the packet, {{c2::but only the designated one will keep it}}. {{c3::Only one packet::How many packets?}} can cross the bus at a given time<br></div>",
                        ""
                    ],
                    "guid": "P1zULOynF*",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><div>The data plane functions of a traditional router are implemented in {{c1::hardware::hardware/software}}.<br></div>",
                        ""
                    ],
                    "guid": "cuGUa_Q#=u",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>\n  Prefix-Match Lookups</h2><h3>Why do we need (better) lookup algorithms?</h3><div><ul><li>Measurement studies on network traffic had shown a large number of concurrent flows of short duration. As a consequence, {{c1::caching}} solutions will not work efficiently.</li><li>A large part of the cost of computation for lookup is {{c2::accessing memory}}.</li><li>An unstable routing protocol may adversely impact {{c3::the update time in the table: add, delete or replace a prefix}}.</li><li>A vital trade-off is {{c4::memory usage (fast/expensive vs slower/cheap)}}.</li></ul></div>",
                        ""
                    ],
                    "guid": "c|y/Uk_)w@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>\n  Prefix-Match Lookups</h2><h3>What is the need for variable-length prefixes?</h3><div>In the earlier days of the Internet, we used an IP addressing model based on {{c1::classes (fixed-length prefixes)}}. With the rapid exhaustion of IP addresses, in 1993, the {{c2::Classless Internet Domain Routing (CIDR)}} came into effect. {{c2::CIDR}} essentially assigns IP addresses using {{c3::arbitrary-length prefixes}}. {{c2::CIDR}} has helped to decrease the router table size, but at the same time, it introduced us to a new problem:&nbsp;{{c4::longest-matching-prefix lookup}}.<br></div>",
                        ""
                    ],
                    "guid": "e#?q[C^AM7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><div>What type of switching can send multiple packets across the fabric in parallel?<br></div>",
                        "Interconnection Network / Crossbar"
                    ],
                    "guid": "e1X2qyvZud",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>\n  Prefix-Match Lookups\n</h2>\n<div>The different ways to denote prefix are:</div><div><ul><li>{{c1::Dot decimal}}</li><ul><li>{{c2::Example of the 16-bit prefix: 132.234}}</li></ul><li>{{c1::Slash notation}}</li><ul><li>{{c3::Standard notation: A/L (where A=Address, L=Length)<br>Example: 132.238.0.0/16<br>Here, 16 denotes that only the first 16 bits are relevant for prefixing}}</li></ul><li>{{c1::Masking}}</li><ul><li>{{c4::Example: The prefix 123.234.0.0/16 is written as 123.234.0.0 with a mask 255.255.0.0}}</li></ul></ul></div>",
                        ""
                    ],
                    "guid": "f^,G*wecu,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>\n  {{c1::Unibit Tries}}\n</h2>\n<div>One of the simplest techniques for prefix lookup is the {{c1::unibit trie}}.<br></div>",
                        "<img src=\"unibitTrie.jpg\">"
                    ],
                    "guid": "gwGaf)sHlY",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Unibit Tries</h2>\n<div><div>These are the steps we follow to perform a prefix match:</div><ul><li>{{c1::We begin the search for a longest prefix match by tracing the trie path.}}</li><li>{{c1::We continue the search until we fail (no match or an empty pointer)}}</li><li>{{c1::When our search fails, the last known successful prefix traced in the path is our match and our returned value}}</li></ul></div>",
                        "<div><ul><li>If a prefix is a substring of another prefix, the smaller string is stored in the path to the longer (more specific prefix).</li><li>One-way branches. For efficiency, we compress one-way branches to a single text string..</li></ul></div>"
                    ],
                    "guid": "idNVA$!OYI",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Multibit Tries</h2>\n<div>While a&nbsp;<b>unibit trie</b>&nbsp;is very efficient and offers advantages such as fast lookup and easier updates, its most significant&nbsp;problem&nbsp;is {{c1::the number of memory accesses required to perform a lookup}}.<br></div><div>Instead, we can implement lookups using a {{c2::stride}}. The {{c2::stride}} is {{c3::the number of bits that we check at each step}}.<br></div>",
                        ""
                    ],
                    "guid": "jCt:BD=84J",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Multibit Tries</h2>\n<div><div>Multibit tries can support an arbitrary number of prefix lengths.&nbsp;</div><div>T/F?</div></div>",
                        "<div><div><div><div><div><b>False</b></div><br><div></div></div><div></div></div><div></div></div><div></div></div><div><div>To use a given multibit&nbsp;trie, the prefix set must be transformed into an equivalent set with&nbsp;the prefix lengths allowed by the new structure.</div></div>"
                    ],
                    "guid": "lGJ6%}w$f:",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1><div><div>Which plane operates on a shorter timescale?</div></div>",
                        "<ul><li>Control&nbsp;</li><li>Data&nbsp;</li><li>Management&nbsp;</li><li>All planes operate on the same timescale</li></ul>",
                        "<ul><li><strike>Control</strike></li><li><span style=\"color: rgb(0, 0, 255);\">Data</span></li><li><strike>Management</strike></li><li><strike>All planes operate on the same timescale</strike></li></ul>"
                    ],
                    "guid": "lHYhW|fw`w",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>\n  Prefix-Match Lookups</h2><div>Determine the mask for the address 192.168.0.1/24.</div>",
                        "255.255.255.0"
                    ],
                    "guid": "lstn!^>25@",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>\n  The Challenges Routers Face\n</h2>\n<div>The fundamental problems that a router faces revolve around:<br><ul><li>{{c1::Bandwidth and Internet population scaling}}</li><li>{{c1::Services (that the router needs to perform) at high speeds}}<br></li></ul></div>\n",
                        ""
                    ],
                    "guid": "n?h87*3J!(",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Multibit tries: Fixed-Stride</h2>\n<div><div>Some key points with fixed-stride tries:</div><ul><li>Every element in a trie represents two pieces of information: {{c1::a pointer}} and {{c1::a prefix value}}.</li><li>The prefix search moves ahead with the preset length in n-bits</li><li>When the path is traced by a pointer, we {{c2::remember the last matched prefix (if any)}}</li><li>Our search ends when {{c3::an empty pointer is met. At that time, we return the last matched prefix as our final prefix match}}</li></ul></div>",
                        ""
                    ],
                    "guid": "o!sjDP1fGj",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>\n  The Challenges Routers Face\n</h2>\n<div>Router Bottlenecks:<br><ul><li>{{c1::Longest prefix matching}}: {{c2::algorithms for efficient longest prefix matching are complex}}</li><li>{{c1::Service differentiation}}: {{c3::quality-of-service (or security guarantees) requires routers to classify packets}}</li><li>{{c1::Switching limitations}}: {{c4::At high speeds even crossbar switching has limitations (e.g., head of line blocking)}}</li><li>{{c1::Bottlenecks about services}}: {{c5::Providing performance guarantees (quality of service) at high speeds is nontrivial}}</li></ul></div>",
                        ""
                    ],
                    "guid": "p*F5T.}UMq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Prefix-Match Lookups</h2>\n<div>Consider a router with the following forwarding table:</div>\n<table border=\"1\">\n<tbody>\n<tr>\n<td><strong>Prefix Match</strong></td>\n<td><strong>Output Link</strong></td>\n</tr>\n<tr>\n<td>101*</td>\n<td>A</td>\n</tr>\n<tr>\n<td>111*</td>\n<td>B</td>\n</tr>\n<tr>\n<td>1100 1*</td>\n<td>C</td>\n</tr>\n<tr>\n<td>otherwise</td>\n<td>D</td>\n</tr>\n</tbody>\n</table>\n<div>\n<div>Given that the router uses longest prefix matching. Determine the output link for packet with given destination IP address. Type the letter of the output link.</div>\n<div>\n<ul>\n  <li><code>1110 0001 1000 0000 0001 0001 0111 1001</code>: {{c1::B}}</li>\n<li><code>1111 0001 1111 0000 1010 0001 0111 0111</code>: {{c1::B}}</li>\n<li><code>1010 1010 1010 1010 1010 1010 1010 1010</code>: {{c1::A}}</li>\n<li><code>1100 1001 1000 0000 0001 0001 0111 0111</code>: {{c1::C}}</li>\n</ul>\n</div>\n</div>",
                        ""
                    ],
                    "guid": "rB]##Do|y=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 5: Router Design and Algorithms</h1>\n<h2>Prefix Expansion</h2>\n<div><div>Consider the following prefix database. &nbsp;</div><div><ol><li>P1 &nbsp; =&gt; &nbsp; 101* </li><li>P2 &nbsp; =&gt; &nbsp; 0* </li><li>P3 &nbsp; =&gt; &nbsp; 1* </li><li>P4 &nbsp; =&gt; &nbsp; 10101* </li></ol></div><div>&nbsp;</div><div>Consider expanding each prefix with stride length 3, so that we construct a fixed length multibit trie.&nbsp;</div><div>Which of the following prefixes are associated with P3? Select all that apply.</div></div>",
                        "<ol><li>110*</li><li>10*</li><li>100*</li><li>101*</li><li>001*</li><li>011*</li><li>111*</li></ol>",
                        "<ol><li><span style=\"color: rgb(0, 0, 255);\">110*</span></li><li>10* &lt;- not a valid prefix for a stride lenght of 3</li><li><span style=\"color: rgb(0, 0, 255);\">100*</span></li><li>101* &lt;- covered by P1</li><li>001*</li><li>011*</li><li><span style=\"color: rgb(0, 0, 255);\">111*</span></li></ol>"
                    ],
                    "guid": "sXwTl!}`9@",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson05",
                        "lesson_quiz"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e19223e-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "Lesson 06: Router Design and Algorithms",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Scheduling Introduction</h2>\n<h3>{{c1::FIFO with tail drop}}:</h3>\n<div>The simplest method of router scheduling is {{c1::FIFO with tail-drop}}. Once packets enter a router on input links, they are looked up using {{c2::the address lookup component}} – which gives the router an output port.This port is a {{c3::FIFO (first-in, first-out) queue}}. If the output link buffer is completely full, {{c4::incoming packets to the tail of the queue are dropped}}.<br></div>",
                        "This results in fast scheduling decisions but a potential loss in important data packets."
                    ],
                    "guid": "A1FS}G!o2:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6</h1>\n<h2>Traffic Scheduling: {{c1::Leaky Bucket}}</h2><div><div>The {{c1::leaky bucket algorithm}} is analogous to water flowing into a {{c1::leaky bucket}}, with the water leaking at a constant rate. It can be used in both traffic policing and traffic shaping. The bucket, say with capacity b, represents {{c2::a buffer that holds packets}}, and the water corresponds to {{c2::the incoming packets}}. The leak rate, r, is {{c3::the rate at which the packets are allowed to enter the network}}, which is constant irrespective of the rate at which packets arrive.</div></div>\n",
                        "Irrespective of the input rate of packets, the output rate is constant, which leads to uniform distribution of packets sent to the network. This algorithm can be implemented as a single server queue.&nbsp;"
                    ],
                    "guid": "B|ilyR5nwZ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Deficit Round Robin</h2>\n<h3>\n  Packet-level Fair Queuing\n</h3><div>This strategy emulates the bit-by-bit fair queueing by {{c1::sending the packet with the smallest finishing round number}}. At any round, the packet chosen to be sent out is garnered from {{c2::the previous round of the algorithm}}. The packet which {{c3::had been starved the most}} while sending out the previous packet from any queue is chosen</div>\n",
                        ""
                    ],
                    "guid": "CwGn%[6pS%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Scheduling Introduction</h2>\n<h3>Need for {{c1::Quality of Service (QoS)}}</h3>\n<div>Methods of packet scheduling such as priority, round-robin, etc. are useful in providing {{c1::quality of service (QoS) guarantees}} to a flow of packets on measures such as {{c2::delay}} and {{c2::bandwidth}}. A flow of packets refers to {{c3::a stream of packets that travels the same route from source to destination and requires the same level of service at each intermediate router and gateway}}.<br></div>",
                        "Flows must be identifiable using fields in the packet headers. For example, an internet flow could consist of all packets with either a source or destination port number of 23."
                    ],
                    "guid": "EklT%sdfPn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1><h2>Avoiding Head of Line Blocking</h2><div><i>Parallel iterative matching</i> runs in three rounds:<br></div><div><div><ul><li>{{c1::Request phase}}: {{c2::all inputs send requests in&nbsp;parallel&nbsp;to all outputs they want to connect with}}.</li><li>{{c1::Grant phase}}: {{c3::the&nbsp;outputs that receive multiple requests pick a random input.}}</li><li>{{c1::Accept phase}}:&nbsp;{{c4::inputs that receive multiple grants randomly pick an output to send to}}.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "G9o6RNpU20",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Deficit Round Robin</h2>\n<h3>\n  Bit-by-bit Round Robin\n</h3><div>The rate of increase in round number is {{c1::inversely proportional}} to the {{c2::number of active flows}}. An important takeaway is that {{c3::the number of rounds required to transmit a packet}} does not depend on {{c3::the number of backlogged queues}}.</div>\n",
                        ""
                    ],
                    "guid": "Ghs{CV{.v6",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Scheduling and {{c2::Head of Line Blocking}}</h2>\n<div>The {{c1::take-a-ticket}} algorithm has problem known as&nbsp;{{c2::head-of-line (HOL) blocking}}&nbsp;where {{c3::the entire queue is blocked by the progress of the head of the queue}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "I{Bb.w{F}|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1><h2>Deficit Round Robin</h2><h3>  Bit-by-bit Round Robin<br></h3><div>A round robin scheme at the {{c1::packet}} level could result in some flows {{c2::receiving less bandwidth}}. Doing this at the {{c3::bit}} level would solve that problem, but isn't possible. An imaginary bit-by-bit system can be used to calculate {{c4::the packet-finishing time}} and send a packet as a whole.</div>",
                        "For example if flow A has packets twice as large as B. A round robin scheme (selecting a packet from A then B then A...) would give flow A twice as much bandwith."
                    ],
                    "guid": "J]:JA(N7x%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Scheduling Introduction</h2>\n<h3>Need for Quality of Service (QoS)</h3>\n<div><div>The reasons to make scheduling decisions more complex than FIFO with tail drop are:</div><ul><li>Router support for {{c1::congestion}}</li><ul><li>While most traffic is based on TCP (which has its own ways to handle congestion), additional router support can improve the throughput of sources by helping handle {{c1::congestion}}.</li></ul><li>Fair sharing of {{c2::links among competing flows}}</li><ul><li>If we use FIFO with tail drop, this {{c2::blocks other flows, resulting in important connections on the clients’ end freezing}}.</li></ul><li>Providing {{c3::QoS guarantees}} to flows</li><ul><li>Fair sharing may guarantee {{c4::bandwidth}} or {{c4::delay limits}} to a flow.</li></ul></ul></div>",
                        "Delay through a router for a flow is noticeably important for live video."
                    ],
                    "guid": "Ju5-a3bs{>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Grid of Tries</h2>\n<div>With the grid of tries approach,&nbsp;we can reduce the wasted time in the backtracking search by using {{c1::precomputation}}. When there is a failure point in&nbsp;a source trie, we&nbsp;{{c2::precompute&nbsp;a&nbsp;switch pointer}}. Switch pointers take us directly to {{c3::the next possible source trie}} containing {{c4::a matching rule}}.</div>",
                        ""
                    ],
                    "guid": "K|a,@ZOF9;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Fast Searching Using Set-Pruning Tries</h2>\n<div>The simplest way to approach a two-dimensional rule (e.g. classify packets using both the source and the destination IP addresses) would be to {{c1::build a trie on the destination prefixes in the database, and then for every leaf-node at the destination trie to \"hang\" source tries}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "Lb?=Bq^|_j",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Deficit Round Robin</h2>\n<h3>\n  Packet-level Fair Queuing\n</h3><div>Bit-by-bit round-robin gives {{c1::bandwidth}} and {{c1::delay}} guarantees, but the time complexity is too high.<br></div>\n",
                        ""
                    ],
                    "guid": "O?&dajq6v>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1><h2>Avoiding Head of Line Blocking</h2><div>In {{c1::parallel iterative matching}}, we break down the {{c2::single queue}} into {{c2::virtual queues}}, with one {{c2::virtual queue}} per {{c2::output link}}.</div>",
                        ""
                    ],
                    "guid": "ON<yU)&2-1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Why We Need Packet Classification?</h2>\n<div><div>Some examples of packet classification are:</div><ul><li>{{c1::Firewalls}}: Routers implement firewalls at {{c2::the entry and exit points of the network}} to filter out unwanted traffic or to enforce other security policies.</li><li>{{c1::Resource reservation protocols}}: For example, {{c3::DiffServ}} has been used to reserve bandwidth between a source and a destination.</li><li>{{c1::Routing based on traffic type}}: Routing based on the specific type of traffic helps {{c4::avoid delays for time-sensitive applications}}.</li></ul></div>",
                        ""
                    ],
                    "guid": "PD|IRuee:f",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Fast Searching Using Set-Pruning Tries</h2>\n<div>The problem with the set pruning tries is {{c1::memory explosion}}. Because a source prefix {{c2::can occur in multiple destination tries}}.<br></div>",
                        ""
                    ],
                    "guid": "fTQU=)@0JG",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6</h1>\n<h2>Traffic Scheduling: Token Bucket</h2><h3>Token Bucket Shaping</h3><div>The bucket shaping technique assumes a bucket per flow that {{c1::fills with tokens}} with a rate {{c2::R}} per second, and it also can have up to {{c2::B}} tokens at any given time. If the bucket is full with B tokens, additional tokens are {{c3::ignored}}.&nbsp;When a packet arrives, it can go through if {{c4::there are enough tokens (equal to the size of packet in bits)}}. If not, the packet needs to wait until {{c4::enough tokens are in the bucket}}. Given the max size of B, a burst is limited to {{c5::B bits per second}}.&nbsp;</div>\n",
                        ""
                    ],
                    "guid": "hU[JYn+/)y",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6</h1>\n<h2>Traffic Scheduling: Token Bucket</h2><h3>Token Bucket Shaping</h3><div>Token bucket shaping can limit the burstiness of a flow by:</div><div><ul><li>limiting the {{c1::average rate (e.g., 100 Kbps)}}</li><li>limiting the {{c1::maximum burst size (e.g., the flow can send a burst of 4KB at a rate of its choice)}}</li></ul></div>\n",
                        ""
                    ],
                    "guid": "i3KZ0P}!iV",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Why We Need {{c1::Packet Classification}}?</h2>\n<div>As the Internet becomes increasingly complex, networks require {{c2::quality-of-service}} and {{c2::security}} guarantees for their traffic. Packet forwarding based on the longest prefix matching of destination IP addresses is insufficient. We need to handle packets based on multiple criteria such as {{c3::TCP flags}}, {{c3::source addresses}}, and so on. We refer to this finer packet handling as&nbsp;{{c1::packet classification}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "jjb1=T7YUu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Deficit Round Robin</h2>\n<h3>\n  Deficit Round Robin (DRR)\n</h3><div>Deficit Round Robin (DRR) assigns {{c1::a quantum size,&nbsp;\\(Q_i\\)}}, and {{c1::a deficit counter,&nbsp;\\(D_i\\)}}, for each flow. The quantum size determines {{c2::the share of bandwidth allocated to that flow}}. For each turn of round-robin, the algorithm will serve as many packets in the flow <i>i</i> with {{c3::size less than&nbsp;\\(Q_i + D_i\\)}}. If packets remain in the queue, it will {{c4::store the remaining bandwidth in&nbsp;\\(D_i\\)&nbsp;for the next run}}. However, if all packets in the queue are serviced in that turn, it will {{c5::clear&nbsp;\\(D_i\\)&nbsp;to 0 for the next turn}}.<br></div>\n",
                        ""
                    ],
                    "guid": "l>UQgS!3%D",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Reducing Memory Using Backtracking</h2>\n<div><div>The backtracking approach has each destination prefix D point to {{c1::a source trie that stores the rules whose destination field is exactly D}}. The search algorithm then performs a \"backtracking\" search on the source tries associated with all ancestors of D.</div><div><br></div><div>The algorithm goes through the destination trie and finds {{c2::the longest destination prefix D matching the header}}. Then it {{c3::works its way back up the destination trie and searches the source trie associated with every ancestor prefix of D that points to a nonempty source trie}}.&nbsp;</div></div>",
                        "Since each rule is stored exactly once, the memory requirements are lower than the previous scheme. But, the lookup cost for backtracking is worse than for set-pruning tries."
                    ],
                    "guid": "lb1AP;r{ZA",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Scheduling and Head of Line Blocking</h2>\n<div>In the “{{c1::take-a-ticket}} algorithm”, each output line maintains {{c2::a distributed queue}} for all input lines that want to send packets to it. When an input line intends to send a packet to a specific output line, it {{c3::requests a ticket}}. Then, the input line {{c4::waits for the ticket to be served}}. At that point, {{c5::the input line connects to the output line, the crosspoint is turned on, and the input line sends the packet}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "n`,SA]<M!{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Avoiding Head of Line Blocking</h2>\n<div>With an N-by-N crossbar switch, we could avoid blocking packets sent to the same output link if {{c1::we have the fabric running N times faster than the input links}}.</div><div><br></div><div>A practical implementation of this approach is {{c2::the Knockout scheme}}. It relies on {{c3::breaking up packets into fixed sizes (cell)}}. In practice, we suppose that {{c4::the same output rarely receives N cells, and the expected number is k (smaller than N)}}. Then we can {{c5::have the fabric running k times as fast as an input link instead of N}}.<br></div>",
                        ""
                    ],
                    "guid": "pQ(wM}/)+l",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6: Router Design and Algorithms</h1>\n<h2>Packet Classification: Simple Solutions</h2>\n<div><div>Before looking into algorithmic solutions to the packet classification problem, let's look at the most straightforward approaches that we have:</div><ul><li>{{c1::Linear Search}}:</li><ul><li>Firewall implementations perform a linear search of the rules database and keep track of the best-match rule.</li></ul><li>{{c1::Caching}}:</li><ul><li>Another approach is to cache the results so that future searches can run faster.</li></ul><li>{{c1::Passing Labels}}:</li><ul><li>The Multiprotocol Label Switching (MPLS) and DiffServ use this technology.&nbsp;</li></ul></ul></div>",
                        ""
                    ],
                    "guid": "q@oHgd~aSO",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6</h1>\n<h2>Traffic Scheduling: Leaky Bucket</h2><div><div>If an arriving packet does not cause an overflow when added to the bucket, it is said to be {{c1::conforming}}. Otherwise, it is said to be {{c1::non-conforming}}. Packets classified as {{c1::conforming}} are {{c2::added to the bucket}}, while {{c1::non-conforming}} packets are {{c2::discarded}}.<br></div></div>\n",
                        "Irrespective of the input rate of packets, the output rate is constant, which leads to uniform distribution of packets sent to the network. This algorithm can be implemented as a single server queue.&nbsp;"
                    ],
                    "guid": "qY=6R(]gRJ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6</h1>\n<h2>Traffic Scheduling: Token Bucket</h2><h3>Token Bucket Shaping</h3><div><div>The problem with this technique is that {{c1::we have one queue per flow}}. This is because a flow may have a full token bucket, whereas other flows may have an empty token bucket and, therefore will need to wait.</div><div><br></div><div>We use a modified version of token bucket shaper to {{c2::maintain one queue}}, called {{c3::token bucket policing}}. When a packet arrives will need to have tokens at the bucket already there. If the bucket is empty, {{c4::the packet is dropped}}.</div></div>\n",
                        ""
                    ],
                    "guid": "r->qSCB:x{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 6</h1>\n<h2>Traffic Scheduling: Leaky Bucket</h2><div>The output rate is controlled by identifying traffic descriptor violations and then responding to them in two different ways:<br></div><div><ul><li>Policer:&nbsp;When the traffic rate reaches the maximum configured rate, {{c1::excess traffic is dropped}}, or the packet's setting or \"marking\" is changed. The output rate appears as a saw-toothed wave.</li><li>Shaper:&nbsp;A shaper typically {{c2::retains excess packets in a queue or a buffer}}, and this excess is scheduled for later transmission. The result is that excess traffic {{c3::is delayed instead of dropped}}. Thus, the flow is shaped or smoothed when the data rate is higher than the configured rate.</li></ul></div>\n",
                        "Traffic shaping and policing can work in tandem."
                    ],
                    "guid": "v0lg?4r9p~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson06"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e1ad6c4-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "34f370c918d248a78abe53276e6a0164-oa-1-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-1-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-10-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-10-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-11-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-11-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-12-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-12-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-13-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-13-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-14-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-14-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-15-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-15-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-16-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-16-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-2-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-2-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-3-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-3-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-4-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-4-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-5-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-5-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-6-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-6-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-7-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-7-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-8-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-8-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-9-A.svg",
                "34f370c918d248a78abe53276e6a0164-oa-9-Q.svg",
                "34f370c918d248a78abe53276e6a0164-oa-O.svg",
                "componentsOfAnSDNController.png"
            ],
            "name": "Lesson 07: SDN",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-2",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-2-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-2-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "A7!I=-R9XH",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Control and data plane separation</h3>\n<div><div>The <b>technology pushes</b> that encouraged control and data plane separation were:<br></div><ul><li>Higher link speeds in backbone networks led vendors to {{c1::implement packet forwarding directly in the hardware, thus separating it from the control-plane software}}.</li><li>Internet Service Providers (ISPs) found it hard to meet the increasing demands for {{c2::greater reliability}} and {{c2::new services (such as virtual private networks)}}, and struggled to {{c3::manage the increased size and scope of their networks}}.</li><li>Servers had substantially more memory and processing resources than those deployed one-two years prior. This meant that a single server could {{c4::store all routing states and compute all routing decisions for a large ISP network}}.</li><li>{{c5::Open source routing software}} lowered the barrier to creating prototype implementations of centralized routing controllers.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "A9LF0KGYo{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div><div>There were two types of {{c1::programming models}} in active networking. These {{c1::models}} differ based on {{c2::where the code to execute at the nodes was carried}}.</div><ol><li>{{c3::Capsule model}} – {{c4::carried in-band in data packets}}</li><li>{{c3::Programmable router/switch model}} – {{c4::established by out-of-band mechanisms.}}</li></ol></div>\n",
                        ""
                    ],
                    "guid": "B[0+l,.@0~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-4",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-4-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-4-A.svg\">",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "DEq7E1gpS)",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Controller Architecture</h2><div>The SDN controller, although viewed as a monolithic service by external devices and applications, is implemented by {{c1::distributed servers}} to achieve {{c2::fault tolerance, high availability and efficiency::list 3}}. Despite the issues of synchronization across servers, many modern controllers such as {{c3::OpenDayLight}} and {{c3::ONOS}} have solved it and prefer distributed controllers to provide highly scalable services.<br></div>",
                        ""
                    ],
                    "guid": "DVnL#[R1*1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-16",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\">",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-16-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-16-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "EMMWk)l3Xv",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1><h2>The SDN Architecture</h2><div>Which plane do the SDN components belong to?</div><div><ul><li>Network-control applications: {{c1::Control}} plane<br></li><li>SDN controller: {{c1::Control}} plane<br></li><li>SDN-controlled network elements: {{c1::Data}} plane<br></li></ul></div>",
                        ""
                    ],
                    "guid": "Ee*0ub>7?C",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>\n  {{c1::Active networks}}\n</h3>\n<div>The {{c1::active networks}}&nbsp;phase took place from {{c2::the mid-1990s}} to the {{c2::early 2000s}}.<br></div>\n",
                        ""
                    ],
                    "guid": "G*m>422Cfi",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>Control Plane and Data Plane Separation</h2>\n<div>In the traditional approach, the routing algorithms (control plane) and forwarding function (data plane) are {{c1::closely}} coupled.<br></div>",
                        "The router runs and participates in the routing algorithms."
                    ],
                    "guid": "H;rhpIq<2K",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>Control Plane and Data Plane Separation</h2>\n<div><div>In the SDN approach, there is a remote controller that {{c1::computes and distributes}} the {{c5::forwarding tables}} to be used by every router. This controller is physically separate from the router. It could be located {{c4::in some remote data center}}, managed by {{c4::the ISP or some other third party}}.</div><div><br></div><div>The routers are solely responsible for {{c2::forwarding}}, and the remote controllers are solely responsible for {{c1::computing and distributing}} the {{c5::forwarding tables}}. The controller is implemented in software, and therefore we say the network is {{c3::software-defined}}.</div></div>",
                        "These software implementations are also increasingly open and publicly available, which speeds up innovation in the field."
                    ],
                    "guid": "I;ClL];-6,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>OpenFlow API and network operating systems</h3>\n<div>\n  Use pulls:</div><div><ul><li>OpenFlow came up to meet the need of {{c1::conducting large scale experimentation on network architectures}}.</li><li>OpenFlow was useful in {{c2::data-center networks}} – there was a need to manage network traffic at large scales.</li><li>Companies started investing more in {{c3::programmers to write control programs}}, and less in {{c3::proprietary switches that could not support new features easily}}.</li></ul></div>",
                        ""
                    ],
                    "guid": "IGAX<A0=[w",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-12",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-12-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-12-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "K`z5eO9u9,",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-1",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\">",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-1-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-1-A.svg\">",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\">"
                    ],
                    "guid": "L`O`dIuiBJ",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>OpenFlow API and network operating systems</h3>\n<div><div>Some key effects that OpenFlow had were:</div><ul><li>Generalizing {{c1::network devices and functions}}.</li><li>The vision of a {{c2::network operating system}}.</li><li>Distributed {{c3::state management techniques}}.</li></ul></div>",
                        ""
                    ],
                    "guid": "LkL=5>kjT{",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Controller Architecture</h2><div>The SDN controller is a part of the SDN {{c1::control}} plane and acts as an interface between {{c2::the network elements}} and {{c2::the network-control applications}}.</div>",
                        ""
                    ],
                    "guid": "Lv:q8ne-yk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-7",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-7-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-7-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "M$xy{E>}.z",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-15",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-15-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-15-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "McYXstA(S4",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Control and data plane separation</h3>\n<div><div>Some use pulls for the separation of control and data planes were:</div><ul><li>Selecting between network paths based on the {{c1::current traffic load}}</li><li>Minimizing disruptions during {{c2::planned routing changes}}</li><li>Redirecting/dropping {{c3::suspected attack traffic}}</li><li>Allowing customer networks more control over {{c4::traffic flow}}</li><li>Offering value-added services for {{c5::virtual private network customers}}</li></ul></div>\n",
                        ""
                    ],
                    "guid": "N#l&FPl=dC",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div>Although the {{c1::capsule}} model was most closely related to active networking, both models have some effect on the current state of SDNs. By carrying the {{c2::code}} in {{c2::data packets}}, {{c1::capsules}} brought a new data-plane functionality across networks. They also used {{c3::caching}} to make {{c4::code distribution}} more efficient.</div>\n",
                        ""
                    ],
                    "guid": "Nmtw&_,8?K",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>OpenFlow API and network operating systems</h3>\n<div>One of the downfalls of OpenFlow when it was first created was that it was hard to deploy and scale it easily.</div><div>T/F?</div>",
                        "False<br>Early OpenFlow versions built on technology that the switches already supported. This meant that enabling OpenFlow initially was as simple as performing a firmware upgrade!"
                    ],
                    "guid": "P2B.m>$U38",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-9",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-9-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-9-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "b$z1J#Jt);",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-11",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-11-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-11-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "bH,Mtwt*6Z",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Controller Architecture</h2><div>{{c1::Communication}} Layer: Devices send {{c2::locally observed events}} to the {{c3::SDN controller}} providing the {{c3::controller}} with {{c4::a current view of the network state}}. The communication between {{c3::SDN controller}} and the controlled devices is known as the “{{c5::southbound}}” interface. {{c6::OpenFlow}} is an example of this protocol, which is broadly used by SDN controllers today.<br></div>",
                        "These events can be a new device joining the network, heartbeat indicating the device is up, etc."
                    ],
                    "guid": "bxSVQw9H|s",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-3",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-3-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-3-A.svg\">",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "c<j8Nx/]XX",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div>In the early 1990s, the networking approach was primarily via {{c1::IP}} or {{c1::ATM (Asynchronous Transfer Mode)}}. Active networking became one of the first {{c2::‘clean slate’ approaches to network architecture}}.</div>\n",
                        ""
                    ],
                    "guid": "cBq.=@6tVk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div><div>The use pulls for active networking were:</div><ul><li>Network service provider frustration concerning {{c1::the long timeline to develop and deploy new network services}}.</li><li>Third party interests to add value by {{c2::implementing control}} at a more {{c5::individualistic}} nature.</li><li>Researchers interest in {{c3::having a network that would support large-scale experimentation}}.</li><li>Unified control over {{c4::middleboxes}}. Active networking envisioned unified control that could replace individually managing these boxes.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "clQ>(Xe#P:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div><div>In addition to the push and pull use cases, active networks made three major contributions related to SDN:</div><ul><li>{{c1::Programmable functions}} in the network to lower the barrier to innovation.</li><ul><li>While many early visions for SDN concentrated on increasing programmability of the control-plane, active networks focused on the programmability of the data-plane.</li></ul><li>{{c2::Network virtualization}}, and the ability to demultiplex to software programs based on {{c3::packet headers}}.</li><li>The vision of a unified architecture for {{c4::middlebox orchestration}}</li></ul></div>\n",
                        ""
                    ],
                    "guid": "fOE(Y(2*Z;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>OpenFlow API and network operating systems</h3>\n<div>One of the main differences between the {{c1::Active Networks}} phase and the {{c1::separation of the Control and Data plane}} phase is that the former is focused on {{c2::device-level configurations}} and the latter is focused on {{c2::network-wide visibility and control}}.</div>",
                        ""
                    ],
                    "guid": "g1mTZB)2p=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Architecture</h2>\n<div><div>The main components of an SDN network are:&nbsp;</div><ul><li>{{c1::SDN-controlled network elements}}</li><ul><li>Sometimes called the {{c2::infrastructure}} layer, is responsible for {{c3::the forwarding of traffic in a network based on the rules computed by the SDN control plane}}.</li></ul><li>{{c1::SDN controller}}</li><ul><li>A logically centralized entity that acts as an&nbsp;interface between {{c4::the network elements and the network-control applications}}.</li></ul><li>{{c1::Network-control applications}}</li><ul><li>Programs that manage {{c5::the underlying network}} by {{c6::collecting information about the network elements with the help of SDN controller}}.</li></ul></ul></div>",
                        ""
                    ],
                    "guid": "gK;x(7mG:D",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-5",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-5-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-5-A.svg\">",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "h)wL]sE`BD",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>{{c1::OpenFlow API and network operating systems}}</h3>\n<div><div>The {{c1::OpenFlow API and network operating systems}}&nbsp;phase took place from around {{c2::2007}} to {{c2::2010}}.</div></div>\n",
                        ""
                    ],
                    "guid": "iXl|Ik%1/K",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>Control Plane and Data Plane Separation</h2>\n<div><div>Two important functions of the network layer are:</div><div><ol><li>{{c1::Forwarding}} is a local function for routers, and it usually takes place in {{c2::nanoseconds::timescale}} and is implemented in {{c3::the hardware itself}}. {{c1::Forwarding}} is a function of the {{c4::data}} plane. A router looks at the header of an incoming packet and consults {{c5::the forwarding table}}, to determine the outgoing link to send the packet to.&nbsp;</li><li>{{c1::Routing}} involves {{c6::determining the path from the sender to the receiver across the network}}. Routers rely on routing algorithms for this purpose.&nbsp;It is an end-to-end process for networks. It usually takes place in {{c7::seconds::timescale}} and is implemented in {{c8::the software}}. {{c1::Routing}} is a function of the {{c9::control}} plane.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "j0unfBOcr-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Controller Architecture</h2><div><div>An SDN controller can be broadly split into three layers:&nbsp;</div><ul><li>{{c1::Communication}} layer:&nbsp;communicating between {{c2::the controller}} and the {{c2::network elements}}</li><li>{{c1::Network-wide state-management}} layer:&nbsp;{{c3::stores information of network-state}}</li><li>{{c1::Interface to the network-control application}} layer: {{c4::communicating between controller and applications}}</li></ul></div>",
                        ""
                    ],
                    "guid": "jrwTk3FP`w",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>OpenFlow API and network operating systems</h3>\n<div>The Active Networks phase consisted mainly of creating a {{c1::programming interface that exposed resources/network nodes}} and supported {{c2::customization of functionalities}} for {{c3::subsets of packets passing through the network}}.<br></div>",
                        ""
                    ],
                    "guid": "k!>T3u+;zh",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1><br><h2>The SDN Controller Architecture</h2><div>{{c1::Network-wide state-management}} layer: This layer is about {{c2::the network-state}} that is maintained by the controller. The {{c2::network-state}} includes any information about {{c3::the state of the hosts, links, switches and other controlled elements in the network::list 3}}. It also includes copies of {{c4::the flow tables}} of {{c5::the switches}}. {{c2::Network-state information}} is needed by {{c6::the SDN control plane}} to configure {{c4::the flow tables}}.</div>",
                        ""
                    ],
                    "guid": "kD;;X9p`Ez",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Architecture</h2>\n<div><div>The four defining features in an SDN architecture are:</div><div><ol><li>{{c1::Flow-based forwarding}}:&nbsp;The rules for forwarding packets in the SDN-controlled switches can be computed based on {{c2::any number of header field values in various layers such as the transport-layer, network-layer and link-layer}}. OpenFlow allows up to {{c3::11}} header field values to be considered.&nbsp;</li><li>{{c1::Separation of data plane and control plane}}:&nbsp;The SDN-controlled switches execute {{c4::the rules in the flow tables}}. Those rules are computed, installed, and managed by software that runs on {{c5::separate servers::locality}}.&nbsp;</li><li>{{c1::Network control functions}}:&nbsp;The SDN control plane consists of two components: {{c6::the controller}} and {{c6::the network applications}}. The controller {{c7::maintains up-to-date network state information about the network devices and elements}} and provides it to {{c8::the network-control applications}}. This information, in turn, is used by the applications to {{c9::monitor and control the network devices}}.</li><li>{{c1::A programmable network}}:&nbsp;The network-control applications act as {{c10::the “brain” of SDN control plane by managing the network}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "l}^eG^[~,7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Architecture</h2>\n<div>In an SDN, the controller is responsible for the {{c1::routing}} of the traffic, and the SDN-controlled network elements such as the switches are responsible for the {{c1::forwarding}} of the traffic.<br></div>",
                        ""
                    ],
                    "guid": "m^oLk[b|hS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div><div>The pushes that encouraged active networking were:</div><ul><li>Reduction in {{c1::computation cost}}: Enabled us to put more processing into the network.</li><li>Advancement in {{c1::programming languages}}: For languages like Java, the options of platform portability, code execution safety, and VM (virtual machine) technology to protect the active node in case of misbehaving programs.</li><li>Advances in rapid code {{c1::compilation}} and {{c1::formal}} methods.</li><li>Funding from agencies such as {{c1::DARPA (U.S. Defense Advanced Research Projects Agency)}} for a collection: promoted interoperability among projects.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "nLPlj7$%LT",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div>{{c1::Programmable routers}} made {{c2::decision making}} a job for {{c3::the network operator}}.<br></div>\n",
                        ""
                    ],
                    "guid": "n_Za#6fP}M",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Active networks</h3>\n<div>Standardization of new protocols required the {{c1::IETF (Internet Engineering Task Force)::group}}, which was a slow and frustrating process.<br></div>\n",
                        ""
                    ],
                    "guid": "oWcqCcUN.S",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>OpenFlow API and network operating systems</h3>\n<div>The basic working of an OpenFlow switch is as follows:</div><div><ul><li>Each switch contains {{c1::a table of packet-handling rules}}.</li><li>Each rule has {{c2::a pattern, list of actions, set of counters and a priority::list 4 components}}.</li><li>When an OpenFlow switch receives a packet, it {{c3::determines the highest priority matching rule, performs the action associated with it and increments the counter::list 3}}.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "ptlrk<z4k~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>OpenFlow API and network operating systems</h3>\n<h4>Technology push:</h4>\n<div>OpenFlow was adopted in the industry, unlike its predecessors. This could be due to:</div><ul><li>Before OpenFlow, switch chipset vendors had already started to {{c1::allow programmers to control some forwarding behaviors}}.</li><li>This allowed more companies to {{c2::build switches without having to design and fabricate their own data plane}}.</li><li>Early OpenFlow versions built on {{c3::technology that the switches already supported}}. This meant that enabling OpenFlow initially was as simple as {{c4::performing a firmware upgrade}}!</li></ul>",
                        ""
                    ],
                    "guid": "puI}?Yj-k]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>Why Separate the Data Plane from the Control Plane?</h2>\n<div><div>This separation leads to opportunities in different areas:</div><div><ol><li>{{c1::Data centers}}.&nbsp;Consider large data centers with thousands of servers and VMs.</li><li>{{c1::Routing}}. With SDN, it is easier to update the router's state, and SDN can provide more control over path selection.&nbsp;</li><li>{{c1::Enterprise networks}}.&nbsp;SDN can improve the security applications for enterprise networks. For example, using SDN it is easier to protect a network from volumetric attacks such as DDoS, if we drop the attack traffic at strategic locations of the network.&nbsp;</li><li>{{c1::Research networks}}.&nbsp;SDN allows research networks to coexist with production networks.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "q7NxT[*q7u",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Control and data plane separation</h3>\n<div><div>This phase was different from active networking in several ways:</div><ul><li>It focused on spurring innovation by and for {{c1::network administrators}} rather than {{c1::end users and researchers}}.</li><li>It emphasized programmability in {{c2::the control domain}} rather than {{c2::the data domain}}.</li><li>It worked towards {{c3::network-wide}} {{c4::visibility and control}} rather than {{c3::device-level}} {{c4::configurations}}.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "qC>=LbBy;5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>What led us to SDN?</h2><div><div>Software Defined Networking (SDN) arose as part of the process to make computer networks more {{c1::programmable}}. Computer networks are very complex and especially difficult to manage for two main reasons:</div><ul><li>{{c2::Diversity}} of equipment on the network</li><li>{{c2::Proprietary}} technologies for the equipment</li></ul></div>\n",
                        ""
                    ],
                    "guid": "qG_L,c+`|w",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-14",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-14-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-14-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "qk2PhK0>~P",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>The SDN Controller Architecture</h2><div>The {{c1::interface to the network-control application}} layer:&nbsp;This layer is also known as the controller’s “{{c2::northbound}}” interface using which the SDN controller interacts with {{c1::network-control applications}}. They can read/write {{c3::network state}} and {{c3::flow tables}} in controller’s {{c4::state-management layer}}. The SDN controller can notify applications of {{c5::changes in the network state}}. A {{c6::REST interface}} is an example of a {{c2::northbound API}}.&nbsp;</div>",
                        ""
                    ],
                    "guid": "rOzPi;<d;G",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-13",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-13-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-13-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "s*GT@xSW</",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Control and data plane separation</h3>\n<div><div>The technology pushes inspired two main innovations:</div><ul><li>{{c1::Open interface}} between control and data planes</li><li>{{c2::Logically centralized}} control of the network</li></ul></div>\n",
                        ""
                    ],
                    "guid": "sLicgwK-iR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>{{c1::Control and data plane separation}}</h3>\n<div><div>The {{c1::Control and data plane separation}}<i>&nbsp;</i>phase lasted from around {{c2::2001}} to {{c2::2007}}.</div></div>\n",
                        ""
                    ],
                    "guid": "u##2T2]R5<",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-6",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-6-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-6-A.svg\">",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "uY}w9(%V8C",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1><h2>A Brief History of SDN: The Milestones</h2><h3>Active networks</h3><div>Active networks aimed at {{c1::opening up network control}}. They envisioned {{c2::a programming interface (a network API)}} that exposed {{c3:: resources/network nodes}} and supported {{c4::customization of functionalities for subsets of packets passing through the network nodes}}. This was the opposite of the popular belief in {{c5::the internet community - the simplicity of the network core was important to the internet success}}!<br></div>",
                        ""
                    ],
                    "guid": "v*(F4tZE%a",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-8",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-8-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-8-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "w,*0`ehfyJ",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>What led us to SDN?</h2><div>SDN employs a simple idea - {{c1::separation of tasks}}. Like how code becomes {{c2::more modular and easy to manage}} when we divided into smaller functions with focused tasks, SDN divides the network into two planes - {{c3::control plane}} and {{c3::data plane}}.<br></div>\n",
                        ""
                    ],
                    "guid": "wh4(M{89,<",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2><div><div>The history of SDN can be divided into three phases:</div><div><ol><li>{{c1::Active networks}}</li><li>{{c1::Control and data plane separation}}</li><li>{{c1::OpenFlow API and network operating systems}}</li></ol></div></div>\n",
                        ""
                    ],
                    "guid": "y;^#12*bt!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1>\n<h2>A Brief History of SDN: The Milestones</h2>\n<h3>Control and data plane separation</h3>\n<div><div>The attempt to separate the control and data planes resulted in a couple of concepts which were used in further SDN design:</div><ul><li>{{c1::Logically centralized control using an open interface to the data plane}}.</li><li>{{c2::Distributed state management}}.</li></ul></div>\n",
                        ""
                    ],
                    "guid": "yKfiuOi:^H",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "34f370c918d248a78abe53276e6a0164-oa-10",
                        "",
                        "<img src=\"componentsOfAnSDNController.png\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-10-Q.svg\" />",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-10-A.svg\" />",
                        "<img src=\"34f370c918d248a78abe53276e6a0164-oa-O.svg\" />"
                    ],
                    "guid": "ycpMhoCOfb",
                    "note_model_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 7: SDN</h1><br><h2>Why Separate the Data Plane from the Control Plane?</h2><br><div><div>The reasons we separate the two are:</div><ol><li>Independent {{c1::evolution and development}}</li><ol><li>In the traditional approach, routers are responsible for both routing and forwarding functionalities. This meant that a change to either of the functions would require {{c2::an upgrade of hardware}}. In this new approach, routers only focus on forwarding.</li></ol><li>Control from {{c1::high-level software program}}</li></ol></div>",
                        ""
                    ],
                    "guid": "z*!~/WIBr(",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson07"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e1cda6e-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "sdnPlanesLayers.png"
            ],
            "name": "Lesson 08: SDN",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div><div>Traditionally viewed, computer networks have three planes of functionality, which are all abstract logical concepts:</div><div><ul><li>{{c1::Data}} plane: These are functions and processes that forward data in the form of packets or frames.</li><li>{{c1::Control}} plane: These refer to functions and processes that determine which path to use by using protocols to populate forwarding tables of data plane elements.</li><li>{{c1::Management}} plane: These are services that are used to monitor and configure the control functionality, e.g. SNMP-based tools.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "A$opokgd,1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Southbound Interfaces</h2><div>Which type of message would be sent by an OpenFlow device to the network OS in when it receives new routing information?<br></div>",
                        "An event-based message"
                    ],
                    "guid": "Ao=|.vV}Mc",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<h3>Centralized controllers</h3>\n<div>A single entity that manages all forwarding devices in the network, is {{c1::a single point of failure}} and may have {{c2::scaling issues}}.<br></div>",
                        "Some enterprise class networks and data centers use such architectures, such as Maestro, Beacon, NOX-MT."
                    ],
                    "guid": "B(yI1FOX,H",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Infrastructure Layer</h2><div>OpenFlow is based on a {{c1::pipeline}} of flow tables. Other SDN-enabled forwarding device specifications include {{c2::Protocol-Oblivious Forwarding (POF)}} and {{c2::Negotiable Datapath Models (NDMs)}}.</div>",
                        ""
                    ],
                    "guid": "B_K^&t)$4?",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane: The Motivation</h2>\n<div>P4 ({{c1::Programming Protocol-independent Packet Processors}}) is a high-level programming language to {{c2::configure switches}} which works in conjunction with {{c3::SDN control protocols}}. Switch capabilities have grown over the years to include multiple stages of {{c4::the rule tables}} with increasing number of {{c5::header fields}} to allow better exposure of a switch’s functionalities to the controller.&nbsp;</div>",
                        ""
                    ],
                    "guid": "CD>}),{!,.",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div><div>The <b>southbound</b> interfaces separate the {{c1::data}} plane and {{c1::control}} plane</div></div>",
                        ""
                    ],
                    "guid": "CN?h<[%4|D",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<h3>Distributed controllers</h3>\n<div><div>A distributed {{c1::network operating system}} (controller) can be scaled to meet the requirements of {{c2::potentially any environment - small or large networks}}. Distribution can occur in two ways: it can be {{c3::a centralized cluster of nodes}} or {{c3::physically distributed set of elements}}.</div></div>",
                        ""
                    ],
                    "guid": "C~Zf[L5;]:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>Network programming languages: Network programmability can be achieved using {{c1::low-level}} or {{c1::high-level}} programming languages. Using {{c1::low-level}} languages, it is difficult to write {{c2::modular reusable code}}, and it generally leads to {{c3::more error-prone development}}. {{c1::High level}} programming languages in SDNs provide abstractions, make development more modular, code more reusable in control plane, do away with {{c4::device specific and low-level configurations}}, and generally allow faster development.</div>",
                        "Some examples of network programming languages in SDNs are Pyretic, Frenetic, Merlin, Nettle, Procera, FML, etc."
                    ],
                    "guid": "DI<`]</%/-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>An example Controller: ONOS</h2>\n<div>The distributed architecture of ONOS offers {{c1::scale-out performance}} and {{c1::fault tolerance}}. Each ONOS instance serves as {{c2::the master OpenFlow controller}} for {{c3::a group of switches}}. The propagation of state changes between a switch and the network view is handled solely by {{c4::the master instance of that switch}}.</div>",
                        ""
                    ],
                    "guid": "DS#6I3`6-a",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Application Example: A Software Defined Internet Exchange</h2>\n<div>In the SDX architecture, each AS has the illusion of its own {{c1::virtual SDN switch}} that {{c2::connects its border router to every other participant AS}}. Each AS can define forwarding policies as if {{c3::it is the only participant at the SDX, without influencing how other participants forward packets on their own virtual switches}}. Each AS can have its own {{c4::SDN applications for dropping, modifying, or forwarding their traffic}}.</div>",
                        ""
                    ],
                    "guid": "DxN`KbzZyk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<div>Which architecture provides the best <b>throughput</b>?<br></div>",
                        "A distributed controller with a centralized cluster of nodes."
                    ],
                    "guid": "E)q!$#hHE2",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Southbound Interfaces</h2><div>Which type of message sent by an OpenFlow device to the network OS allows for quality of service (QoS) policies to be implemented?<br></div>",
                        "Flow statistics"
                    ],
                    "guid": "FRFO@/{N``",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications</h2>\n<div><div>The SDX architectures provides which of the following benefits?</div></div>",
                        "<ol><li>It provides an AS more flexibility for managing traffic.</li><li>It scales easily with more participants.&nbsp;</li><li>It provides faster peering compared to a conventional IXP.</li></ol>",
                        "<ol><li><span style=\"color: rgb(0, 0, 255);\">It provides an AS more flexibility for managing traffic.</span></li><li><strike>It scales easily with more participants.</strike></li><li><strike>It provides faster peering compared to a conventional IXP.</strike></li></ol>"
                    ],
                    "guid": "G.ge,NSc@m",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div>The transition to IPv6 would be faster with a software defined networking paradigm compared to a conventional networking paradigm.<br></div><div>T/F?</div>",
                        "True.<br>In tightly coupled traditional IP networks, new protocol update takes as long as 10 years."
                    ],
                    "guid": "G7H1^2RAMH",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div><div>As <b>IP networks</b> grew in adoption worldwide, there were a few challenges that became more and more pronounced, such as:</div><ul><li>Handling the ever growing complexity and {{c1::dynamic nature of networks}}: The implementation of network policies required changes right down to {{c2::each individual network device}}, which were often carried out by {{c3::vendor-specific commands}} and required manual configurations.</li><li>{{c1::Tightly coupled}} architecture</li></ul></div>",
                        ""
                    ],
                    "guid": "H#wgL$BfYi",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>An example Controller: ONOS</h2>\n<div>How does ONOS handle faults (ONOS instance failure)?<br></div>",
                        "Other instances elect a new master for each of the switches that were previously controlled by the failed instance."
                    ],
                    "guid": "HNdVmT730>",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Southbound Interfaces</h2><div>From a legacy standpoint, development of a new switch typically takes up to {{c1::two years}} for commercialization. API proposals like OpenFlow promote {{c2::interoperability}} and {{c2::deployment of vendor-agnostic devices}}.<br></div>",
                        ""
                    ],
                    "guid": "Ht3QZXPU4A",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Measurement and Monitoring</h3>\n<div>The first class of applications in this domain aims to {{c1::add features to other networking services}}. A second class of these applications aim to {{c2::improve the existing features of SDNs using OpenFlow}}.<br></div>",
                        ""
                    ],
                    "guid": "IMkQd<8kKd",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane: The Motivation</h2>\n<div><div>The following are the&nbsp;primary goals of P4:</div><div><ul><li>{{c1::Reconfigurability}}: The way parsing and processing of packets takes place in the switches should be {{c2::modifiable by the controller}}.</li><li>{{c1::Protocol independence}}: The controller defines {{c3::a packet parser}} and {{c3::a set of tables}} mapping matches and their actions. The packet parser {{c4::extracts the header fields}} which are then passed on to {{c5::the match+action tables}} to be processed.&nbsp;</li><li>{{c1::Target independence}}: The packet processing programs should be programmed independent of the underlying target devices. These generalized programs written in P4 should be {{c6::converted into target-dependent programs by a compiler}} which are then used to configure the switch.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "IYdmL~@u*3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<h3>Distributed controllers</h3>\n<div><div>Properties of distributed controllers:</div><ul><li>{{c1::Weak consistency semantics}}</li><li>{{c1::Fault tolerance}}</li></ul></div>",
                        ""
                    ],
                    "guid": "IeO%tzkH8E",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Infrastructure Layer</h2><div><div>In an OpenFlow device, when a packet arrives, the lookup process starts in {{c1::the first table}} and ends either with {{c1::a match in one of the tables of the pipeline}} or {{c1::with a miss (when no rule is found for that packet)}}. Some possible actions for the packet include:</div><ol><li>{{c2::Forward the packet to outgoing port}}</li><li>{{c2::Encapsulate the packet and forward it to controller}}</li><li>{{c2::Drop the packet}}</li><li>{{c3::Send the packet to normal processing pipeline}}</li><li>{{c3::Send the packet to next flow table}}</li></ol></div>",
                        ""
                    ],
                    "guid": "In,@28TU:G",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Data Center Networking</h3>\n<div>SDN aims to offer services such as {{c1::live migration of networks}},&nbsp; {{c1::troubleshooting}}, {{c1::real-time monitoring of networks}} among various other features. SDN applications can also help {{c2::detect anomalous behavior}} in data centers by defining different models and building application signatures from observing the information collected from network devices in the data center.<br></div>",
                        ""
                    ],
                    "guid": "Iy;irXu*n:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Application Example: A Software Defined Internet Exchange</h2>\n<div><div>Researchers have proposed an SDN based architecture for IXPs, called {{c1::SDX}}.<br></div></div>",
                        ""
                    ],
                    "guid": "J%.b4H3Ku;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Security and Dependability</h3>\n<div>DDoS detection, an SDN application identifies and mitigates DDoS flooding attacks by leveraging {{c1::the timely information collected from the network}}. Furthermore, SDN has also been used to detect any {{c2::anomalies in the traffic}}, to {{c3::randomly mutate}} the IP addresses of hosts to fake dynamic IPs to the attackers (OF-RHM) , and monitoring the {{c4::cloud infrastructures}} (CloudWatcher).&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "JbcFbg%DF#",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane: The Motivation</h2>\n<div>P4 is used to {{c1::configure the switch programmatically}} and acts as a general interface between the switches and the controller with its main aim of allowing the {{c2::controller}} to {{c3::define how the switches operate}}.</div>",
                        ""
                    ],
                    "guid": "K/-$LUFgKi",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div>The {{c1::management}} plane {{c2::defines}} a network policy.<br></div>",
                        ""
                    ],
                    "guid": "KY+BlB6LKR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Wide Area Traffic Delivery</h2>\n<h3>Application specific peering</h3>\n<div>ISPs prefer {{c1::dedicated ASes}} to handle the high volume of traffic flowing from high bandwidth applications such as YouTube, Netflix.<br></div>",
                        ""
                    ],
                    "guid": "L?~|Rfy1,c",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div><div>The {{c1::control}} plane {{c2::enforces}} a network policy.</div></div>",
                        ""
                    ],
                    "guid": "Lb|>.&K5!<",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div>An OpenFlow switch can be instructed by the controller to behave like a {{c1::firewall, switch, router::list 3}}, or even perform other roles like {{c2::load balancer, traffic shaper::list 2}}, etc.<br></div>",
                        ""
                    ],
                    "guid": "M<lsLd=HY=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Advantages</h2><div><div>In software defined networking, which network application would take precedence when managing incoming traffic?</div><div>Routing Policies or Load Balancing</div></div>",
                        "Load Balancing.<br>Load balancing and routing applications can be combined sequentially."
                    ],
                    "guid": "No=H5B=:1]",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>{{c1::Network virtualization}}: The network infrastructure needs to provide support for {{c2::arbitrary network topologies and addressing schemes}}. Existing virtualization constructs such as {{c3::VLAN, NAT and MLPS::list 3}} are able to provide full network virtualization, however these technologies are {{c4::connected by a box-by-box basis configuration and there is no unifying abstraction}}. New advancements in SDN network virtualization such as VxLAN, NVGRE, FlowVisor, FlowN, NVP are promising.</div>",
                        "Multiprotocol Label Switching, or MPLS, is&nbsp;a networking technology that routes traffic using the shortest path based on “labels,” rather than network addresses, to handle forwarding over private wide area networks."
                    ],
                    "guid": "O6~4[W{{e%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane: P4's Forwarding Model</h2>\n<div>P4's programming contrasts with OpenFlow, which supports only {{c1::fixed parsers}} based on {{c1::predetermined header fields}} and only a {{c2::series}} combination of match+actions tables.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "Otyn4^+(1.",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div><div>The P4 language is being developed as a replacement for OpenFlow.</div></div><div>T/F?</div>",
                        "<div>False</div><div>According to the paper, P4 is a strawman proposal for how OpenFlow should evolve in the future.&nbsp;</div>"
                    ],
                    "guid": "Q.*~Bp*3~$",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div><div>The northbound interfaces separate the {{c1::management}} plane and {{c1::control}} plane.</div></div>",
                        ""
                    ],
                    "guid": "Qt[.OST7YZ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Advantages</h2><div><div>In conventional networks, to add a new networking feature, one has to go through the process of {{c1::modifying all control plane devices}} - e.g. installing new firmware / hardware upgrades.&nbsp; To avoid this, traditionally, new specialized equipment was introduced (known as {{c2::middleboxes}}) through which concepts and features such as {{c3::load balancers, intrusion detection systems, firewalls::list 3}}, etc. were introduced. Since these {{c2::middleboxes}} are required to be {{c4::carefully placed in the network topology}}, it is much harder to later change or reconfigure them.</div><br></div>",
                        ""
                    ],
                    "guid": "RiWE!@R)F@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Infrastructure Layer</h2><div>The SDN infrastructure composes of networking equipment (routers, switches and appliance hardware) performing {{c1::simple forwarding tasks}}. The physical devices do not have {{c2::embedded intelligence or control}}, as the network intelligence is now delegated to {{c3::a logically centralized control system - the Network Operating System (NOS)::system}}.</div>",
                        ""
                    ],
                    "guid": "b&0,A3P`Di",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div><div>What are the two operations in the P4 forwarding model?&nbsp;</div></div>",
                        "Configure, Populate"
                    ],
                    "guid": "bKf&Gk[,7h",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<div>Which architecture has the strongest <b>consistency</b> semantics?<br></div>",
                        "A centralized controller."
                    ],
                    "guid": "bT>8~YHB%C",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1><br><h2>SDN Application Example: A Software Defined Internet Exchange</h2><br><div>The SDX is responsible to {{c1::combine the policies}} from {{c2::multiple participants}} into {{c1::a single policy}} for {{c2::the physical switch}}.<br></div>",
                        ""
                    ],
                    "guid": "c.5xP1c,(c",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>An example Controller: ONOS</h2>\n<div>To make {{c1::forwarding}} and {{c1::policy}} decisions, the applications consume information from {{c2::the view}} and then {{c2::update these decisions back to the view}}.<br></div>",
                        ""
                    ],
                    "guid": "c/b{JNAHqS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<h3>Core controller functions</h3>\n<div>Security mechanisms are critical components to provide {{c1::basic isolation}} and security enforcements between {{c2::services}} and {{c2::applications}}.<br></div>",
                        ""
                    ],
                    "guid": "cEJG>f_<kG",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>An example Controller: ONOS</h2>\n<div>To achieve fault tolerance, ONOS redistributes the work of a failed instance to {{c1::other remaining instances}}. Each switch in the network connects to {{c2::multiple ONOS instances with only one instance acting as its master}}. Upon failure of an ONOS instance, {{c3::an election is held on a consensus basis to choose a master for each of the switches that were controlled by the failed instance}}.</div>",
                        ""
                    ],
                    "guid": "cM93Xpts[o",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>Infrastructure: In SDN, the physical networking equipment are merely {{c1::forwarding elements that do a simple forwarding task}}, and any logic to operate them is directed from the {{c2::centralized control system}}. Popular examples of such infrastructure equipment include OpenFlow (software) switches such as {{c3::SwitchLight, Open vSwitch, Pica8::list 3}}, etc.<br></div>",
                        ""
                    ],
                    "guid": "cl^].Byqx;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane: P4's Forwarding Model</h2>\n<div><div>The following are the two main operations of the P4 forwarding model:&nbsp;</div><div><ol><li>{{c1::Configure}}: These sets of operations are used to {{c2::program the parser}}. They specify the {{c3::header fields}} to be processed in each {{c4::match+action}} stage and also define the order of these stages.</li><li>{{c1::Populate}}: The entries in the {{c4::match+action}} tables specified during configuration may be altered using the populate operations. It allows {{c5::addition and deletion}} of the entries in the tables.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "dh.k|&}k]Q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Data Center Networking</h3>\n<div><ul><li>LIME is an SDN application which aims to {{c1::provide live migration}}.</li><li>FlowDiff is an application which {{c2::detects abnormalities}}.</li></ul></div>",
                        ""
                    ],
                    "guid": "dl[j9=i6Z3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div><div>The forwarding model used by P4 is a pipeline.</div></div><div>T/F?</div>",
                        "<div>True.</div><div><i>The analysis of dependencies between the nodes determine where a table may be placed in the pipeline.</i></div>"
                    ],
                    "guid": "e&(#v?4`Gk",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Traffic Engineering</h3>\n<div>{{c1::Load balancing}} applications such as Plug-n-Serve and Aster*x achieve scalability by creating rules based on {{c2::wildcard patterns}} which enables handling of large numbers of requests from a particular group.<br></div>",
                        ""
                    ],
                    "guid": "e`P&+@+$/C",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications</h2>\n<div><div>In the SDX architecture, each participant AS must use the same network applications for traffic engineering.</div></div><div>T/F?</div>",
                        "False"
                    ],
                    "guid": "f$+|y[4G2T",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Traffic Engineering</h3>\n<div>{{c1::ElasticTree}} is one such application which identifies and shut downs specific links and devices depending on the traffic load.<br></div>",
                        ""
                    ],
                    "guid": "fR[?DC7wO!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>There is a wide variety of {{c1::network applications}} such as:<br></div><div><ul><li>{{c2::routing}}</li><li>{{c2::load balancing}}</li><li>{{c2::security enforcement}}</li><li>{{c3::end-to-end QoS enforcement}}</li><li>{{c3::power consumption reduction}}</li><li>{{c4::network virtualization}}</li><li>{{c4::mobility management}}</li></ul></div>",
                        "Some well known solutions are Hedera, Aster*x, OSP, OpenQoS, Pronto, Plug-N-Serve, SIMPLE, FAMS, FlowSense, OpenTCP, NetGraph, FortNOX, FlowNAC, VAVE, etc."
                    ],
                    "guid": "f|dHlRQgW3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div><div>The P4 language allows programmers to use multiple header fields to parse, match, and perform actions on packets.</div></div><div>T/F?</div>",
                        "<div>True</div>"
                    ],
                    "guid": "f~,h&Ko77b",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Southbound Interfaces</h2><div>There are other {{c3::API proposals}} besides OpenFlow:</div><div><ul><li>{{c1::ForCES}}, provides a more flexible approach to traditional network management without changing the current architecture of the network, i.e, it does not need a logically centralized controller. The control and data planes are separated but potentially can also be kept in the same network element.</li><li>{{c2::OVSDB}} acts complementary to OpenFlow or Open vSwitch. It allows the control elements to create multiple vSwitch instances, set QoS policies on interfaces, attach interfaces to the switches, configure tunnel interfaces on the OpenFlow data paths, manage queues and collect statistics.</li></ul></div>",
                        ""
                    ],
                    "guid": "g)<#=fDMs@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications</h2>\n<div><div>Most SDN applications can be grouped into one of the five categories:</div><div><ul><li>traffic engineering</li><li>mobility and wireless</li><li>measurement and monitoring</li><li>security and dependability</li><li>data center networking</li></ul></div><div>Classify each application into an appropriate category.&nbsp;</div><div><ul><li>Load Balancing: {{c1::Traffic engineering}}</li><li>Interference management: {{c2::Mobility and wireless}}</li><li>Traffic matrix estimation tool: {{c3::Measurement and monitoring}}</li><li>Optimize network utilization: {{c4::Data center networking}}</li><li>Minimizing power consumption: {{c5::Traffic engineering}}</li><li>DoS attack mitigation: {{c6::Security and dependability}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "gEIi|@A^.i",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>OpenFlow is used in the {{c1::data}} plane, and it is an example of a {{c1::southbound}} interface.<br></div>",
                        ""
                    ],
                    "guid": "g[aY@!bp,N",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Advantages</h2><div>In conventional networking, {{c1::middleboxes}} would implement an intrusion detection system (IDS).<br></div>",
                        ""
                    ],
                    "guid": "g[pMMQ_..g",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<h3>Core controller functions</h3>\n<div>All controllers should provide base funcionality such as:</div><div><ul><li>{{c1::topology}}</li><li>{{c1::statistics}}</li><li>{{c1::notifications}}</li><li>{{c2::device management}}</li><li>{{c2::shortest path forwarding}}</li><li>{{c2::security mechanisms}}</li></ul></div>",
                        ""
                    ],
                    "guid": "h)XUAtI%bu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div><div>The P4 programming language can also be used with a conventional network paradigm.&nbsp;</div><div>T/F?</div></div>",
                        "False.<br>In conventional networks, the switches are not reprogrammable."
                    ],
                    "guid": "hUz{7i%rSf",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div>The P4 language is used to program the {{c1::data}} plane.<br></div>",
                        ""
                    ],
                    "guid": "hxfyTAn=ME",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1><br><h2>The SDN Landscape</h2><div>Network operating systems: The promise of SDN is to ease network management and solve networking problems by using a {{c1::logically centralized}} controller by way of a network operating system (NOS). The value of a NOS is in providing {{c2::abstractions, essential services, and common APIs to developers::list 3}}.<br></div>",
                        "Some popular NOSs are OpenDayLight, OpenContrail, Onix, Beacon and HP VAN SDN."
                    ],
                    "guid": "h},Hs;QrF9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications</h2>\n<div><div>In the SDX architecture, two autonomous systems can choose to only exchange video traffic.</div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "iE&UG#cM+~",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Wide Area Traffic Delivery</h2>\n<h3>Wide-area server load balancing</h3>\n<div>A more efficient approach to load balancing can be achieved with the help of SDX, as it supports {{c1::modification of the packet headers}}. A single anycast IP can be assigned to a service, and the destination IP addresses of packets can be {{c1::modified at the exchange point}} to {{c2::the desired backend server based on the request load}}.<br></div>",
                        ""
                    ],
                    "guid": "iq?&aKj}a]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane: P4's Forwarding Model</h2>\n<div>The switches using P4 use a {{c1::programmable parser}} and a {{c1::set of match+action tables}} to forward packets. The tables can be accessed in multiple stages in a {{c2::series}} or {{c2::parallel}} manner.<br></div>",
                        ""
                    ],
                    "guid": "it45v9%PaC",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<div>A network controller prioritizes the rules generated by various services.<br></div><div>T/F?</div>",
                        "True<br>High priority services’ rules should always take precedence over rules created by applications with low priority."
                    ],
                    "guid": "jbAx8h1W*a",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>{{c1::Language-based virtualization}}: An important characteristic of {{c1::virtualization}} is the ability to {{c2::express modularity}} and allowing {{c2::different levels of abstraction}}.<br></div>",
                        "Some popular examples of programming languages that support virtualization are Pyretic, libNetVirt, AutoSlice, RadioVisor, OpenVirteX, etc."
                    ],
                    "guid": "jsD!9_3&DY",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>Northbound interfaces: Northbound interfaces are supposed to be a mostly {{c1::software ecosystem}}. Another key requirement is the abstraction that guarantees {{c2::programming language}} and {{c2::controller}} independence.</div>",
                        "A standard for Northbound interface is still an open problem, as are its use cases. Some popular examples are Floodlight, Trema, NOX, Onix and SFNet."
                    ],
                    "guid": "kIRQW2Lp#_",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Southbound Interfaces</h2><div><div>There are three information sources provided by OpenFlow protocol:</div><ol><li>{{c1::Event-based messages}} that are sent by forwarding devices to controller when there is a link or port change</li><li>{{c1::Flow statistics}} are generated by forwarding devices and collected by controller</li><li>{{c1::Packet messages}} are sent by forwarding devices to controller when they do not know what to do with a new incoming flow</li></ol></div>",
                        ""
                    ],
                    "guid": "m90Dr*M;3=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div><div>The match+action tables in P4 are more flexible than those in current version of OpenFlow.&nbsp;</div><div>T/F?</div></div>",
                        "<div>True.</div>"
                    ],
                    "guid": "mEN{UR+.4)",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div><div>The {{c1::data}} plane {{c2::executes}} a network policy.</div></div>",
                        ""
                    ],
                    "guid": "md7T$*Kltc",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Application Example: A Software Defined Internet Exchange</h2>\n<div><div>Border Gateway Protocol&nbsp;(BGP) has limitations which makes Internet routing unreliable and difficult to manage. The two main limitations are:&nbsp;</div><ul><li>Routing only on {{c1::destination IP prefix}}</li><li>Networks have little control over {{c1::end-to-end paths - Networks can only select paths advertised by direct neighbors}}</li></ul></div>",
                        ""
                    ],
                    "guid": "msvlfP6D?6",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Application Example: A Software Defined Internet Exchange</h2>\n<div>To write policies SDX uses the {{c1::Pyretic}} language to {{c2::match header fields of the packets}} and to {{c2::express actions on the packets}}.</div>",
                        ""
                    ],
                    "guid": "mvd&1^->YF",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Mobility and Wireless</h3>\n<div>{{c1::OpenRadio}}, which is considered as the OpenFlow for wireless, enables decoupling of the wireless protocols from the underlying hardware by providing an abstraction layer.<br></div>",
                        ""
                    ],
                    "guid": "n$D/}4-Sy.",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Advantages</h2><div><div>Load balancing is only possible with software defined networking.<br></div><div>T/F?</div></div>",
                        "False.<br>Traditionally, <b>middleboxes</b> implemented features such as load balancers, intrusion detection systems, firewalls."
                    ],
                    "guid": "nQMGeTQ9x-",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Mobility and Wireless</h3>\n<div>{{c1::Light virtual access points (LVAPs)}} offer an improved way of managing wireless networks by using a one-to-one mapping between {{c1::LVAPs}} and clients.<br></div>",
                        ""
                    ],
                    "guid": "n~vO=-#!t3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Traffic Engineering</h3>\n<div>Main focus on optimizing the traffic flow so as to minimize {{c1::power consumption}}, judiciously use {{c1::network resources}}, perform {{c1::load balancing}}, etc.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "oV[8[!V:*3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Revisiting the Motivation for SDN</h2><div><div>In software defined networking, every device (switch, router, middlebox, etc.) must be able to make decisions in the forwarding process.</div></div><div>T/F?</div>",
                        "False.<br>The data plane forwards traffic based on the control plane’s decisions."
                    ],
                    "guid": "o}fnP@zA!S",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1><h2>SDN Applications</h2><div>Which of the follow are applications of the SDX architecture?<br></div>",
                        "<ol><li>Inbound traffic engineering</li><li>Wide-area server load balancing</li><li>Redirection of traffic through middleboxes</li></ol>",
                        "<ol><li><span style=\"color: rgb(0, 0, 255);\">Inbound traffic engineering</span></li><li><span style=\"color: rgb(0, 0, 255);\">Wide-area server load balancing</span></li><li><span style=\"color: rgb(0, 0, 255);\">Redirection of traffic through middleboxes</span></li></ol>"
                    ],
                    "guid": "p9s3>5&l-o",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>Southbound interfaces:&nbsp;These are interfaces that act as {{c1::connecting bridges between control and forwarding elements}}. These APIs are {{c2::tightly coupled}} with the forwarding elements of the underlying physical or virtual infrastructure. The most popular implementation of Southbound APIs for SDNs is {{c3::OpenFlow}}, however there are other APIs proposed such as ForCES, OVSDB, POF, OpFlex, OpenState, etc.<br></div>",
                        ""
                    ],
                    "guid": "q3X?0sh/YB",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div><img src=\"sdnPlanesLayers.png\"><br></div><div>Three perspectives of the SDN landscape:</div><div><ul><li>(a)&nbsp;{{c1::a plane-oriented view}}</li><li>(b)&nbsp;{{c1::the SDN layers}}</li><li>(c)&nbsp;{{c1::a system design perspective}}</li></ul></div>",
                        ""
                    ],
                    "guid": "r0r!8Z8RJx",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Mobility and Wireless</h3>\n<div>The existing wireless networks face various challenges in its control plane including management of {{c1::the limited spectrum}}, allocation of {{c1::radio resources}} and {{c1::load-balancing}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "rii?F@JPO(",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>An example Controller: ONOS</h2>\n<div>The management and sharing of the {{c1::network state}} across ONOS cluster instances is achieved by maintaining a {{c2::global network view}}.</div>",
                        ""
                    ],
                    "guid": "sA$m@CBt|S",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Optional: An introduction To The P4 Programming Language</h2>\n<div><div>P4 is a packet processing language with the following characteristics:&nbsp;&nbsp;</div><ul><li>{{c1::Legal header types}} are declared to let the parser be aware of the possible packet formats.</li><li>A {{c2::control flow program}} which uses the declared header types and a set of actions to specify how the headers are processed.</li><li>{{c3::Table Dependency Graphs (TDGs)}} are used to identify the dependencies between the header fields and help determine the order in which the tables can be executed. Tables with no dependencies may be executed in parallel.</li></ul></div>",
                        ""
                    ],
                    "guid": "sNxeqAAgP9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "optional"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Traffic Engineering</h3>\n<div>Large scale service providers also use SDN for traffic optimization to {{c1::scale dynamically}}.<br></div>",
                        "e.g. ALTO VPN enables dynamic provisioning of VPNs in cloud infrastructure."
                    ],
                    "guid": "ss##2++>CI",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>The SDN Landscape</h2><div>Network applications:&nbsp;These are the functionalities that implement the {{c1::control}} plane {{c2::logic}} and translate to {{c2::commands}} in the {{c1::data}} plane.</div>",
                        "Some well known solutions are Hedera, Aster*x, OSP, OpenQoS, Pronto, Plug-N-Serve, SIMPLE, FAMS, FlowSense, OpenTCP, NetGraph, FortNOX, FlowNAC, VAVE, etc."
                    ],
                    "guid": "t++Qbi.Q#2",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>Programming the Data Plane with P4</h2>\n<div>A multiport switch and a SmartNIC are two devices that can be programmed using P4. This is possible due to which of the three primary goals of the language?<br></div>",
                        "Target independence"
                    ],
                    "guid": "t<ULl!:U;[",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Wide Area Traffic Delivery</h2>\n<h3>Inbound traffic engineering</h3>\n<div>An SDN enabled switch can be installed with forwarding rules based on {{c1::the source IP address and source port}} of the packets, thereby enabling an AS to control how the traffic enters its network.<br></div>",
                        ""
                    ],
                    "guid": "tu[D#P6v|N",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Wide Area Traffic Delivery</h2>\n<h3>Redirection through middle boxes</h3>\n<div>To avoid the high expenses involved in placing middleboxes at every location in case of geographically large ISPs, the traffic is {{c1::directed through a fixed set of middleboxes by the ISPs}}. This approach could result in unnecessary additional traffic being redirected, and is also limited by the fixed set of middleboxes. To overcome these issues, an SDX can {{c2::identify and redirect the desired traffic through a sequence of middleboxes}}.<br></div>",
                        ""
                    ],
                    "guid": "u0=,?,75$f",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Application Example: A Software Defined Internet Exchange</h2>\n<div><div><div>SDX was proposed to implement multiple applications including:&nbsp;&nbsp;&nbsp;</div><ul><li>Application {{c1::specific peering}} - {{c2::Custom peering rules can be installed for certain applications, such as high-bandwidth video applications like Netflix or YouTube}}</li><li>Traffic {{c1::engineering}} - {{c3::Controlling the inbound traffic based on source IP or port numbers by setting forwarding rules}}</li><li>Traffic {{c1::load balancing}} - {{c4::The destination IP address can be rewritten based on any field in the packet header to balance the load}}</li><li>Traffic {{c1::redirection through middleboxes}} - {{c5::Targeted subsets of traffic can be redirected to middleboxes}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "uNUIzx*&Sf",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Advantages</h2><div><div><div>Software-defined networks have several advantages:</div><ol><li>{{c1::Shared abstractions}}:&nbsp;These middlebox services (or network functionalities) can be programmed easily now that the {{c1::abstractions}} provided by the control platform and network programming languages can be shared.</li><li>{{c2::Consistency of same network information}}: All network applications have the same global network information view, leading to consistent policy decisions while reusing control plane modules</li><li>{{c3::Locality of functionality placement}}:&nbsp;Previously, the location of middleboxes was a strategic decision and big constraint. However, in this model, the middlebox applications can take actions from anywhere in the network.</li><li>{{c4::Simpler integration}}:&nbsp;Integrations of networking applications are smoother. For example, load balancing and routing applications can be combined sequentially.</li></ol></div><br></div>",
                        ""
                    ],
                    "guid": "x.sApD$@].",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>An example Controller: ONOS</h2>\n<div>{{c1::Titan}}, a {{c2::graph database}} and {{c1::Cassandra}}, a {{c2::distributed key value store}} are used to implement the view. The applications interact with the network view using the {{c3::Blueprints graph API}}.&nbsp;{{c4::Zookeeper}} is used to maintain the mastership between the switch and the controller.</div>",
                        ""
                    ],
                    "guid": "xo`#K8p5|S",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Applications: Overview</h2>\n<h3>Traffic Engineering</h3>\n<div>Another use case of SDN applications is to {{c2::automate the management of router configuration}} to reduce the growth in {{c1::routing tables}} due to {{c1::duplication of data}}.</div>",
                        ""
                    ],
                    "guid": "y-Xx`ZD-lR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>An example Controller: ONOS</h2>\n<div>ONOS ({{c1::Open Networking Operating System}}) is a {{c2::distributed SDN control platform}}. It aims to provide {{c3::a global view of the network to the applications, scale-out performance, and fault tolerance::list 3}}.<br></div>",
                        "The prototype was built based on Floodlight, an open-source single-instance SDN controller."
                    ],
                    "guid": "y-i}F$^T,Z",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson08"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Controllers: Centralized vs Distributed</h2>\n<div>Which architecture provides the highest level of <b>fault tolerance</b>?<br></div>",
                        "A distributed controller with a physically distributed set of elements."
                    ],
                    "guid": "zR@)cLXswc",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Southbound Interfaces</h2><div>What action does an OpenFlow device take when an incoming flow does NOT match any rules in any of the flow tables in the pipeline?<br></div>",
                        "Sends a message to the controller"
                    ],
                    "guid": "zW01%t^5Z?",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 8: SDN</h1>\n<h2>SDN Advantages</h2><div><div><div>Software-defined networks:&nbsp;Since SDN decouples {{c1::the control plane}} from {{c1::the physical networking devices}}, it isolates itself as an external entity (SDN controller). With this, {{c2::middlebox services}} can be viewed as {{c3::a SDN controller application}}.</div></div></div>",
                        ""
                    ],
                    "guid": "z]X:jp?=+|",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson08"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e1f24ae-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [],
            "name": "Lesson 09: Internet Security",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Traffic Attraction Attacks</h2><div><div>In order to stop a prefix or AS-Path announcement attack, we need access to the {{c1::control}} plane data, such as IP prefixes and AS-paths.</div></div>",
                        ""
                    ],
                    "guid": "A&MH7!H+za",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defenses Against DDoS Attacks</h2><div>A {{c1::scrubbing service}} diverts the incoming traffic to a specialized server, where the traffic is {{c1::“scrubbed”}} into either {{c2::clean}} or {{c2::unwanted}} traffic. The {{c2::clean}} traffic is then {{c3::sent to its original destination}}.<br></div>",
                        ""
                    ],
                    "guid": "ANPTy/tYb-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div><div>Round Robin DNS is a mechanism used by large websites to distribute the load of incoming requests to several servers at a single physical location.<br></div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "Ayp4#8hu5f",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Traffic Attraction Attacks</h2><div><div>In attacks where network traffic is dropped, manipulated or impersonated, the data accessed is located at the {{c1::data}} plane.</div></div>",
                        ""
                    ],
                    "guid": "B>iqm@YmH+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS Mitigation Techniques</h2><div><div>BGP Blackholing stops the traffic closer to the destination of the attack.</div></div><div>T/F?</div>",
                        "False<br>The premise of this approach is that the traffic is stopped <b>closer to the source</b> of the attack and before it reaches the targeted victim."
                    ],
                    "guid": "BO*DC/3~BJ",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defending against BGP Hijacking: Example Mitigation Techniques</h2><div><div>The ARTEMIS system uses two automated techniques in mitigating BGP Hijacking attacks:</div><div><ol><li>{{c3::Prefix deaggregation}}:&nbsp;Simply {{c3::deaggregate}} the prefixes that were targeted by {{c1::announcing more specific subprefixes}}.</li><li>{{c3::Mitigation with Multiple Origin AS (MOAS)}}:&nbsp;{{c2::Third party organizations and service providers}} do BGP announcements for a given network.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "C4Km^;=;0%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Background and Spoofing</h2><div><div>In DDoS attacks, spoofing can happen in two forms:</div><div><ol><li>The source IP address is spoofed, resulting in the response of the server {{c1::sent to some other client instead of the attacker’s machine}}. This results in wastage of network resources and the client resources while also causing denial of service to legitimate users.</li><li>In the second type of attack, the attacker {{c2::sets the same IP address in both the source and destination IP fields}}. This results in the server sending the replies to itself, causing it to crash.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "CAV)[mbCvR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Background and Spoofing</h2><div>The packets sent from the slave contain the source address as {{c1::a random IP address}} and the destination as {{c1::the victim’s IP address}}.<br></div>",
                        ""
                    ],
                    "guid": "D;,@:as%2/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>There are different ways AS-Path announcement attacks can be achieved:</div><div><ol><li>{{c4::Type-0 hijacking}}: This is simply {{c1::an AS announcing a prefix not owned by itself}}.</li><li>{{c4::Type-N hijacking}}: This is an attack where {{c2::the counterfeit AS announces an illegitimate path for a prefix that it does not own to create a fake link (path) between different ASes}}.</li><li>{{c4::Type-U hijacking}}:&nbsp;In this attack {{c3::the hijacking AS does not modify the AS-PATH but may change the prefix}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "DET?c6_vJ0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Reflection and Amplification</h2><div>What is the difference between a conventional DDoS and a Reflection and Amplification attack?<br></div>",
                        "In a DDos attack, the slaves send traffic directly to the victim as opposed to a reflector sending the traffic to the victim."
                    ],
                    "guid": "DeCI.9N:8Q",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div>Round Robin DNS (RRDNS) and DNS-based content delivery provide reliability, scalability and resilience, which is great for larger websites. However, this also benefits {{c1::spammers}}. Since using these techniques, a DNS request receives multiple A records (each containing a different IP address), this makes it harder to shut down online scams, as if {{c2::even one IP address is functional}}, the scam is still working.</div>",
                        ""
                    ],
                    "guid": "E!U*RXk{U}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Properties of Secure Communication</h2><div><div>Which property of secure communication ensures that a message is not modified before it reaches the receiver?</div></div>",
                        "Integrity"
                    ],
                    "guid": "FSP#u;):/H",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Interconnection Patterns</h2><div><div>The design of ASwatch is based on monitoring {{c1::global BGP routing activity}} to learn the control plane behavior of a network. The system has two phases:</div><div><ol><li>{{c2::Training}} phase&nbsp;- The system learns {{c3::control-plane behavior}} typical of each type of ASes from a list of {{c4::known malicious and legitimate ASes}}.</li><li>{{c2::Operational}} phase&nbsp;- Given an unknown AS, it then calculates the {{c5::features for this AS}}. It uses the model to then assign {{c6::a reputation score}} to the AS.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "Fq>c^]^T@1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>There are 3 classes of features used for the likelihood of breach model:</div><div><ol><li>{{c1::Mismanagement symptoms}}&nbsp;– If there are misconfigurations in an organization’s network, it indicates that {{c2::there may not be policies in place to prevent such attacks}} or may not have the technological capability to detect these failures.</li><li>{{c1::Malicious Activities}}&nbsp;– The level of malicious activities can be determined using spam traps, darknet monitors, DNS monitors, etc. We create {{c3::a reputation blacklist}} of the IP addresses that are involved in some malicious activities.</li><li>{{c1::Security Incident Reports}}&nbsp;– Data based on actual security incidents gives us the ground truth on which to {{c4::train our machine learning model}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "G]J@eGv;0~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defenses Against DDoS Attacks</h2><div>{{c1::The flow specification feature of BGP, called Flowspec}}, helps to mitigate DDoS attacks by supporting the deployment and propagation of {{c2::fine-grained filters across AS domain borders}}. It can be designed to match {{c3::a specific flow}} or be based on {{c4::packet attributes like length and fragment}}.</div>",
                        ""
                    ],
                    "guid": "I?%PV-AE(=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Evidence of Abuse</h2><div>{{c1::FIRE – FInding Rogue nEtworks}} is a system that {{c2::monitors the Internet for rogue networks}}. Rogue networks are networks whose main purpose is {{c3::malicious activity such as phishing, hosting spam pages, hosting pirated software, etc}}.<br></div>",
                        ""
                    ],
                    "guid": "IIEbb-PQTu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Evidence of Abuse</h2><div>The key difference between rogue and legitimate networks is {{c1::the longevity of malicious behavior}}. By disregarding IP addresses that have been active for {{c2::a short time}}, we ignore phishing attacks hosted on legitimate networks and web servers that were temporarily abused for botnet communication.<br></div>",
                        ""
                    ],
                    "guid": "J/-J3k:r0s",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div><div>{{c1::Round Robin DNS (RRDNS)}} is used by large websites to {{c2::distribute the load of incoming requests to several servers at a single physical location}}. It responds to a DNS request with {{c3::a list of DNS A records, which it then cycles through in a round robin manner}}. Each {{c3::A record}} also has a {{c4::Time to Live (TTL)}} for this mapping which specifies the number of seconds the response is valid.</div></div>",
                        "If the lookup is repeated while the mapping is still active, the DNS client will receive the same set of records, albeit in a different order."
                    ],
                    "guid": "Jg^Glq)~<m",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defenses Against DDoS Attacks</h2><div>Although flowspec has been effective in {{c1::intra-domain environment}}, it is not so popular in {{c1::inter-domain environments}} as it depends on {{c2::trust and cooperation among competitive networks}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "K18BQK38wu",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS Mitigation Techniques: BGP Blackholing</h2><div>The victim AS uses {{c1::BGP}} to communicate the attacked destination prefix to its upstream AS, which then {{c2::drops the attack traffic towards this prefix}}. Then the provider (or the IXP) will {{c3::advertise a more specific prefix}} and modify {{c4::the next-hop address}} that will divert the attack traffic to a null interface.</div>",
                        ""
                    ],
                    "guid": "Ky5#IvXa_&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div><div>{{c1::Fast-Flux Service Networks (FFSN)}} is an extension of the ideas behind RRDNS and CDN. It is based on {{c2::a ‘rapid’ change in DNS answers, with a TTL lower than that of RRDNS and CDN}}. One key difference between {{c1::FFSN}} and the other methods is that {{c3::after the TTL expires, it returns a different set of A records from a larger set of compromised machines}}. These compromised machines act as {{c4::proxies between the incoming request and control node/mothership}}, forming a resilient, robust, one-hop overlay network.<br></div></div>",
                        ""
                    ],
                    "guid": "Kz%<`1:^]^",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Example BGP Hijack Attacks</h2>\n<h3>Attack Scenario: Hijacking a path</h3><div>In path hijacking, the attacker {{c1::manipulates received updates before propagating them to neighbors}}. Routers which previously had a longer path “believe” the new false path and it adopts it. But the rest of the ASes don’t adopt the new path because {{c2::they either have an shorter path already}} or {{c2::an equally long path to the hijacked AS for the same prefix}}.</div>",
                        ""
                    ],
                    "guid": "Kz/t&zIoW3",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Interconnection Patterns</h2><div>With {{c1::data plane monitoring}} only if a network has {{c2::a large enough concentration of blacklisted IPs}} it will be flagged as malicious. In practice, it is not feasible to {{c3::monitor the traffic of all networks to detect malicious behaviors from the data plane}}. In addition, the disadvantage of this approach is that it may {{c4::take a long time until a very large fraction of IPs makes it to a blacklist}}, and 2) the approach does not {{c5::differentiate well between networks that are legitimate but abused, and those which are likely operated by cyberactors}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "LPHaH12F~>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div><div>DNS-based content delivery aims to distribute the load amongst multiple servers at a single location, but also distribute these servers across the world.<br></div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "M?:,9(@7jk",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Reflection and Amplification</h2><div>A Distributed Denial of Service Attack consists on the attacker sending a large volume of traffic to the victim through servers (slaves), so that the victim host becoming unreachable or in exhaustion of its bandwidth.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "MuX4)fj5uN",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Properties of Secure Communication</h2><div><div>Which property of secure communication is protected by encrypting the messages exchanged?</div></div>",
                        "Confidentiality"
                    ],
                    "guid": "M{%!EAG2#]",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Traffic Attraction Attacks</h2><div><div>Prefix deaggregation and mitigation with Multiple Origin AS (MOAS) are independent from ARTEMIS.&nbsp;</div><div>T/F?</div></div>",
                        "False.<br>The ARTEMIS system uses both techniques in mitigating attacks."
                    ],
                    "guid": "N+^8MmBqqY",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>In Classification by Affected Prefix, there are different ways the prefix can be targeted, such as:</div><div><ol><li>Exact prefix hijacking:&nbsp;When two different ASes (one is genuine and the other one is counterfeit) {{c1::announce a path for the same prefix}}.</li><li>Sub-prefix hijacking: This exploits the characteristic of BGP to {{c2::favor more specific prefixes}}.</li><li>Squatting: In this type of attack, the hijacking AS {{c3::announces a prefix that has not yet been announced by the owner AS}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "Nd@Ps*mus)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>{{c1::DDoS}}: Background and Spoofing</h2><div><div>A {{c1::Distributed Denial of Service (DDoS)}} attack is an attempt to compromise a server or network resources with {{c2::a flood of traffic}}. To achieve this, the attacker first {{c3::compromises and deploys flooding servers (slaves)}}.</div><div><br></div><div>Later, when initiating an attack, the attacker {{c4::instructs these flooding servers to send a high volume of traffic to the victim}}. This results in the victim host either {{c5::becoming unreachable}} or {{c5::in exhaustion of its bandwidth}}.</div></div>",
                        ""
                    ],
                    "guid": "OKl;;e,(uk",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>In Data-Plane traffic manipulation attacks, traffic intercepted by the hijacker can be:</div><div><ol><li>{{c1::Dropped}}, so that it never reaches the intended destination. This attack falls under the category of&nbsp;{{c2::blackholing (BH) attack}}.</li><li>{{c1::Eavesdropped}} or manipulated before it reaches the receiving AS, which is also called a {{c3::man-in-the-middle attack (MM)}}.</li><li>{{c1::Impersonated}}, e.g. In this case the network traffic of the victim AS is impersonated and the response to this network traffic is sent back to the sender. This attack is called&nbsp;{{c4::imposture (IM) attack}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "Oa<WvA>@;v",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: {{c1::Interconnection}} Patterns</h2><div>Bulletproof ASes have distinct {{c1::interconnection}} patterns and overall different {{c2::control plane}} behavior from most legitimate networks.</div>",
                        ""
                    ],
                    "guid": "Op&9E5M#ln",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>The features used for Mismanagement symptoms&nbsp;are:</div><ol><li>Open {{c1::Recursive}} Resolvers – misconfigured open DNS resolvers</li><li>DNS Source Port {{c2::Randomization}} – many servers still do not implement this</li><li>BGP Misconfiguration – {{c3::short-lived routes}} can cause unnecessary updates to the {{c4::global routing table}}</li><li>{{c5::Untrusted}} HTTPS Certificates – can detect the validity of a certificate by {{c6::TLS handshake}}</li><li>Open SMTP Mail Relays – servers should filter messages so that only those {{c7::in the same domain}} can send mails/messages</li></ol></div>",
                        ""
                    ],
                    "guid": "PlT+|~5I7]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Interconnection Patterns</h2><div>{{c1::ASwatch}} uses information exclusively from {{c2::the control plane (ie. routing behavior)}} to identify malicious networks. Also, this approach aims to detect malicious networks that are likely run by cyberactors, or {{c3::bulletproof}} as they are called, rather than networks that may be badly abused.<br></div>",
                        ""
                    ],
                    "guid": "Xq[=IqZAn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Background and Spoofing</h2><div>Spoofed source addresses make it difficult for the victim to {{c1::track the slaves}}. Also, since the traffic is sent from multiple sources, it’s harder for the victim to {{c2::isolate and block the attack traffic}}.<br></div>",
                        ""
                    ],
                    "guid": "bx=Q]tx4/k",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Reflection and Amplification</h2><div>IP spoofing is the act of setting a false IP address in the source field of a packet with the purpose of impersonating a legitimate server.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "c<T=XIB#PD",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Properties of Secure Communication</h2><div><div>Which property of secure communication ensures that people are who they say they are when communicating over the internet?</div></div>",
                        "Authentication"
                    ],
                    "guid": "cIaoh:YYQ2",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS Mitigation Techniques: BGP Blackholing</h2><div>With BGP Blackholing, all the attack traffic to a targeted DDoS destination is {{c1::dropped to a null location}}. The premise of this approach is that the traffic is stopped closer to {{c2::the source of the attack and before it reaches the targeted victim}}.</div>",
                        ""
                    ],
                    "guid": "dpP?b.6,Tz",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Properties of Secure Communication</h2><div><div>Certain properties are important to ensure communication is secure even in the presence of attackers:</div><ul><li>{{c1::Confidentiality}} – We want to ensure that messages are {{c2::only available to the two parties}}. One measure towards this is to {{c3::encrypt the message}}.</li><li>{{c1::Integrity}} – It is important to ensure the message has not been {{c4::modified while in transit from the sender to the receiver}}. As a countermeasure, we can {{c5::check for the integrity of the message}}.</li><li>{{c1::Authentication}} – It is important to ensure that the two parties {{c6::are who they say they are}}. To do this we use {{c1::authentication}} mechanisms to verify the identity of a user.</li><li>{{c1::Availability}} - So we will need to ensure that multiple aspects of the communication channel are functioning appropriately and we can cope with {{c7::possible failures such as power outages, hardware failures, etc.}} or attacks that aim to render the system unavailable.</li></ul></div>",
                        ""
                    ],
                    "guid": "duH!edbibJ",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation</h2><div>ASwatch uses information exclusively from the data plane to infer network reputation.<br></div><div>T/F?</div>",
                        "False.<br>The system learns <b>control-plane</b> behavior typical of malicious and legitimate ASes."
                    ],
                    "guid": "ej>9`CNN#q",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS Mitigation Techniques</h2><div>Which mitigation technique uses fine-grained filters across AS domain borders, and attributes such as length and fragment can be used to match traffic?<br></div>",
                        "BGP Flowspec<br>BGP Flowspec supports the deployment and propagation of fine-grained filters across AS domain borders.&nbsp;It can be designed to match a specific flow or be based on packet attributes like length and fragment."
                    ],
                    "guid": "f=MBjy)cr!",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: {{c1::Reflection and Amplification}}</h2><div><div>A {{c1::reflector}} is any server that {{c2::sends a response to a request}}.</div></div>",
                        ""
                    ],
                    "guid": "fXQ@3Fltz_",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Traffic Attraction Attacks: Motivations</h2><div><div>BGP Hijacking attacks can be classified as <b>caused</b> by:</div><ol><li>{{c1::Human Error}}:&nbsp;This is an accidental routing misconfiguration due to manual errors.</li><li>{{c1::Targeted Attack}}:&nbsp;In this type of attack, the hijacking AS usually intercepts network traffic (MM attack) while operating in stealth mode to remain under the radar on the control plane (Type-N and Type-U attacks).</li><li>{{c1::High Impact Attack}}:&nbsp;Here, the attacker is obvious in their intent to cause widespread disruption of services.</li></ol></div>",
                        ""
                    ],
                    "guid": "fb:8k0+tn<",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS Mitigation Techniques: BGP Blackholing Limitations and Problems</h2><div>One of the major drawbacks of BGP blackholing is that {{c1::the destination under attack becomes unreachable since all the traffic including the legitimate traffic is dropped}}.<br></div>",
                        ""
                    ],
                    "guid": "ho;u8-AiME",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation</h2><div>Legitimate networks may let malicious content be up for weeks to more than a year.<br></div><div>T/F?</div>",
                        "False.<br>Legitimate networks are usually able to remove the malicious content within a few days whereas rogue networks may let the content be up for weeks to more than a year!"
                    ],
                    "guid": "hws?S;,]WF",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Reflection and Amplification</h2><div>During a Reflection and Amplification attack, the slaves set the source address of the packets to {{c1::the victim's IP address}}.<br></div>",
                        ""
                    ],
                    "guid": "i!bV%a<${!",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defending against BGP Hijacking: An example detection system</h2><div><div>The key ideas behind {{c5::ARTEMIS}} are:</div><ol><li>{{c1::A&nbsp;configuration file}}: where {{c4::all the prefixes owned by the network are listed here for reference}}. This configuration file is populated by {{c2::the network operator}}.</li><li>{{c1::A&nbsp;mechanism for receiving BGP updates}}: this allows receiving updates from {{c3::local routers}} and {{c3::monitoring services}}.</li></ol></div>",
                        ""
                    ],
                    "guid": "iNj(oBRB};",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defending against BGP Hijacking: Example Mitigation Techniques</h2><div><div>The authors of the ARTEMIS paper put forth two main findings from their research&nbsp; work:</div><ol><li>{{c1::Outsource the task of BGP announcement to third parties}}: To combat against BGP hijacking attacks, having even just one single external organization to mitigate BGP attacks is highly effective against BGP attacks.</li><li>Comparison of outsourcing BGP announcements vs {{c2::prefix filtering}}: When compared against {{c2::prefix filtering}}, which is the current standard defense mechanism, the research work found that filtering is less optimal when compared against BGP announcements.</li></ol></div>",
                        ""
                    ],
                    "guid": "jTz,EVJ]aP",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div>Attackers have developed techniques abusing the DNS protocol so to {{c1::extend the uptime of domains that are used for malicious purposes}} . The ultimate goal of this abuse is to {{c2::remain undetectable for longer}}.<br></div>",
                        "Malicious purposes such as: Command and Control hosting infrastructure, phishing, spamming domains, hosting illegal businesses, illegal content"
                    ],
                    "guid": "jd}!&chy~k",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>The system uses 3 collections of Security Incident Reports to ensure a wider coverage area:</div><ol><li>VERIS Community Database – This is a public effort to collect cyber security incidents in a common format. It is maintained by {{c1::the Verizon RISK team}}. It contains more than 5000 incident reports.</li><li>Hackmageddon – This is {{c2::an independently maintained blog}} that aggregates security incidents on a monthly basis.</li><li>The Web Hacking Incidents Database – This is {{c3::an actively maintained repository for cyber security incidents}}.</li></ol></div>",
                        ""
                    ],
                    "guid": "jkK:N)`TJ:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation</h2><div>How does FIRE identify the most malicious networks?<br></div>",
                        "Analyzing the information given by data sources and searching for ASes with a large percentage of malicious IP addresses."
                    ],
                    "guid": "kDui>!#SD<",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div><div>DNS-based content delivery determines the nearest server, which results in increased responsiveness and availability.<br></div></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "kwu|i</^*!",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Interconnection Patterns</h2><div><div>The three main families of features {{c2::ASwatch}} uses are:</div><div><ol><li>{{c1::Rewiring activity}} – Frequent changes in customers/providers, connecting with less popular providers, etc. is usually suspicious behavior.</li><li>{{c1::IP Space Fragmentation and Churn}} - Malicious ASes are likely to use small BGP prefixes to partition their IP address space and only advertise a small section of these (to avoid all of them being taken down at one if detected).</li><li>{{c1::BGP Routing Dynamics}} – The BGP announcements and withdrawals for malicious ASes follow different patterns from legitimate ones – such as periodically announcing prefixes for short periods of time.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "naQlp!nJfy",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "leech",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div><div>Content Distribution Networks (CDNs) also use {{c1::DNS-based content delivery}}&nbsp;to {{c2::distribute content}} but using more complex strategies. When accessing the name of the service using DNS, the CDN {{c3::computes the ‘nearest edge server’ and returns its IP address to the DNS client}}. CDNs can react quickly to changes in link characteristics as their {{c4::TTL is lower than that in RRDNS}}.</div></div>",
                        ""
                    ],
                    "guid": "nbzzA?wOK",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Evidence of Abuse</h2><div>Each of these data sources produces a list (Li) of {{c1::malicious IP addresses}} {{c2::daily::frequency}}. The approach is to identify the most malicious networks as those which have the highest {{c3::ratio of malicious IP addresses as compared to the total owned IP addresses of that AS}}.<br></div>",
                        ""
                    ],
                    "guid": "p3@VZ3Q!`x",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Example BGP Hijack Attacks</h2>\n<h3>Attack Scenario: Hijacking a prefix</h3><div>In prefix hijacking the attacker sends {{c1::announcements that it owns a prefix (which it does not)}}.&nbsp;This causes {{c2::a conflict of origin}} for the ASes that receive it ({{c3::Multiple Origin AS or MOAS}}).&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "pt`q,SNER:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Evidence of Abuse</h2><div><div>{{c8::FIRE}} uses three main data sources to identify hosts that likely belong to rogue networks:</div><div><ol><li>{{c1::Botnet command and control providers}} - The two main types of botnets this system considers are {{c2::IRC}}-based botnets and {{c2::HTTP}}-based botnets.</li><li>{{c1::Drive-by-download hosting providers}} - a method of malware installation without {{c3::interaction with the user}}. It commonly occurs when the victim visits a web page that contains {{c4::an exploit for their vulnerable browser}}.&nbsp;</li><li>{{c1::Phish housing providers}} - Contains {{c5::URLs of servers}} that host phishing pages. These pages are hosted on {{c6::compromised servers}} and usually are {{c7::up only for a short period of time}}.&nbsp;</li></ol></div></div>",
                        "Phishing pages usually mimic authentic sites to steal login credentials, credit card numbers and other personal information."
                    ],
                    "guid": "qS7U}KM!Fx",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation</h2><div>ASwatch relies on the premise that “bulletproof” ASes have {{c1::distinct}} interconnection patterns and overall different {{c1::control}} plane behavior from most legitimate networks.<br></div>",
                        ""
                    ],
                    "guid": "r9:j}OWaX&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS Mitigation Techniques</h2><div><div>BGP Blackholing is used to mitigate DDoS attacks.</div></div><div>T/F?</div>",
                        "True<br>BGP blackholing is a countermeasure to mitigate a DDoS attacks."
                    ],
                    "guid": "sO/Q~6NDt_",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div>This system uses a {{c1::Random Forest (RF)}} classifier and compares it to a baseline provided by {{c2::a Support Vector Machine (SVM)}}. It uses 258 features. The best combination of parameters gives this model an accuracy of {{c3::90}}%!</div>",
                        ""
                    ],
                    "guid": "sUnv|5/EV4",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Traffic Attraction Attacks</h2><div><div>{{c1::Sub-prefix hijacking}} disrupts the BGP characteristic to favor more specific prefixes.</div></div>",
                        ""
                    ],
                    "guid": "saX=vIWC=X",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Reflection and Amplification</h2><div>In a reflection attack, the attackers use a set of reflectors to initiate an attack on the victim.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "t(+WnJb/`$",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS Mitigation Techniques</h2><div><div>Which defense mechanism consists on a service that diverts the incoming traffic to a specialized server, where traffic is divided in either clean or unwanted traffic, and clean traffic is then sent to its original destination?</div></div>",
                        "Traffic Scrubbing Services<br>A scrubbing service diverts the incoming traffic to a specialized server, where the traffic is “scrubbed” into either clean or unwanted traffic. The clean traffic is then sent to its original destination."
                    ],
                    "guid": "t8-zZ.4CMl",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: Reflection and Amplification</h2><div>In a reflection attack, the master directs the slaves to send {{c1::spoofed requests}} to a very large number of reflectors, usually in the range of 1 million. The slaves set the source address of the packets to {{c2::the victim’s IP address, thereby redirecting the response of the reflectors to the victim}}.<br></div>",
                        ""
                    ],
                    "guid": "txic_jOy,1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DDoS: {{c2::Reflection and Amplification}}</h2><div>If the requests are chosen in such a way that {{c1::the reflectors send large responses to the victim}}, it is a reflection and {{c2::amplification}} attack.<br></div>",
                        ""
                    ],
                    "guid": "v%3ef0Vp1&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>DNS Abuse</h2><div><div>Attackers tend to keep the uptime of domains used for malicious purposes as short as possible in order to avoid being detected.<br></div></div><div>T/F?</div>",
                        "False.<br>Attackers have developed techniques abusing the DNS protocol so to <b>extend</b> the uptime of domains that are used for malicious purposes."
                    ],
                    "guid": "wk#otAqJh#",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>3 types of malicious activities are:</div><ol><li>Capturing {{c1::spam}} activity – for example, CBL, SBL, SpamCop</li><li>Capturing {{c1::phishing and malware}} activities – for example, PhishTank, SURBL</li><li>Capturing {{c1::scanning}} activity – for example, Dshield, OpenBL</li></ol></div>",
                        ""
                    ],
                    "guid": "x%)/yKKDlK",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defending against BGP Hijacking: An example detection system</h2><div>{{c1::ARTEMIS}} is a system that is run {{c2::locally::where}} by {{c2::network operators}} to {{c3::safeguard its own prefixes against malicious BGP hijacking attempts}}.<br></div>",
                        ""
                    ],
                    "guid": "x.y2fOR)42",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>Defenses Against DDoS Attacks</h2><div>{{c1::Access Control List filters}} are deployed by ISPs or IXPs at their {{c2::AS border routers}} to filter out unwanted traffic. They are effective when the hardware is homogeneous and the deployment of the filters {{c3::can be automated}}.<br></div>",
                        ""
                    ],
                    "guid": "y~r@LHmyHH",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 9: Internet Security</h1>\n<h2>How to Infer Network Reputation: Likelihood of Breach</h2><div><div>BGP hijacking attacks&nbsp;can be classified into the following groups:</div><div><ol><li>Classification by {{c1::Affected Prefix}}: In this class of hijacking attacks, we are primarily concerned with the IP prefixes that are advertised by {{c2::BGP}}.</li><li>Classification by {{c1::AS-Path announcement}}: In this class of attacks, an illegitimate AS announces the {{c3::AS-path for a prefix for which it doesn’t have ownership rights}}.</li><li>Classification by {{c1::Data-Plane traffic manipulation}}: In this class of attacks, the intention of the attacker is to {{c4::hijack the network traffic}} and {{c5::manipulate the redirected network traffic on its way to the receiving AS}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "zKUXIBgkax",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "lesson09"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e2140cc-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "inboundBlocking.png",
                "noBlocking.png",
                "outboundBlocking.png"
            ],
            "name": "Lesson 10: Internet Surveillance and Censorship",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (2)</h2><h3>Technique 4: Blocking with {{c1::Resets}}</h3><div>The GFW employs this technique where it sends {{c1::a TCP reset (RST)}} to block {{c2::individual connections}} that contain requests with objectionable content.<br></div>",
                        ""
                    ],
                    "guid": ".DIHayh*1",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><h3>{{c1::IP ID}}</h3><div>Any packet that is sent by a host is assigned {{c1::a unique 16-bit IP identifier (“IP ID”)}}, which the destination host can use to {{c2::reassemble a fragmented packet}}. This {{c1::IP ID}} should be different for {{c3::the packets that are generated by the same host}}.</div>",
                        ""
                    ],
                    "guid": "Cy$-zp#[92",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Optional Reading: Connectivity Disruptions: A Case Study</h2><div>In early 2011 in Egypt, there was a series of political developments.&nbsp; On 25th January, access to {{c1::Twitter}} was blocked and as the political developments intensified, there was a complete shutdown of the Internet on 27th January.</div><div><br></div><div>In Libya, similar political developments unfolded about four days after the above incident. On February 17, {{c2::YouTube}} was blocked to the users followed by an Internet curfew on February 18, blocking Internet connectivity till 8am in the morning. Later on March 3rd, Internet access was disabled completely for around 4 days.&nbsp;</div>",
                        ""
                    ],
                    "guid": "D^}G1a#MY}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>DNS Censorship: A Global Measurement Methodology</h2><div><div>In order to avoid using {{c1::home routers}}, the Iris dataset is restricted to a few thousand {{c2::open DNS resolvers}} that are part of the {{c3::Internet infrastructure}}. There are two main steps associated with this process:</div><ol><li>{{c4::Scanning the Internet’s IPv4 space}} for open DNS resolvers</li><li>Identifying {{c3::Infrastructure DNS Resolvers}}</li></ol></div>",
                        ""
                    ],
                    "guid": "E*jSbs]HR9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Example Censorship Detection Systems and Their Limitations</h2><div>One the most common systems/approaches to censorship measurement is {{c1::the OpenNet Initiative}} where volunteers perform measurements on their home networks at different times since the past decade. Relying on {{c2::volunteer efforts}} make continuous and diverse measurements very difficult.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "Ee[Z2OoUpq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (2)</h2><h3>Technique 3: Content Inspection</h3><div>Proxy-based content inspection:&nbsp;This censorship technique is more sophisticated, in that it allows for all network traffic to pass through a proxy where the traffic is {{c1::examined for content}}, and the proxy rejects requests that {{c1::serve objectionable content}}.<br></div>",
                        ""
                    ],
                    "guid": "H,Uhz3Pulh",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><div>Augur is used to identify DNS-based manipulations.<br></div><div>T/F?</div>",
                        "False.<br>Augur is a method and accompanying system that utilizes TCP/IP side channels to measure reachability (if there is any filtering) between two Internet locations without directly controlling a measurement vantage point at either location."
                    ],
                    "guid": "I*=|Jax&)^",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>DNS Censorship: A Global Measurement Methodology</h2><div><div>The steps involved in this measurement process are:</div><ol><li>{{c1::Performing global DNS queries}} – Iris queries thousands of domains across thousands of open DNS resolvers.</li><li>{{c2::Annotating DNS responses with auxiliary information}} – To enable the classification, Iris annotates the IP addresses with additional information such as their geo-location, AS, port 80 HTTP responses, etc. This information is available from the Censys dataset.</li><li>{{c3::Additional PTR and TLS scanning}} – One IP address could host several websites via virtual hosting. So, when Censys retrieves certificates from port 443, it could differ from one retrieved via TLS’s Server Name Indication (SNI) extension. This results in discrepancies that could cause Iris to label virtual hosting as DNS inconsistencies. To avoid this, Iris adds PTR and SNI certificates.</li></ol></div>",
                        ""
                    ],
                    "guid": "KZ=_j[#&/f",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>DNS Censorship</h2><div>The Great Firewall of China is likely&nbsp;managed by a&nbsp;single entity.<br></div><div>T/F?</div>",
                        "True<br><i>Since the blocklists obtained from two distinct GFW locations are the same, there is a high possibility of a central management (GFW Manager) entity that orchestrates blocklists.</i>"
                    ],
                    "guid": "Kba?&4X}XT",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><h3>{{c1::Outbound blocking}}</h3><div>{{c1::Outbound blocking}} is the filtering imposed on the path from {{c2::the reflector}} to the {{c2::site}}. Here, the reflector receives the {{c3::SYN-ACK}} packet and generates a {{c3::RST}} packet. However, the {{c3::RST}} packet does not reach the site. When the site doesn’t receive a {{c3::RST}} packet, it continues to resend the {{c3::SYN-ACK}} packets at regular intervals depending on the site’s OS and its configuration. The before/after IP ID will be {{c4::at least 2 and even higher}} with {{c3::resent SYN-ACK packets}}.<br></div>",
                        "<img src=\"outboundBlocking.png\">"
                    ],
                    "guid": "N2S3PsV=ga",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><div><div>Suppose we are using Augur to detect filtering between two host, and that we have a scenario where no blocking occurs. The measurement machine sends a SYN-ACK to the reflector. What should happen?</div></div>",
                        "The return IP ID from the reflector to the measurement machine should increase by 2.<br><img src=\"outboundBlocking.png\">"
                    ],
                    "guid": "Nh%=ig+C-(",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>DNS Censorship: What is it?</h2><div>DNS censorship is {{c1::a large scale network traffic filtering strategy}} opted by a network to {{c2::enforce control and censorship}} over Internet infrastructure to suppress material which they deem as objectionable.<br></div>",
                        ""
                    ],
                    "guid": "OEp{&Zjoqz",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><h3>{{c1::Inbound blocking}}</h3><div>With {{c1::inbound blocking}}, filtering occurs on the path from {{c2::the site}} to {{c2::the reflector}}. In this case, the {{c3::SYN-ACK}} packet sent from the site does not reach the reflector. Hence, there is no response generated and the IP ID of the reflector {{c4::does not increase}}, and the before/after difference is {{c4::1}}.<br></div>",
                        "<img src=\"inboundBlocking.png\">"
                    ],
                    "guid": "OU:<~@VKma",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Why is {{c2::DNS Manipulation}} Difficult to Measure?</h2><div><div>What are the challenges of understanding censorhip around the world?&nbsp;</div><div><ol><li>Diverse Measurements: We need&nbsp;{{c1::widespread longitudinal measurements}} to understand global Internet manipulation and the heterogeneity of {{c2::DNS manipulation}}, across countries, resolvers, and domains.&nbsp;</li><li>Need for Scale: There is a need for methods and tools that are {{c3::independent of human intervention and participation}}.&nbsp;</li><li>Identifying {{c4::the intent to restrict content access}}:&nbsp;While identifying&nbsp;inconsistent or anomalous DNS responses can help to detect a variety of underlying causes such as misconfigurations, identifying DNS manipulation is different and it requires that we detect {{c4::the intent to block access to content}}.</li><li>Ethics and Minimizing Risks: It is safer to stay away from using DNS&nbsp;resolvers or DNS forwarders in {{c5::the home networks of individual users}}. Instead, it is safer to&nbsp;rely on&nbsp;open DNS resolvers that are hosted in {{c5::Internet infrastructure, for example, within Internet service providers or cloud hosting providers}}.&nbsp;</li></ol></div></div>",
                        ""
                    ],
                    "guid": "bu_b+e1]0#",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (2)</h2><h3>Technique 2: DNS Poisoning</h3><div>When DNS receives a query for resolving hostname to IP address there is {{c1::no answer returned}} or {{c1::an incorrect answer is sent}}.<br></div><div><br></div><div><ul><li>Strength</li><ul><li>{{c2::No overblocking: Since there is an extra layer of hostname translation, access to specific hostnames can be blocked versus blanket IP address blocking.}}</li></ul><li>Weakness</li><ul><li>{{c2::Blocks the entire domain. It is not possible to allow email contact while blocking the website.}}</li></ul></ul></div>",
                        ""
                    ],
                    "guid": "bz*|Z2>rN>",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><div><div>{{c1::Perturbation}} is a mechanism which {{c2::forces a host to increment its IP ID counter}} by sending traffic from different sources such that the host generates a response packet. The flow here is as follows:&nbsp;</div><ol><li>The measurement machine sends a spoofed {{c3::TCP SYN}} packet to the site with source address set to the reflector’s IP address.</li><li>The site responds to the reflector with a {{c3::TCP SYN-ACK}} packet.</li><li>The reflector returns a {{c3::TCP RST}} packet to the site while also incrementing its global IP ID counter by 1.&nbsp;</li></ol></div>",
                        ""
                    ],
                    "guid": "c1/bZ[R~0A",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (2)</h2><div>Usually, a censorship system implements these techniques {{c1::in combination}} to effect censorship on a network.<br></div>",
                        ""
                    ],
                    "guid": "d[}G1a{DRn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Censorship Detection</h2><div>Censorship methods are {{c1::inconsistent}} across ISPs making it {{c1::difficult}} to measure DNS manipulation.<br></div>",
                        ""
                    ],
                    "guid": "g<-Q?Ilp{?",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (1)</h2><div><div>The steps involved in DNS injection are:</div><ol><li>{{c1::DNS probe}} is sent to the open DNS resolvers</li><li>The Step 1 result is checked against the {{c2::blocklist of domains and keywords}}</li><li>For domain level blocking, {{c3::a fake DNS A record}} response is sent back.</li></ol></div>",
                        ""
                    ],
                    "guid": "gEBwE%9AmN",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (2)</h2><h3>Technique 5: Immediate Reset of Connections</h3><div>Following one “questionable” request, the requestor will {{c1::continue to receive resets from the firewall}} for a particular duration.</div>",
                        ""
                    ],
                    "guid": "h54/0;_+Y]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><h3>Perterbation</h3><div>The measurement machine thus observes that {{c1::the difference in IP IDs}} before and after perterbation is {{c2::2}} and infers that {{c3::communication has occurred between the two hosts}}.<br></div>",
                        "<img src=\"noBlocking.png\">"
                    ],
                    "guid": "i)Ba!ZVZES",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Censorship Detection</h2><div>The use of Open DNS resolvers resolves some of the ethical concerns associated with Internet censorship studies.<br></div><div>T/F?</div>",
                        "True<br>It is safer to rely on open DNS resolvers that are hosted in Internet infrastructure, for example, within Internet service providers or cloud hosting providers."
                    ],
                    "guid": "i]`H]Bf^kL",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (2)</h2><h3>Technique 3: Content Inspection</h3><div>{{c1::Intrusion detection system (IDS)}} based content inspection: An alternative approach is to use parts of an {{c1::IDS}} to inspect network traffic. An {{c1::IDS}} is easier and more cost effective to implement than a proxy based system as it is more responsive than reactive in nature, in that it informs the firewall rules for future censorship.<br></div>",
                        ""
                    ],
                    "guid": "j|;[3a+FkU",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (1)</h2><div>There are two levels of blocking domains:</div><div><ol><li>{{c1::directly blocking the domain}}</li><li>{{c1::blocking based on keywords present in the domain}}</li></ol></div>",
                        ""
                    ],
                    "guid": "k.4DR5QLG/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Censorship Through Connectivity Disruptions</h2><div><div>Using software to interrupt the routing or packet forwarding mechanisms can work by:&nbsp;</div><div><ol><li>{{c1::Routing disruption}}: If routing communication is disrupted or disabled on critical routers, it could result in unreachability of the large parts of a network. Using this approach can be easily detectable, as it involves {{c2::withdrawing previously advertised prefixes or re-advertising them with different properties}}.&nbsp;</li><li>{{c1::Packet filtering}}: Can be used to block packets matching a certain criteria disrupting the normal forwarding action. This approach can be harder to detect and might require {{c3::active probing of the forwarding path}} or {{c4::monitoring traffic of the impacted network}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "kW<},C{9}r",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>DNS Censorship</h2><div><div>The&nbsp;Great Firewall of China&nbsp;may block&nbsp;content based on which of the following&nbsp;characteristics?</div></div>",
                        "<ul><li>Keywords within the URL</li><li>Images on webpage</li><li>Destination IP</li></ul>",
                        "<ul><li><span style=\"color: rgb(0, 0, 255);\">Keywords within the URL</span></li><li><span style=\"color: rgb(0, 0, 255);\">Images on webpage</span></li><li><span style=\"color: rgb(0, 0, 255);\">Destination IP</span></li></ul><div><i></i>The GFW operates in an on-path fashion, passively examining passing traffic.&nbsp;It may use&nbsp;any combinations of characteristics&nbsp;for filtering.<br></div>"
                    ],
                    "guid": "oIig-O01N`",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>DNS Censorship: What is it?</h2><div>The Great Firewall of China (GFW) works by {{c1::injecting fake DNS record responses so that access to a domain name is blocked}}.<br></div>",
                        ""
                    ],
                    "guid": "pyZ<F&lgrS",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Optional Reading: Connectivity Disruptions: A Case Study</h2><div>{{c1::Internet background radiation (IBR)}} refers to {{c2::unsolicited one-way traffic to unused IP addresses in the Internet}}. These usually indicate malicious activity on the Internet, including worms, Denial of Service attacks, etc. {{c1::IBR}} traffic is observed using network telescopes, called {{c3::darknets}}.<br></div>",
                        ""
                    ],
                    "guid": "q&rURROX@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>DNS Censorship: A Global Measurement Methodology</h2><div><div>Iris uses two types of metrics to identify DNS manipulation:</div><div><ol><li>{{c1::Consistency}} Metrics - Domain access should have some agreement, in terms of network properties, infrastructure, or content, even when accessed from different global vantage points.</li><li>{{c1::Independent Verifiability}} Metrics - Some of the {{c1::independent verifiability}} metrics used are HTTPS certificate without SNI and HTTPS Certificate with SNI.</li></ol></div><div><br></div><div>If&nbsp;any {{c1::consistency}} metric or {{c1::independent verifiability}} metric is satisfied, the response is {{c2::correct}}. Otherwise, the response is classified as {{c2::manipulated}}.</div><br></div>",
                        ""
                    ],
                    "guid": "q+h@/4V,P^",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>DNS Censorship: What is it?</h2><div><div>Researchers have started to identify some of the properties of the GFW:&nbsp;<br></div><ol><li>Locality of GFW nodes: There are two differing notions on whether the GFW nodes are present only at the edge ISPs or whether they are also present in non-bordering Chinese ASes. The majority view is that censorship nodes are {{c1::present at the edge}}.</li><li>{{c2::Centralized}} management: Since the blocklists obtained from two distinct GFW locations are the same, there is a high possibility of a {{c2::central}} management (GFW Manager) entity that orchestrates blocklists.</li><li>Load balancing: GFW load balances between processes based on source and destination IP address. The processes are clustered together to collectively send {{c3::injected DNS responses}}.</li></ol></div>",
                        ""
                    ],
                    "guid": "qM_X}=(*lh",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>DNS Censorship</h2><div>Suppose a client in Cambridge&nbsp;makes a request to a website based in China. When does the GFW reset the connection?<br></div>",
                        "After the ACK sent by the client in Cambridge."
                    ],
                    "guid": "soYCXR1W_:",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>DNS Censorship: A Global Measurement Methodology</h2><div><div>Suppose&nbsp;Iris is being used to detect DNS manipulation.&nbsp;Iris&nbsp;queries a global&nbsp;resolver for an IP addresses&nbsp;(consistency metric)&nbsp;and receives&nbsp;a DNS A&nbsp;record&nbsp;with a different IP&nbsp;address than the ones stored.<br></div><div><br></div>The response is {{c1::inconsistent}}. It {{c1::might not}} be classified as manipulated.<br></div>",
                        "<span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">The response is inconsistent, but will be classified as correct if&nbsp;</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">still the IP address&nbsp;</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">satisfies</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">&nbsp;</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">an</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">&nbsp;independent verifiability metric (e.g., the IP address presents a valid, browser-</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">trusted</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">&nbsp;certificate for the correct domain&nbsp;</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">name)</span><span style=\"color: rgb(45, 59, 69); background-color: rgb(255, 255, 255);\">.</span>"
                    ],
                    "guid": "t:eA{Uc%M@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Censorship Detection</h2><div>Current research methods for understanding DNS methods are scalable due to the number of volunteers participating.<br></div><div>T/F?</div>",
                        "False<br>At first, the methods to measure Internet censorship were relying on volunteers who were running measurement software on their own devices. Since this requires them to actually install software and do measurements, we can see that this method is unlikely to reach the scale required."
                    ],
                    "guid": "tF$^4G{g@.",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><div>{{c1::Augur::tool}} aims to detect if filtering exists between two hosts, a {{c2::reflector}} and a {{c2::site}}. A {{c2::reflector}} is a host which maintains {{c3::a global IP ID}}. A {{c2::site}} is {{c4::a host that may be potentially blocked}}. To identify if filtering exists, it makes use of a third machine called the {{c5::measurement machine}}.</div>",
                        ""
                    ],
                    "guid": "u^=$hv/Ia9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>DNS Censorship: A Global Measurement Methodology</h2><div>{{c1::Iris}} is a method to identify {{c2::DNS manipulation}} via {{c3::machine learning}}. It&nbsp;uses {{c4::open DNS resolvers}} located all over the globe.<br></div>",
                        ""
                    ],
                    "guid": "v8gFh]*F7v",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1>\n<h2>Example DNS Censorship Techniques (2)</h2><h3>Technique 1: Packet Dropping</h3><div>In packet dropping, {{c1::all network traffic}} going to {{c2::a set of specific IP addresses}} is discarded.<br></div><div><br></div><div><ul><li>Strengths</li><ul><li>{{c3::Easy to implement}}</li><li>{{c3::Low cost}}</li></ul><li>Weaknesses</li><ul><li>{{c4::Maintenance of blocklist - It is challenging to stay up to date with the list of IP addresses to block}}</li><li>{{c4::Overblocking - If two websites share the same IP address and the intention is to only block one of them, there’s a risk of blocking both}}</li></ul></ul></div>",
                        ""
                    ],
                    "guid": "yM%Jx~DPp]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Connectivity Disruptions: Detection</h2><div>{{c1::Probing}} is a mechanism to {{c2::monitor the IP ID of a host over time}}. We use the measurement machine to observe the IP ID generated by {{c3::the reflector}}. To do so, the measurement machine sends a {{c4::TCP SYN-ACK}} to the reflector and receives a {{c4::TCP RST}} packet as the response, containing the {{c5::latest IP ID that was generated by the reflector}}.</div>",
                        ""
                    ],
                    "guid": "y~)LZn/r6%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 10: Internet Surveillance and Censorship</h1><h2>Example Censorship Detection Systems and Their Limitations</h2><div>{{c3::Augur}} is a new system created to perform longitudinal global measurements using {{c1::TCP/IP side channels}}. It focuses on identifying {{c2::IP-based disruptions}}.<br></div>",
                        ""
                    ],
                    "guid": "zj;R)us.A*",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson10"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e2305f6-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 8,
            "extendRev": 0,
            "media_files": [],
            "name": "Lesson 11: Applications: Video",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Streaming</h2><div>What is the first item downloaded by a client’s video player?<br></div>",
                        "A manifest file"
                    ],
                    "guid": "A^K{gUgL3h",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>When using Forward Error Correction, the redundant data that is transmitted alongside the main transmission&nbsp;could be a copy of the original data divided into&nbsp;chunks or&nbsp;could also be a lower-quality version.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "ArKooxlLG#",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How Does VoIP Work?</h2><div>Analog audio by nature is represented as {{c1::a continuous wave}}, but digital data by nature is {{c1::discrete}}. Therefore, all digital representations of analog audio are only {{c2::approximations}}.<br></div>",
                        ""
                    ],
                    "guid": "Ase[XVr,&:",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Bitrate Adaptation in {{c1::DASH}}</h2><div><div>The client dynamically adjusting the video bitrate based on the network conditions and device type is known as {{c1::Dynamic Streaming over HTTP or DASH}}.</div></div>",
                        "There have been multiple implementations of this with HLS and MPEG-DASH being the most popular."
                    ],
                    "guid": "DIsaC>h2j9",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><h3>Streaming live audio and video</h3><div>Since these applications are live and broadcast-like, there are generally&nbsp;many {{c1::simultaneous}} users, sometimes in very different geographic locations. They are also&nbsp;delay-sensitive, but not as much as {{c2::conversational voice and video applications}} are - generally, a ten second delay is ok.<br></div>",
                        ""
                    ],
                    "guid": "E6wg6XT_Bn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Metrics</h2><div><div>End-to-end delay includes delay from:</div><ul><li>the time it takes to {{c1::encode the audio}}</li><li>the time it takes to {{c2::put it in packets}}</li><li>all the normal sources of {{c3::network delay}} that {{c3::network traffic}} encounters such as queueing delays</li><li>{{c4::playback delay}} which comes from the receiver’s {{c4::playback}} buffer</li><li>{{c5::decoding delay}}, which is the time it takes to reconstruct the signal</li></ul></div>",
                        ""
                    ],
                    "guid": "Eru_v>.SG0",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><div>The first defining property for video is&nbsp;{{c1::high bit rate}}, generally somewhere between {{c2::100 kbps}} to over {{c2::3Mbps}}, depending on the quality of the video.<br></div>",
                        ""
                    ],
                    "guid": "Ez=S14/zNA",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><h3>Streaming Stored Video</h3><div>Video starts playing {{c1::within a few seconds of receiving data, instead of waiting for the entire file to download first}}. It’s also&nbsp;interactive, which means that the {{c2::user can pause, fast forward, skip ahead or move back in the video, and then see the response within a few seconds}}. Streaming stored video should also have&nbsp;{{c3::continuous playout}}, which means that it should play out the same way it was recorded without freezing up in the middle. Generally, streaming stored video files are stored {{c4::on a CDN rather than just one data center::location}}. This type of multimedia application can also be implemented with the {{c5::peer-to-peer}} model instead of the {{c5::client-server}} model.<br></div>",
                        ""
                    ],
                    "guid": "F|pi#XaV5[",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Streaming</h2><div>Suppose that Alice is using a cloud service to listen to many MP3 songs, one after the other, each encoded at a rate of 128 kbps. Suppose that she downloads for 30 minutes (1800 seconds). How many Mbytes of data are transferred during the 30-minute session? Round your answer to the nearest Mbytes. (For simplification, assume 1 MB = 8,000 Kb).<br></div>",
                        "29 Mbytes<br>\\(128kbps * 1800s * \\frac{1MB}{8000Kb} = 28.8 MB \\approx 29 MB\\)"
                    ],
                    "guid": "GuR[LsziGQ",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>UDP vs TCP</h2><div>Content providers ended up choosing {{c1::TCP::transport protocol}} for video delivery as it provides reliability.<br></div>",
                        ""
                    ],
                    "guid": "Gz%e<,QCwb",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How Does VoIP Work?</h2><div>Generally speaking, audio is encoded by {{c1::taking many (as in, thousands) of samples per second}}, and then {{c2::rounding each sample’s value to a discrete number within a particular range}}. (This “{{c2::rounding}}” to a discrete number is called&nbsp;{{c3::quantization}}.)<br></div>",
                        ""
                    ],
                    "guid": "HHTrnf=AoW",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How Does VoIP Work?</h2><div>VoIP also uses {{c1::signaling protocols}}, just like telephony, to perform the same functions ({{c2::how calls are set up and torn down}}). The {{c3::SIP (Session Initiation Protocol)}} is just one example of a {{c1::signaling protocol}} used in many VoIP applications.<br></div>",
                        ""
                    ],
                    "guid": "HO4Csod_4L",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>Which of the following services is the most tolerant&nbsp;to packet losses? (assuming no retransmit)<br></div>",
                        "<ul><li>VoIP</li><li>File transfer</li><li>Stored audio and video streaming</li></ul>",
                        "<ul><li><span style=\"color: rgb(0, 0, 255);\">VoIP</span></li><li>File transfer</li><li>Stored audio and video streaming</li></ul>"
                    ],
                    "guid": "H]+tJqZvrZ",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Live/On Demand Streaming Introduction</h2><div>The types of content that is streamed over the Internet can be divided into two categories:<br><ol><li>{{c1::Live}} -- this means the video content is created and delivered to the clients simultaneously. One of the main constraints being that there is not a lot of room for {{c2::pre-fetching content}} in the case of live streaming.</li><li>{{c1::On-demand}} -- this includes streaming stored video based on users’ convenience.</li></ol></div>",
                        "It turns out that most of the basic principles behind streaming live at large-scale and on-demand content are similar apart from the few details such as video encoding."
                    ],
                    "guid": "I|`7zwFkcG",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Throughput-Based Adaptation and its Limitations</h2><div><div>A simple rate-based adaptation algorithm has the following steps:&nbsp;</div><div><ol><li>{{c1::Estimation}}: This is done by {{c2::considering the throughput of the last few downloaded chunks}}.</li><li>{{c1::Quantization}}: We select {{c3::the maximum bitrate that is less than the estimate of the throughput, including a factor in this selection}}.</li></ol></div></div>",
                        ""
                    ],
                    "guid": "LIyT;fukCx",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Progressive Download vs Streaming</h2><div>Instead of downloading the content all at once, the client sends {{c1::byte-range&nbsp;requests}} for part of the video instead of requesting the entire video.<br></div>",
                        ""
                    ],
                    "guid": "Pv!zZ93k;;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div><div>With VoIP, a packet is lost if it either {{c1::never arrives}} OR {{c1::if it arrives after its {{c2::scheduled playout}} }}.</div></div>",
                        "VoIP can tolerate loss rates of between 1 and 20 percent, depending on what voice codec is used and other factors."
                    ],
                    "guid": "Q<7~]}]W~}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Live/On Demand Streaming Introduction</h2><div>Streaming media content accounts for nearly {{c1::60-70}}% of the Internet traffic.<br></div>",
                        ""
                    ],
                    "guid": "QVO//BG<T~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Multimedia Applications: A Perspective From the Network</h2><div>Multimedia applications are defined in Kurose and Ross as “{{c1::any network application that employs audio or video}}.”&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "QZaC!EI}Bq",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><div><div>Multimedia applications can be organized into three major categories</div><div><ul><li>{{c1::streaming&nbsp;stored&nbsp;audio and video, such video clips on Udacity for our OMSCS courses}}</li><li>{{c1::conversational&nbsp;voice and video over IP, such as Skype}}</li><li>{{c1::streaming&nbsp;live&nbsp;audio and video, such as the graduation ceremony for GATech on graduation day}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "Ra8{1H|_[]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How Does VoIP Work?</h2><div>The three major categories of {{c1::encoding schemes}} are narrowband, broadband, and multimode (which can operate on either). For VoIP, the important thing is that we want {{c2::to still be able to understand the speech and the words that are being said}}, while at the same time {{c2::still using as little bandwidth as possible}}.&nbsp;<br></div>",
                        ""
                    ],
                    "guid": "V77*4HnCe",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>What are the Goals of Bitrate Adaptation?</h2><div><div>A good QoE ({{c1::quality of experience}}) is usually characterized by the following:</div><ul><li>{{c2::Low or zero re-buffering}}: users typically tend to close the video session if the video stalls a lot</li><li>{{c2::High video quality}}: A higher video quality is usually characterized by high bitrate video chunk.</li><li>{{c2::Low video quality variations}}: A lot of video quality variations are also known to reduce the user QoE.</li><li>{{c2::Low startup latency}}: Startup latency is the time it takes to start playing&nbsp; the video since the user first requested to play the video.</li></ul></div>",
                        ""
                    ],
                    "guid": "d.2Qxhqx</",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Live/On Demand Streaming Introduction</h2><div>Various enabling technologies and trends have led to this development of consuming media content over the Internet:</div><div><ol><li>{{c1::bandwidth}} for both the core network and last-mile access links have increased tremendously over the years.&nbsp;</li><li>{{c2::video compression}} technologies have become more efficient.</li><li>the development of {{c3::Digital Rights Management}} culture has encouraged content providers to put their content on the Internet.</li></ol></div>",
                        ""
                    ],
                    "guid": "dG-a`p34Qr",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Multimedia Applications: A Perspective From the Network</h2><div>Video randomly speeding up or freezeing can be addressed with {{c1::buffering techniques}}.<br></div>",
                        ""
                    ],
                    "guid": "es8;TB%fv-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How Does VoIP Work?</h2><div>Signaling protocols are responsible for four major functions:</div><div><ol><li>User location - {{c1::the caller locating where the callee is}}.</li><li>Session establishment - {{c2::handling the callee accepting, rejecting, or redirecting a call}}.</li><li>Session negotiation&nbsp; - {{c3::the endpoints synchronizing with each other on a set of properties for the session}}.</li><li>Call participation management - {{c4::handling endpoints joining or leaving an existing session}}.&nbsp;</li></ol></div>",
                        ""
                    ],
                    "guid": "f)<,x=uj~,",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Delay Jitter</h2><div>The main VoIP application mechanism for mitigating jitter is maintaining {{c1::a buffer}}, called the “{{c1::jitter buffer}}” or the “{{c1::play-out buffer}}.” This mechanism helps to {{c2::smooth out and hide the variation in delay}} between different received packets, by buffering them and playing them out for decoding at a steady rate.<br></div>",
                        ""
                    ],
                    "guid": "g2qw${M,Jz",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>Which of the following services is the least sensitive to network delays?&nbsp;(i.e.&nbsp;more tolerant to network delays).&nbsp;<br></div>",
                        "<ul><li>VoIP</li><li>File transfer</li><li>Stored audio and video streaming</li></ul>",
                        "<ul><li><strike>VoIP</strike></li><li><span style=\"color: rgb(0, 0, 255);\">File transfer</span></li><li><strike>Stored audio and video streaming</strike></li></ul>"
                    ],
                    "guid": "h0G6?0|},-",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>Error concealment can be computationally cheap if a lost packet is simply replaced&nbsp;with a previous packet.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "h0_?zk&?L=",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Throughput-Based Adaptation and its Limitations</h2><div><div>The buffer-filling rate is {{c1::the network bandwidth divided by the chunk bitrate}}.</div><div><br></div><div>The buffer-depletion rate or the output rate is {{c2::simply 1}}.</div></div>",
                        "The buffer-filling rate can be thought of as how many chunks can be downloaded in the time it takes to play 1 chunk.<br>The buffer-depletion rate is 1 because 1s of video content gets played in 1s."
                    ],
                    "guid": "hX[tj.h,S&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Problem of Bandwidth UNDER-Estimation with Rate-Based Adaption</h2><div><div>As the bitrate becomes lower, the chunk size {{c1::reduces}}. In the presence of a competing flow, a smaller chunk size would {{c2::lower the probability for the video flow to get its fair share}}.</div></div>",
                        ""
                    ],
                    "guid": "i<]D:/$ImB",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>{{c1::Bitrate Adaptation}} in DASH</h2><div><div>Each time the video player needs to download a video chunk, it calls the {{c1::bitrate adaptation}} function.</div></div>",
                        ""
                    ],
                    "guid": "iKPvx)iSK<",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How to Handle Network and User Device Diversity?</h2><div>The client switching between different quality streams as network conditions change is known as {{c1::bitrate adaptation}}.<br></div>",
                        ""
                    ],
                    "guid": "iifj8<O-k7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Bitrate Adaptation Algorithms</h2><div><div>Different signals can serve as an&nbsp;input&nbsp;to a bitrate adaptation algorithm:</div><div><ul><li>{{c5::Network Throughput}}: Ideally, you would want to select a bitrate that is {{c1::equal or lesser than the available throughput}}. Bitrate adaptation using this signal are known as {{c2::rate-based}} adaptation.&nbsp;&nbsp;</li><li>{{c5::Video Buffer}}: If the video buffer is full, then the player can {{c3::possibly afford to download high-quality chunks}}. Similarly, if the video buffer is low, the player can {{c3::download low-quality chunks so as to quickly fill-up the buffer and avoid any re-buffering}}. Bitrate adaptation based on the video buffer is known as {{c4::buffer-based}} adaptation.&nbsp;</li></ul></div></div>",
                        ""
                    ],
                    "guid": "ismhgx7]Dd",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How to Handle Network and User Device Diversity?</h2><div>To deal with different and changing network conditions, content providers encode their video {{c1::at multiple bitrates chosen from a set of pre-defined bitrates}}. Specifically, the video is {{c2::chunked into segments which are usually of equal duration}}. Each of these segments is then {{c1::encoded at multiple bitrates}} and stored at the server.<br></div>",
                        ""
                    ],
                    "guid": "jhOI:9k23]",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Problem of Bandwidth UNDER-Estimation with Rate-Based Adaption</h2><div>DASH clients have a {{c1:: ON-OFF}} pattern in the steady state. This happens when {{c2::the video client has the buffer filled up and it is waiting for to deplete before requesting the next chunk}}.<br></div>",
                        ""
                    ],
                    "guid": "k8>!b.p}9&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><div>Conversational voice and video over IP is a service that uses traditional circuit-switched telephony networks.<br></div><div>T/F?</div>",
                        "False.<br>Notice that VoIP stands for “Voice over IP”, which is like phone service that <b>goes over the Internet</b> instead of through traditional circuit-switched telephony network."
                    ],
                    "guid": "kyb<^%&y[8",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Delay {{c1::Jitter}}</h2><div>Different voice packets can end up with different amounts of delay. We call this phenomenon “{{c1::jitter}},” “packet {{c1::jitter}},” or “delay {{c1::jitter}}.”<br></div>",
                        ""
                    ],
                    "guid": "lHC2t;+xi$",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>Retransmitted packets are no good if {{c1::they are received too late}}. So most of the time, VoIP protocols use {{c2::UDP::transport protocol}}.<br></div>",
                        ""
                    ],
                    "guid": "lphonjaqV%",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>An advantage of using Interleaving is that there is no added latency.<br></div><div>T/F?</div>",
                        "False.<br>The tradeoff for interleaving is that the receiving side has to wait longer to receive consecutive chunks of audio, and that increases latency. Unfortunately, that means this technique is limited in usefulness for VoIP, although it can have good performance for streaming stored audio."
                    ],
                    "guid": "m+Omlyh`#x",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><h3>Conversational {{c1::voice and video over IP}}</h3><div>Notice that&nbsp;VoIP&nbsp;stands for “{{c1::Voice over IP}}”. These applications are highly&nbsp;delay-sensitive; a short delay of less than {{c2::150 milliseconds}} isn’t really noticeable, but a longer delay, such as over {{c2::400 milliseconds}}, can be frustrating as people end up accidentally talking over each other. On the other hand, these applications are&nbsp;{{c3::loss-tolerant}}.<br></div>",
                        ""
                    ],
                    "guid": "mvio8wDHZ}",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Problem of Bandwidth OVER-Estimation with Rate-Based Adaptation</h2><div>When the bandwidth changes rapidly, the player takes some time to {{c1::converge to the right estimate of the bandwidth}}.<br></div>",
                        ""
                    ],
                    "guid": "n:`Jgl+}j",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Problem of Bandwidth UNDER-Estimation with Rate-Based Adaption</h2><div><div>In the OFF period, the TCP connection will {{c1::reset the congestion window}}. Chunk download can finish before {{c2::TCP actually converges to the fair share}}, making the {{c3::observed bandwidth}} appear lower.&nbsp;</div></div>",
                        ""
                    ],
                    "guid": "nm.0<)iyy)",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><div>When streaming stored audio and video, the content starts playing within a few seconds of receiving data, instead of waiting for the entire file to download first.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "o)D2JM@Q:8",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Progressive Download vs Streaming</h2><div><div>To account for variations in the network, the client {{c1::pre-fetches}} {{c2::some video ahead}} and {{c1::stores it}} in {{c2::a&nbsp;playout buffer}}. Streaming in this manner typically has two states:</div><div><ol><li>{{c3::Filling state: This happens when the video buffer is empty and the client tries to fill it as soon as possible.}}</li><li>{{c3::Steady state: After the buffer has become full, the client waits for it to become lower than a threshold. The steady state is characterized by these ON-OFF patterns.}}</li></ol></div></div>",
                        ""
                    ],
                    "guid": "oFGt$Yh^;l",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><div><div>Glitches in {{c1::audio}} are generally more noticeable than glitches in {{c1::video}}. Like video, audio can be {{c2::compressed at varying quality levels}}.</div></div>",
                        ""
                    ],
                    "guid": "p74(MsPz`d",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Progressive Download vs Streaming</h2><div><div>While quite simple, downloading the video as a single {{c1::HTTP GET}} request has some disadvantages:</div><ol><li>{{c2::Users often leave the video mid-way. Thus, downloading the entire file can lead to a waste of network resources.}}</li><li>{{c2::The video content that has been downloaded but not played so far would have to be stored. Thus, we will need a video buffer at the client to store this content in memory.}}</li></ol></div>",
                        ""
                    ],
                    "guid": "q0j.LAGS1f",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Streaming</h2><div>Suppose that Bob is using a cloud service to watch video encoded at a rate of 2 Mbps. Suppose that his session lasts for 30 minutes (1800 seconds). How many Mbytes of data are transferred during the 30-minute session? Round your answer to the nearest MB. (For simplification, assume 1 MB = 8,000 Kb).<br></div>",
                        "450 MB<br>\\(2000Kbps * 1800s * \\frac{1MB}{8000Kb} = 450MB\\)"
                    ],
                    "guid": "qEArBX!Nm`",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Throughput-Based Adaptation and its Limitations</h2><div><div>An extra factor is added in quantization because:</div><div><ul><li>We want to be a little conservative in our estimate of the {{c1::future bandwidth}} to avoid any re-buffering</li><li>If the chunks are {{c2::VBR-encoded}}, their bitrate can exceed the nominal bitrate</li><li>There are additional {{c3::application and transport-layer overheads}} associated with downloading the chunk and we want to take them into account</li></ul></div></div>",
                        ""
                    ],
                    "guid": "rb2OotdyJ~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>Which&nbsp;of the following applications&nbsp;has less delay tolerance (i.e. a&nbsp;lower&nbsp;threshold&nbsp;in terms of when a packet is considered&nbsp;lost)?<br></div>",
                        "<ul><li>VoIP</li><li>File transfer</li><li>Stored audio and video streaming</li></ul>",
                        "<ul><li><span style=\"color: rgb(0, 0, 255);\">VoIP</span></li><li>File transfer</li><li>Stored audio and video streaming</li></ul>"
                    ],
                    "guid": "s)j{=?Ta&J",
                    "note_model_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Delay Jitter</h2><div>A longer jitter buffer reduces the number of packets that are discarded because {{c1::they were received too late}}, but that adds to {{c1::the end-to-end delay}}. A shorter jitter buffer will not add to the {{c2::end-to-end delay}} as much, but that can lead to {{c2::more dropped packets}}, which reduces the speech quality.</div>",
                        ""
                    ],
                    "guid": "s5p`<HRd1q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>TCP eliminates packet loss by {{c1::retransmitting lost packets}}.<br></div>",
                        ""
                    ],
                    "guid": "t;uFil~w|W",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>Interleaving works by {{c1::mixing chunks of audio together}} so that {{c2::if one set of chunks is lost, the lost chunks aren’t consecutive}}. Interleaving does not transmit {{c3::ANY redundant data, and so it doesn’t add extra bandwidth requirements or bandwidth overhead}}.&nbsp;<br></div>",
                        "The idea is that many smaller audio gaps are preferable to one large audio gap."
                    ],
                    "guid": "tyv|nFR0JN",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Metrics</h2><div><div>There are three major QoS metrics for VoIP:</div><ul><li>{{c1::end-to-end delay}}</li><li>{{c1::jitter}}</li><li>{{c1::packet loss}}</li></ul></div>",
                        ""
                    ],
                    "guid": "u2(XZFHR}a",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Delay Jitter</h2><div>With large jitter, we end up with more {{c1::delayed packets}} that end up getting discarded, and that can lead to a gap in the audio. Because the human ear is pretty intolerant of audio gaps, audio gaps should ideally be kept below {{c2::30ms}}, but depending on the type of voice codec used and other factors, audio gaps between {{c2::30}} to {{c2::75ms}} can be acceptable.<br></div>",
                        ""
                    ],
                    "guid": "uH=NKVdNVR",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Metrics</h2><div>Since delays are so impactful for VoIP, VoIP applications frequently have {{c1::delay thresholds}}, such as at 400ms, and {{c2::discard any received packets}} with a delay greater than {{c1::that threshold}}.<br></div>",
                        ""
                    ],
                    "guid": "uW][$!YVNy",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Streaming</h2><div>Content providers store all the intelligence to download the video at the server.<br></div><div>T/F?</div>",
                        "False.<br>The server is essentially stateless and the intelligence to download the video will be stored at the client."
                    ],
                    "guid": "uh+rR$J^Wz",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Why Do We Use {{c1::HTTP}}?</h2><div>Content providers ended up using {{c1::HTTP::application protocol}} for video delivery. The {{c2::server}} is essentially {{c3::stateless}} and the intelligence to download the video will be stored at {{c2::the client}}. A major advantage of this is that content providers could use the already existing {{c4::CDN infrastructure}}. Moreover, it also made {{c5::bypassing middleboxes and firewalls}} easier as they already understood {{c1::HTTP}}.<br></div><br>",
                        ""
                    ],
                    "guid": "vIT{JV16Nf",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>Error concealment, is {{c1::basically “guessing” what the lost audio packet might be}}.<br></div>",
                        ""
                    ],
                    "guid": "w^}u<;00G_",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>How to Handle Network and User Device Diversity?</h2><div>At the beginning of every video session, the client first downloads {{c1::a&nbsp;manifest&nbsp;file}}, which contains {{c2::all the metadata information about the video content and the associated URLs}}.<br></div>",
                        ""
                    ],
                    "guid": "x<W4Rg0J1R",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><div>Streaming audio and video is interactive and should have a continuous playout.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "xX|eQB[s4B",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Background: Video and Audio Characteristics</h2><div>Streaming live audio and video is usually not interactive and is delay-sensitive.<br></div><div>T/F?</div>",
                        "True"
                    ],
                    "guid": "yL!f!Oy6F!",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>VoIP protocols have three major methods of dealing with packet loss:</div><div><ul><li>{{c1::FEC (Forward Error Correction)}}</li><li>{{c1::interleaving}}</li><li>{{c1::error concealment}}</li></ul></div>",
                        ""
                    ],
                    "guid": "yU_M[nfU~@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>QoS for VoIP: Packet Loss</h2><div>FEC&nbsp;(Forward Error Correction): in general, FEC works by {{c1::transmitting redundant data alongside the main transmission}}.<br></div>",
                        ""
                    ],
                    "guid": "z*1H,4x{Fs",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 11: Applications: Video</h1>\n<h2>Streaming</h2><div>Video delivery is tolerant to packet losses. Reliability of packet delivery is not that important.<br></div><div>T/F?</div>",
                        "False.<br>Video needs to be decoded at the client. This decoding might fail if some data is lost. For instance, if an I-frame is lost partially, we may not be able to obtain the RGB matrices correctly. Similarly, if an I-frame was lost, P-frame can not be decoded."
                    ],
                    "guid": "zR(N_~A;t-",
                    "note_model_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson11",
                        "lesson_quiz"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        },
        {
            "__type__": "Deck",
            "children": [],
            "crowdanki_uuid": "0e252390-a05c-11ed-8334-83f82e164357",
            "deck_config_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "desc": "",
            "dyn": 0,
            "extendNew": 0,
            "extendRev": 0,
            "media_files": [
                "consistentHashing.png"
            ],
            "name": "Lesson 12: Applications: CDNs and Overlay Networks",
            "newLimit": null,
            "newLimitToday": null,
            "notes": [
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Policy for Server Selection</h2><div>A {{c1::simple load balancing}} technique does not work well for server selection because it may {{c2::forward to a server without the content cached}}.</div>",
                        "Another another server may have the content requested, but it is not selected because the client is directed to a less-loaded server"
                    ],
                    "guid": "A(zFBme6fn",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Network Protocols Used for Cluster/Server Selections</h2><div><div>Three network protocols that can be used for server selection are:</div><ul><li>{{c1::DNS}}</li><li>{{c1::HTTP redirection}}</li><li>{{c1::IP Anycast}}</li></ul></div>",
                        ""
                    ],
                    "guid": "A0Pn4&58lc",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1><br><h2>Consistent Hashing</h2><div>Consistent hashing tends to balance load, by assigning roughly the same number of {{c1::content IDs}}, and requires {{c2::relatively little movement of these content IDs}} when nodes join and leave the system.<br></div>",
                        ""
                    ],
                    "guid": "B1&B9F}~>$",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Introduction to Content Distribution Networks</h2><h3>Major challenges that Internet applications face</h3><div>{{c1::Inefficient routing protocols}}.&nbsp;{{c2::BGP}} has worked really well over the decades and the massive growth of the best-effort Internet, but it was never designed for modern demands. Between the algorithm only using {{c3::AS hop count}} and not taking into account other factors (like congestion, latencies, etc.), and {{c2::BGP}}’s well-documented vulnerabilities to malicious actions - it’s not an efficient inter-domain routing protocol for the modern Internet.</div>",
                        ""
                    ],
                    "guid": "B=5hPCp[1K",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>How does DNS work?</h3><div><div>There are other service offered by DNS:</div><div><ul><li>{{c1::Mail server/Host aliasing}}: DNS is used to get the {{c2::canonical}} hostname (and IP address) for an {{c2::alias}} hostname.</li><li>{{c1::Load distribution}}: When a client makes a DNS query, the DNS server responds with {{c3::a set of addresses but rotates the address ordering with each reply}}.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "CXmV5?3;L+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>How does DNS work?</h3><div>First, DNS provides a distributed database implemented over {{c1::a hierarchy of servers}}. Second,&nbsp;DNS is an {{c2::application}} layer protocol that allows hosts to query this database and provide the translation of hostnames to IP addresses.</div>",
                        ""
                    ],
                    "guid": "C|,GJ.NGBm",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>How DNS works: Recursive and Iterative DNS queries</h3><div>In the&nbsp;{{c1::iterative}} query&nbsp;process, the querying host is {{c2::referred to a different DNS server in the chain, until it can fully resolve the request}}.<br></div>",
                        ""
                    ],
                    "guid": "E*@mc{Nwv5",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>CDNs and the Internet Ecosystem</h2><div><div>Major players (e.g., Google, Facebook), have shifted the focus from {{c1::traditional tier-1 ISPs}} to {{c2::the edge}} and {{c2::the end users}}.</div></div>",
                        ""
                    ],
                    "guid": "Edl=cnZ$!$",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Introduction to Content Distribution Networks</h2><h3>Major challenges that Internet applications face</h3><div><div>{{c1::Inefficient communication protocols}}.&nbsp;Like BGP, {{c2::TCP}} was not designed for the demands of the modern Internet. Although it provides reliability and congestion avoidance, there’s a lot of {{c3::overhead}}.</div></div>",
                        ""
                    ],
                    "guid": "Ib~27{~M2/",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Introduction to Content Distribution Networks</h2><h3>Major challenges that Internet applications face</h3><div><div>Application limitations and {{c1::slow rate of change adoption}}.&nbsp;As mentioned with TCP, even if there are better protocols developed to meet the needs of the modern Internet, especially with video streaming, historically it can take a long time for better protocols to get adopted.</div></div>",
                        ""
                    ],
                    "guid": "L0_(rSnLwl",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1><br><h2>Introduction to Content Distribution Networks</h2><div>CDNs are {{c1::networks of multiple, geographically distributed servers and/or data centers}}, with {{c2::copies of content}}, that direct users to {{c3::a server or server cluster that can best serve the user’s request}}.<br></div>",
                        ""
                    ],
                    "guid": "L8*`5+)R^c",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>How DNS works: Recursive and Iterative DNS queries</h3><div>The usual pattern is for the {{c1::first}} query from the requesting host to the local DNS server to be {{c2::recursive}}, and the {{c1::remaining queries}} to be {{c2::iterative}}.<br></div>",
                        ""
                    ],
                    "guid": "LUX2>j(Z*8",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>The DNS hierarchy</h3><div><div>The DNS hierarchy consists of the following types of servers:&nbsp;</div><div><ul><li>{{c1::Root DNS}} servers: There are {{c2::13::quantity}} servers, each of which is a network of replicated servers mostly located in North America. As of May 2019, the total number of server instances is 984.</li><li>{{c1::Top level domain (TLD)}}&nbsp; Servers: These servers are responsible for the top level domains such as {{c3::.com, .org, .edu, etc}} and also all of the country top level domains.</li><li>{{c1::Authoritative}} servers: These keeps an organization's DNS records that need to be {{c4::publicly accessible}}.</li><li>{{c1::Local DNS}} servers. Each {{c5::Internet Service Provider (ISP), such as a university, a company or a small residential ISP}}, has one or more of these servers.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "M%H1gCBpiC",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks</h1><h2>Server Selection Strategies: IP Anycast</h2><div>Server selection using anycast routing does not take {{c1::link congestion}} into account. Thus, it is not commonly used in practice by {{c2::CDNs}}.&nbsp;However, it is used is in routing to {{c2::DNS servers}}.<br></div>",
                        "Google provides public DNS servers that can be used for resolving domain names to IP address. In order to serve clients from multiple locations, it has multiple DNS servers distributed geographically with all of the servers being assigned the same address."
                    ],
                    "guid": "MEHBxbPiiM",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Introduction to Content Distribution Networks</h2><h3>Major challenges that Internet applications face</h3><div><div>{{c1::Unreliable networks}}.&nbsp;Outages happen all the time. Some are {{c2::accidents}} - like misconfigured routers, power outages in an area, accidental severing of undersea fiber cables. Others are {{c2::malicious}}, such as {{c3::DDoS attacks}} or {{c3::BGP hijacking}}. And others yet are from {{c2::natural disasters}}.</div></div>",
                        ""
                    ],
                    "guid": "Mg>*leoH<P",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>CDN Server Selection</h2><div>There are two main steps selecting a server:</div><div><ol><li>{{c1::Mapping the client to a cluster}}</li><li>{{c1::Selecting a server from the cluster}}</li></ol></div>",
                        ""
                    ],
                    "guid": "O*aaq-*T.^",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>More on DNS: Resource Records and Messages</h2><div><div>The most common types of resource records are:</div><div><ul><li>TYPE={{c1::A}}:&nbsp;the name is {{c2::a domain name}} and value is {{c2::the IP address of the hostname. (abc.com, 190.191.192.193, A)}}</li><li>TYPE={{c1::NS}}:&nbsp;the name is {{c3::the domain name}}, and the value is {{c3::the appropriate authoritative DNS server that can obtain the IP addresses for hosts in that domain. (abc.com, dns.abc.com, NS)}}</li><li>TYPE={{c1::CNAME}}:&nbsp;the name is {{c4::the alias hostname}}, and the value is {{c4::the canonical name, (abc.com, relay1.dnsserver.abc.com, CNAME)}}</li><li>TYPE={{c1::MX}}:&nbsp;the name is {{c5::the alias hostname of a mail server}}, and the Value is {{c5::the canonical name of the email server. (abc.com, mail.dnsserver.abc.com, MX)}}</li></ul></div></div>",
                        ""
                    ],
                    "guid": "O{1nG>)/g-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Policy for Server Selection</h2><div>Requests can be {{c1::mapped}} to servers based on the content. Essentially, requests for the same piece of content can be {{c1::mapped}} to the same machine by using some sort of {{c2::content-based hashing}}.</div>",
                        ""
                    ],
                    "guid": "P9PI<sFvLv",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Introduction to Content Distribution Networks</h2><div><div>There are three major drawbacks to puting content on a single, publicly accessible web server:</div><div><ol><li>{{c1::Global users}} -&nbsp;the server-to-client packets will have to traverse lots of communication links between many ISPs</li><li>{{c1::Popular content}} -&nbsp;wasteful for a single massive data center to repeatedly be sending the exact same data over the same communication link over and over again</li><li>{{c1::Single point of failure}} - a natural disaster or a massive power outage in the area, the entire data center could be taken temporarily or permanently offline</li></ol></div></div>",
                        "Scalability is also an issue."
                    ],
                    "guid": "Q$Xo&wwy:;",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>CDNs and the Internet Ecosystem</h2><div><div><ul><li>Some CDNs are&nbsp;{{c1::private}}, such as {{c2::Google’s}} CDN, which distributes YouTube videos and other content. Private CDNs are CDNs that are owned by the content provider.</li><li>Other CDNs are&nbsp;{{c1::third party}}, such as {{c2::Akamai}} and {{c2::Limelight}}. Third party CDNs distribute content on behalf of multiple content providers.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "b3sZg`&9a*",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Policy for Server Selection</h2><div>Content servers fetch content from an origin server in a {{c1::lazy}} manner. A content server waits for a request from a {{c2::client}}, does its own request to the {{c2::origin}}, then responds to the {{c2::client}}. It also {{c3::keeps a copy cached so it can skip the origin request in the futre}}.</div>",
                        ""
                    ],
                    "guid": "cM[D@=ntnT",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>More on DNS: Resource Records and Messages</h2><div>The DNS servers store the mappings between hostnames and IP addresses as {{c1::resource records (RRs)}}. These are contained {{c2::inside the DNS reply messages}}.&nbsp;A DNS {{c1::resource record}} has four fields: ({{c3::name, value, Type, TTL::list 4}}).&nbsp;The {{c3::TTL}}&nbsp;specifies the time (in sec) a record {{c4::should remain in the cache}}.&nbsp;<br></div>",
                        "The name and the value depend on the type of the resource record."
                    ],
                    "guid": "dtFytzF}qT",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1><br><h2>Introduction to Content Distribution Networks</h2><h3>Major challenges that Internet applications face</h3>{{c1::Peering point}} congestion. There’s the business and financial motivation to upgrade the “first mile” (like {{c2::web hosts}}) and the “last mile” ({{c2::end users}}), but not for the “middle mile” where expensive {{c1::peering points}} between networks with no revenue happen.<br>",
                        ""
                    ],
                    "guid": "f>8},~3La7",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>CDNs Server Placement Approaches</h2><div>In the {{c1::Bring Home}} philosophy, CDNs {{c2::place fewer larger server clusters at key points (typically in {{c3::IXPs}}, not in {{c3::access networks}})}}.<br></div>",
                        ""
                    ],
                    "guid": "f>z}y.@Y_~",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>How does DNS work?</h3><div><div>Here are the main steps that a host takes to use DNS:&nbsp;</div><div><ol><li>The user host runs the {{c1::client side}} of the DNS application</li><li>The browser extracts the {{c2::hostname}} to an external site and passes it to client side of the DNS application.&nbsp;&nbsp;</li><li>{{c3::DNS Client}} sends a query containing the hostname of DNS</li><li>{{c3::DNS Client}} eventually receives a reply which includes the {{c4::IP address}} for the hostname</li><li>As soon as the host receives the IP addresses, it can {{c5::initiate a TCP connection to the HTTP server located at that port at that IP}}</li></ol></div></div>",
                        ""
                    ],
                    "guid": "g4,eh[l6Bg",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Cluster Selection Strategies</h2><div><div>Researchers have proposed the design of a distributed system that uses a two-layered system:</div><div><ul><li>A coarse-grained global layer operates at larger time scales (timescale of {{c1::a few tens of seconds (or minutes)}}). This layer has a global view of client quality measurements.</li><li>A fine-grained per-client decision layer that operates at {{c1::the millisecond}} timescale. It makes actual decisions upon a client request. This is based on the latest (but possibly stale) pre-computed global model and up-to-date per-client state.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "gGH9z?Ne#q",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>How DNS works: Recursive and Iterative DNS queries</h3><div>In the {{c1::recursive}} query, the querying host, and each DNS server in the chain, queries the next server and delegates the query to it.<br></div>",
                        ""
                    ],
                    "guid": "gsq]vqtjb=",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Cluster Selection Strategies</h2><div>A second challenge for a matching approach is that it needs to have data for different {{c1::subnet-cluster pairs}}. Thus, some of the clients {{c2::deliberately need to be routed to sub-optimal clusters}}.&nbsp;</div>",
                        ""
                    ],
                    "guid": "i_znj8!S>&",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Cluster Selection Strategies</h2><div>There are various e2e metrics that can be used:</div><div><ul><li>{{c1::network}}-layer metrics such as {{c2::delay}}, {{c2::available bandwidth}} or both</li><li>{{c1::application}}-layer metrics metrics such as {{c3::video re-buffering ratio}} and {{c3::average bitrate}}</li></ul></div>",
                        ""
                    ],
                    "guid": "j;2j;Te|E+",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>More on DNS: Making Responses Faster with Caching</h2><div>The idea of DNS Caching is that,&nbsp;in both {{c1::iterative and recursive}} queries, after a server receives the DNS reply of mapping from any host to IP address, it {{c2::stores this information in the Cache memory}} before sending it to the client.<br></div>",
                        ""
                    ],
                    "guid": "joHvd(R;in",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Cluster Selection Strategies</h2><div><div>How to obtain real-time measurements?&nbsp;</div><div><ul><li>Active measurements: The LDNS could probe multiple clusters, such as by sending a ping request to multiple clusters for monitoring the {{c1::RTT}} and then use the “closest” server. However, most of the LDNS are not equipped to perform such active measurements. Furthermore, this would also create a lot of traffic.</li><li>Passive measurements:&nbsp;The name server system in {{c2::the CDN}} could keep a track of the performance metrics based on the current traffic conditions.</li></ul></div></div>",
                        ""
                    ],
                    "guid": "mwl]TjI@dO",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Cluster Selection Strategies</h2><div><div>Choosing the geographically closest cluster has some limitations:</div><div><ul><li>{{c1::Using the location of the Local DNS}}. A recursive DNS query will have {{c2::the users local DNS (likely in the ISP)}} making queries to {{c2::the CDN DNS}} which will get the LDNS location.</li><li>{{c1::Closest cluster may not be the best choice}}. This can happen because of {{c3::routing inefficiencies}} or the {{c3::cluster itself could be congested}}.&nbsp;</li></ul></div></div>",
                        "Most of the time, the location of the LDNS is fine, but some customers use a remote LDNS."
                    ],
                    "guid": "pN4e5/FRAm",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>How a CDN Operates</h2><div>By intercepting {{c1::DNS}} requests, CDNs have the opportunity to {{c2::choose where to direct users}}, based on location and/or current conditions.</div>",
                        ""
                    ],
                    "guid": "tfG9U@^cO@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: The DNS Protocol</h2><h3>The DNS hierarchy</h3><div>When a client requests the IP address for a specific domain name, it will:</div><div><ol><li>First contact the&nbsp;{{c1::root server}}, which will return the IP address of {{c2::a&nbsp;top level domain server}}.</li><li>Then the client will contact {{c2::that top level domain server}} to receive a referral to {{c3::the&nbsp;authoritative server}}.</li><li>Finally, the client will make a query to {{c3::that authoritative server}} to receive {{c4::the domain-to-IP mapping}} and to finally reach the requested domain.&nbsp;</li></ol></div>",
                        ""
                    ],
                    "guid": "tg8b:L|X(@",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: IP Anycast</h2><div>The main goal of IP anycast is to {{c1::route a client to the “closest” server}}, as determined by {{c2::BGP (Border Gateway Protocol)}}. This is achieved by {{c3::assigning the same IP address to multiple servers belonging to different clusters}}. When a BGP router receives multiple route advertisements for this IP address, it would treat them as {{c4::multiple paths to the same locations}}, although, in reality {{c4::these routes correspond to different physical locations}}.<br></div>",
                        ""
                    ],
                    "guid": "ty}$/og;j-",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Server Selection Strategies: HTTP Redirection</h2><div>In HTTP redirection, when a client sends a GET request to a server, say A, it can redirect the client to another server, say B, by sending {{c1::an HTTP response with a code 3xx and the name of the new server}}.<br></div>",
                        "YouTube first tries to use HTTP redirection for sharing the load within a cluster, and then can also use it to redirect clients to a different cluster if the former is not enough."
                    ],
                    "guid": "uLFk/Y(|ay",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Consistent Hashing</h2><div>The main idea behind consistent hashing is that {{c1::servers and the content objects are mapped to the same ID space}}.</div><div><ul><li>Imagine we map the servers to {{c2::the edge of a circle (say uniformly)}}.</li><li>Now, {{c3::the successor server}} for an object ID can be responsible for serving the object.</li><li>The objects that the server was responsible for can now be served by {{c4::the next server}}.</li></ul></div>",
                        "<img src=\"consistentHashing.png\"><b><span style=\"color: rgb(45, 59, 69); font-weight: 400;\"><br></span></b>On a side note, this algorithm was proposed as a part of a popular distributed lookup protocol, known as Chord and was also used for content lookup in peer-to-peer applications such as BitTorrent, Napster."
                    ],
                    "guid": "w-kA2ybkg^",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>Introduction to Content Distribution Networks</h2><h3>Major challenges that Internet applications face</h3><div><div>{{c1::Scalability}}.&nbsp;Demand is variable, whether it be a video unexpectedly going viral, or a planned event (like Black Friday shopping traffic peaks).</div></div>",
                        ""
                    ],
                    "guid": "wmmJg_/h42",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                },
                {
                    "__type__": "Note",
                    "fields": [
                        "<h1>Lesson 12: Applications: CDNs and Overlay Networks<br></h1>\n<h2>CDNs Server Placement Approaches</h2><div>In the {{c1::Enter Deep}} philosophy, CDNs {{c2::place many smaller server clusters into the&nbsp;access networks&nbsp;around the world}}. {{c3::Akamai}} is a good example of a third party CDN with this philosophy, as they have clusters in over 1700 locations.<br></div>",
                        ""
                    ],
                    "guid": "x:k<X^mi0h",
                    "note_model_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
                    "tags": [
                        "lecture",
                        "Lesson12"
                    ]
                }
            ],
            "reviewLimit": null,
            "reviewLimitToday": null
        }
    ],
    "crowdanki_uuid": "0e0a9066-a05c-11ed-8334-83f82e164357",
    "deck_config_uuid": "0e0a939a-a05c-11ed-8334-83f82e164357",
    "deck_configurations": [
        {
            "__type__": "DeckConfig",
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "0e0a939a-a05c-11ed-8334-83f82e164357",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0,
                    1440.0,
                    4320.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 3,
                "mult": 0.75
            },
            "maxTaken": 60,
            "name": "Trickle 2",
            "new": {
                "bury": true,
                "delays": [
                    2.0,
                    10.0,
                    1440.0,
                    4320.0
                ],
                "initialFactor": 2500,
                "ints": [
                    4,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 2,
                "separate": true
            },
            "newGatherPriority": 1,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "replayq": true,
            "rev": {
                "bury": true,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 500
            },
            "reviewOrder": 0,
            "timer": 0
        },
        {
            "__type__": "DeckConfig",
            "autoplay": true,
            "buryInterdayLearning": false,
            "crowdanki_uuid": "eedb0b70-e5c4-11ea-8fe2-e4a7a0580719",
            "dyn": false,
            "interdayLearningMix": 0,
            "lapse": {
                "delays": [
                    10.0,
                    1440.0
                ],
                "leechAction": 1,
                "leechFails": 8,
                "minInt": 1,
                "mult": 0.75
            },
            "maxTaken": 60,
            "name": "Default",
            "new": {
                "bury": true,
                "delays": [
                    2.0,
                    10.0,
                    1440.0,
                    4320.0
                ],
                "initialFactor": 2500,
                "ints": [
                    4,
                    4,
                    0
                ],
                "order": 1,
                "perDay": 50,
                "separate": true
            },
            "newGatherPriority": 0,
            "newMix": 0,
            "newPerDayMinimum": 0,
            "newSortOrder": 0,
            "replayq": true,
            "rev": {
                "bury": true,
                "ease4": 1.3,
                "fuzz": 0.05,
                "hardFactor": 1.2,
                "ivlFct": 1.0,
                "maxIvl": 36500,
                "minSpace": 1,
                "perDay": 500
            },
            "reviewOrder": 0,
            "timer": 0
        }
    ],
    "desc": "",
    "dyn": 0,
    "extendNew": 8,
    "extendRev": 0,
    "media_files": [],
    "name": "GA Tech OMSCS::Computer Networks",
    "newLimit": null,
    "newLimitToday": null,
    "note_models": [
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "eef582ac-e5c4-11ea-8fe2-e4a7a0580719",
            "css": ".card {\n  font-family: arial;\n  font-size: 20px;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n.cloze {\n  font-weight: bold;\n  color: blue;\n}\n\n.cloze-inactive {\n  color: darkslateblue;\n}\n\n.nightMode .cloze {\n  color: lightblue;\n}\n\nul,\nol {\n  display: block;\n  text-align: left;\n  list-style: inside;\n}\n\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n\ntd[colspan]:not([colspan=\"1\"]) {\n    text-align: center;\n}\n\ncode {\n  display: inline-block;\n  white-space: pre;\n  text-align: left;\n  tab-size: 3;\n  background: rgba(7,7,7,0.2);\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Text",
                    "ord": 0,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Extra",
                    "ord": 1,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "OMSCS Cloze",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [],
            "tmpls": [
                {
                    "afmt": "<h6>{{Deck}}</h6>\n{{cloze:Text}}<br><br>\n{{Extra}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Cloze",
                    "ord": 0,
                    "qfmt": "<h6>{{Deck}}</h6>\n{{cloze:Text}}"
                }
            ],
            "type": 1,
            "vers": []
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "94d029ea-7628-11eb-b3ff-e4a7a0580719",
            "css": ".card {\n  font-family: arial;\n  font-size: 20px;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n.cloze {\n  font-weight: bold;\n  color: blue;\n}\n\n.nightMode .cloze {\n  color: lightblue;\n}\n\nul,\nol {\n  display: inline-block;\n  text-align: left; \n}\n\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n\ntd[colspan]:not([colspan=\"1\"]) {\n    text-align: center;\n}\n\ncode {\n  display: inline-block;\n  white-space: pre;\n  text-align: left;\n  tab-size: 3;\n  background: rgba(7,7,7,0.2);\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Front",
                    "ord": 0,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Back",
                    "ord": 1,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "OMSCS Basic",
            "req": [
                [
                    0,
                    "any",
                    [
                        0
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [
                "practice_exam"
            ],
            "tmpls": [
                {
                    "afmt": "{{FrontSide}}\n\n<hr id=answer>\n\n{{Back}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "{{Deck}}<br>\n{{Front}}"
                }
            ],
            "type": 0,
            "vers": []
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "0e109998-a05c-11ed-8334-83f82e164357",
            "css": ".card {\n  font-family: arial;\n  font-size: 20px;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n.cloze {\n  font-weight: bold;\n  color: blue;\n}\n\n.nightMode .cloze {\n  color: lightblue;\n}\n\nul,\nol {\n  display: inline-block;\n  text-align: left; \n}\n\ntable, th, td {\n  border: 1px solid black;\n  border-collapse: collapse;\n}\n\ntd[colspan]:not([colspan=\"1\"]) {\n    text-align: center;\n}\n\ncode {\n  display: inline-block;\n  white-space: pre;\n  text-align: left;\n  tab-size: 3;\n  background: rgba(7,7,7,0.2);\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Header",
                    "ord": 0,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Front",
                    "ord": 1,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "Back",
                    "ord": 2,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": true
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "OMSCS Replace",
            "req": [
                [
                    0,
                    "any",
                    [
                        0,
                        1
                    ]
                ]
            ],
            "sortf": 0,
            "tags": [],
            "tmpls": [
                {
                    "afmt": "<div>{{Deck}}</div>\n<div>{{Header}}</div>\n{{Back}}",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "Card 1",
                    "ord": 0,
                    "qfmt": "<div>{{Deck}}</div>\n<div>{{Header}}</div>\n{{Front}}"
                }
            ],
            "type": 0,
            "vers": []
        },
        {
            "__type__": "NoteModel",
            "crowdanki_uuid": "0e1cb2dc-a05c-11ed-8334-83f82e164357",
            "css": "/* GENERAL CARD STYLE */\n.card {\n  font-family: \"Helvetica LT Std\", Helvetica, Arial, Sans;\n  font-size: 150%;\n  text-align: center;\n  color: black;\n  background-color: white;\n}\n\n/* OCCLUSION CSS START - don't edit this */\n#io-overlay {\n  position:absolute;\n  top:0;\n  width:100%;\n  z-index:3\n}\n\n#io-original {\n  position:relative;\n  top:0;\n  width:100%;\n  z-index:2;\n  visibility: hidden;\n}\n\n#io-wrapper {\n  position:relative;\n  width: 100%;\n}\n/* OCCLUSION CSS END */\n\n/* OTHER STYLES */\n#io-header{\n  font-size: 1.1em;\n  margin-bottom: 0.2em;\n}\n\n#io-footer{\n  max-width: 80%;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 0.8em;\n  font-style: italic;\n}\n\n#io-extra-wrapper{\n  /* the wrapper is needed to center the\n  left-aligned blocks below it */\n  width: 80%;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 0.5em;\n}\n\n#io-extra{\n  text-align:center;\n  display: inline-block;\n}\n\n.io-extra-entry{\n  margin-top: 0.8em;\n  font-size: 0.9em;\n  text-align:left;\n}\n\n.io-field-descr{\n  margin-bottom: 0.2em;\n  font-weight: bold;\n  font-size: 1em;\n}\n\n#io-revl-btn {\n  font-size: 0.5em;\n}\n\n/* ADJUSTMENTS FOR MOBILE DEVICES */\n\n.mobile .card, .mobile #content {\n  font-size: 120%;\n  margin: 0;\n}\n\n.mobile #io-extra-wrapper {\n  width: 95%;\n}\n\n.mobile #io-revl-btn {\n  font-size: 0.8em;\n}\n",
            "flds": [
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Liberation Sans",
                    "media": [],
                    "name": "ID (hidden)",
                    "ord": 0,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Header",
                    "ord": 1,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Image",
                    "ord": 2,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Question Mask",
                    "ord": 3,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Footer",
                    "ord": 4,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Remarks",
                    "ord": 5,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Sources",
                    "ord": 6,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Extra 1",
                    "ord": 7,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Extra 2",
                    "ord": 8,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Answer Mask",
                    "ord": 9,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                },
                {
                    "collapsed": false,
                    "description": "",
                    "excludeFromSearch": false,
                    "font": "Arial",
                    "media": [],
                    "name": "Original Mask",
                    "ord": 10,
                    "plainText": false,
                    "rtl": false,
                    "size": 20,
                    "sticky": false
                }
            ],
            "latexPost": "\\end{document}",
            "latexPre": "\\documentclass[12pt]{article}\n\\special{papersize=3in,5in}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amssymb,amsmath}\n\\pagestyle{empty}\n\\setlength{\\parindent}{0in}\n\\begin{document}\n",
            "latexsvg": false,
            "name": "Image Occlusion Enhanced",
            "req": [
                [
                    0,
                    "any",
                    [
                        2
                    ]
                ]
            ],
            "sortf": 1,
            "tags": [],
            "tmpls": [
                {
                    "afmt": "{{#Image}}\n<div id=\"io-header\">{{Header}}</div>\n<div id=\"io-wrapper\">\n  <div id=\"io-overlay\">{{Answer Mask}}</div>\n  <div id=\"io-original\">{{Image}}</div>\n</div>\n{{#Footer}}<div id=\"io-footer\">{{Footer}}</div>{{/Footer}}\n<button id=\"io-revl-btn\" onclick=\"toggle();\">Toggle Masks</button>\n<div id=\"io-extra-wrapper\">\n  <div id=\"io-extra\">\n    {{#Remarks}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Remarks</div>{{Remarks}}\n      </div>\n    {{/Remarks}}\n    {{#Sources}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Sources</div>{{Sources}}\n      </div>\n    {{/Sources}}\n    {{#Extra 1}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Extra 1</div>{{Extra 1}}\n      </div>\n    {{/Extra 1}}\n    {{#Extra 2}}\n      <div class=\"io-extra-entry\">\n        <div class=\"io-field-descr\">Extra 2</div>{{Extra 2}}\n      </div>\n    {{/Extra 2}}\n  </div>\n</div>\n\n<script>\n// Toggle answer mask on clicking the image\nvar toggle = function() {\n  var amask = document.getElementById('io-overlay');\n  if (amask.style.display === 'block' || amask.style.display === '')\n    amask.style.display = 'none';\n  else\n    amask.style.display = 'block'\n}\n\n// Prevent original image from loading before mask\naFade = 50, qFade = 0;\nvar mask = document.querySelector('#io-overlay>img');\nfunction loaded() {\n    var original = document.querySelector('#io-original');\n    original.style.visibility = \"visible\";\n}\nif (mask === null || mask.complete) {\n    loaded();\n} else {\n    mask.addEventListener('load', loaded);\n}\n</script>\n{{/Image}}\n",
                    "bafmt": "",
                    "bfont": "",
                    "bqfmt": "",
                    "bsize": 0,
                    "did": null,
                    "name": "IO Card",
                    "ord": 0,
                    "qfmt": "{{#Image}}\n<div id=\"io-header\">{{Header}}</div>\n<div id=\"io-wrapper\">\n  <div id=\"io-overlay\">{{Question Mask}}</div>\n  <div id=\"io-original\">{{Image}}</div>\n</div>\n<div id=\"io-footer\">{{Footer}}</div>\n\n<script>\n// Prevent original image from loading before mask\naFade = 50, qFade = 0;\nvar mask = document.querySelector('#io-overlay>img');\nfunction loaded() {\n    var original = document.querySelector('#io-original');\n    original.style.visibility = \"visible\";\n}\nif (mask === null || mask.complete) {\n    loaded();\n} else {\n    mask.addEventListener('load', loaded);\n}\n</script>\n{{/Image}}\n"
                }
            ],
            "type": 0,
            "vers": []
        }
    ],
    "notes": [],
    "reviewLimit": null,
    "reviewLimitToday": null
}